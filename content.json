{"meta":{"title":"Hexo","subtitle":"","description":"","author":"不知名小白菜","url":"https://222cabbage.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-05-12T18:12:36.201Z","updated":"2022-05-12T15:59:45.020Z","comments":false,"path":"books/index.html","permalink":"https://222cabbage.github.io/books/index.html","excerpt":"","text":""},{"title":"我","date":"2022-05-13T06:12:28.221Z","updated":"2022-05-13T06:12:28.221Z","comments":false,"path":"about/index.html","permalink":"https://222cabbage.github.io/about/index.html","excerpt":"","text":"只是一个菜菜QQ：1305970446 WeChat：QZHZD6"},{"title":"分类","date":"2022-05-13T03:00:34.720Z","updated":"2022-05-13T03:00:34.720Z","comments":false,"path":"categories/index.html","permalink":"https://222cabbage.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-12T15:59:45.021Z","updated":"2022-05-12T15:59:45.021Z","comments":true,"path":"links/index.html","permalink":"https://222cabbage.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-05-12T18:23:13.873Z","updated":"2022-05-12T15:59:45.022Z","comments":false,"path":"repository/index.html","permalink":"https://222cabbage.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-13T03:03:19.251Z","updated":"2022-05-13T03:03:19.251Z","comments":false,"path":"tags/index.html","permalink":"https://222cabbage.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于uniapp和uview1.0的简易表单生成器","slug":"Component1","date":"2022-05-17T16:51:43.000Z","updated":"2022-05-17T16:55:24.158Z","comments":true,"path":"2022/05/18/Component1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/Component1/","excerpt":"","text":"基于uniapp和uview1.0的简易表单生成器在新的项目中，有的表单项相同，那么能不能将表单form-item循环生成出来？只需要传递配置项与规则即可自动生成 说干就干 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221​```//表单Form.vue封装 基于uview1.0的input输入框 可以传递类型为text，textarea或者select下拉框//其他类型需要使用插槽或者其他方式插入 可以绑定form数据&lt;template&gt; &lt;view class=&quot;&quot;&gt; &lt;view class=&quot;formbox&quot;&gt; &lt;u-form :model=&quot;form&quot; ref=&quot;uForm&quot; label-width=&quot;150rpx&quot;&gt; &lt;u-form-item v-for=&quot;(item,index) in formItems&quot; :key=&quot;index&quot; :label=&quot;item.labelName&quot; :prop=&quot;item.prop&quot; :border-bottom=&quot;item.borderBottom&quot; :label-width=&quot;item.labelWidth&quot; :style=&quot;&#123;&#x27;position&#x27; : item.prop === &#x27;des&#x27; ? &#x27;relative&#x27; : &#x27;&#x27; &#125;&quot; &gt; &lt;u-input v-if=&quot;item.showInput&quot; v-model=&quot;form[item.prop]&quot; :placeholder=&quot;item.placeholder&quot; :type=&quot;item.type&quot; :border=&quot;item.border&quot; :height=&quot;item.height&quot; :class=&quot;item.class&quot; :maxlength=&quot;item.maxlength&quot; :custom-style=&quot;item.inputStyle ? item.inputStyle : null&quot; :clearable=&quot;false&quot; @click=&quot;clickChange(item)&quot;/&gt; &lt;view v-if=&quot;item.prop === &#x27;fileList&#x27;&quot; class=&quot;filebox&quot;&gt; &lt;view class=&quot;title&quot;&gt; 请上传附件（&#123;&#123; fileLength &#125;&#125;/5） &lt;/view&gt; &lt;view class=&quot;&quot;&gt; &lt;u-upload ref=&quot;uUpload&quot; :action=&quot;action&quot; :auto-upload=&quot;false&quot; max-count=&quot;5&quot; @on-list-change=&quot;imgChange&quot; &gt;&lt;/u-upload&gt; &lt;/view&gt; &lt;view class=&quot;uploadtip&quot;&gt; &lt;u-icon name=&quot;info-circle&quot; color=&quot;#F7B500&quot; size=&quot;26&quot; style=&quot;margin-right: 12rpx;&quot; &gt;&lt;/u-icon&gt; 附件支持图片和视频,支持jpg/png/mp4格式 &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;countbox&quot; v-if=&quot;item.prop === &#x27;des&#x27;&quot;&gt; &#123;&#123; form.des.length ? form.des.length : 0 &#125;&#125;/300 &lt;/view&gt; &lt;/u-form-item&gt; &lt;/u-form&gt; &lt;u-picker mode=&quot;time&quot; :params=&quot;params&quot; v-model=&quot;showList[&#x27;timeshow&#x27;]&quot; @confirm=&quot;timechange&quot; @cancel=&quot;timecancel&quot;&gt;&lt;/u-picker&gt; &lt;view v-if=&quot;methodsList.length&quot;&gt; &lt;u-action-sheet v-for=&quot;(item,index) in methodsList&quot; :key=&quot;index&quot; :list=&quot;paramsData[item.propList]&quot; v-model=&quot;showList[item.prop + &#x27;show&#x27;]&quot; @click=&quot;selectchange&quot; &gt;&lt;/u-action-sheet&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:&#123; // 传递的下拉框数据 paramsData:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, rules:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, formItems:&#123; type:Array, default:()=&gt;([]) &#125; &#125;, data()&#123; return &#123; // 数据绑定 form:&#123;&#125;, // 控制显示 showList:&#123;&#125;, params: &#123; year: true, month: true, day: true, hour: true, minute: true, second: false &#125;, // 非真实地址 action: &#x27;http://www.example.com/upload&#x27;, fileLength:0, methodsList:[], selectList:&#123;&#125; &#125; &#125;, watch:&#123;&#125;, onReady() &#123; this.formItems.forEach((items)=&gt;&#123; this.$set(this.form,items.prop,&#x27;&#x27;) this.$set(this.showList,items.prop + &#x27;show&#x27; ,false) this.form.fileList = [] if(items.type === &#x27;select&#x27;)&#123; if(items.prop === &#x27;time&#x27;) return const dataStr = items.prop + &#x27;List&#x27; const fnStr = items.prop + &#x27;change&#x27; this.methodsList.push(&#123; prop:items.prop, propList:dataStr &#125;) &#125; &#125;) setTimeout(()=&gt;&#123; this.$refs.uForm.setRules(this.rules); &#125;,500) &#125;, methods:&#123; clickChange(item)&#123; this.selectList = &#123; prop:item.prop, formName:item.prop + &#x27;List&#x27; &#125; this.showList[item.prop + &#x27;show&#x27;] = true &#125;, selectchange(index)&#123; if(this.selectList)&#123; this.form[this.selectList.prop] = this.paramsData[this.selectList.formName][index].text; &#125; &#125;, timechange(obj)&#123; let timestr = Object.values(obj).join(&#x27;-&#x27;) this.form.time = timestr &#125;, timecancel()&#123; this.show2 = false &#125;, // 上传图片变化 imgChange(lists,name)&#123; this.fileLength = lists.length this.form.fileList = lists &#125;, validateForm()&#123; let flag this.$refs.uForm.validate(valid =&gt; &#123; if (valid) &#123; // 上传文件 // his.$refs.uUpload[0].upload() flag = true &#125; else &#123; flag = false &#125; &#125;) return flag &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import &#x27;./index.scss&#x27;&lt;/style&gt;//传入配置项 验证规则 export const rules = &#123; content: [ &#123; required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125; ], ...... fileList:[ &#123; type:&#x27;array&#x27;, required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125; ], &#125;//表单配置 export const formItems = [ ...... &#123; labelName:&#x27; &#x27;, labelWidth:&#x27;0&#x27;, type:&#x27;textarea&#x27;, prop:&#x27;content&#x27;, placeholder:&#x27;默认文字&#x27;, height:&#x27;420&#x27;, class:&#x27;desbox&#x27;, border:false, borderBottom:false, maxlength:&#x27;300&#x27;, showInput:true, inputStyle:&#123; &#x27;background&#x27;: &#x27;#F5F5F5&#x27;, &#x27;border-radius&#x27;:&#x27;8px&#x27;, &#x27;padding&#x27;:&#x27;22rpx 26rpx&#x27; &#125; &#125; ]","categories":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}],"tags":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}]},{"title":"JS运算方法-解决小数点运算精度问题","slug":"tips1","date":"2022-05-17T16:39:07.000Z","updated":"2022-05-17T16:51:21.090Z","comments":true,"path":"2022/05/18/tips1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/tips1/","excerpt":"","text":"解决小数点精度问题的JS方法一开始学JS的时候也遇到过小数点精度运算的问题，但是没怎么注意，后来在实习时公司的一个项目需要做到金额的运算 有的金额涉及到了小数点 后运算出的结果会带有很多位小数点 因此就有了这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106解决小数点计算精度问题/** * method ** * add / subtract / multiply /divide * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */export const floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123; times: 1, num: 0 &#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + &#x27;&#x27; var dotPos = strfi.indexOf(&#x27;.&#x27;) var len = strfi.substr(dotPos + 1).length var times = Math.pow(10, len) var intNum = Number(floatNum.toString().replace(&#x27;.&#x27;, &#x27;&#x27;)) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case &#x27;add&#x27;: if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case &#x27;subtract&#x27;: if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case &#x27;multiply&#x27;: result = (n1 * n2) / (t1 * t2) return result case &#x27;divide&#x27;: result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, &#x27;add&#x27;) &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, &#x27;subtract&#x27;) &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, &#x27;multiply&#x27;) &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, &#x27;divide&#x27;) &#125; // exports 暴露出加减乘除四个方法 其他页面引入解构调用 return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;","categories":[{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"}],"tags":[{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Node内置模块","slug":"Node2","date":"2022-05-15T07:16:27.000Z","updated":"2022-05-15T07:17:16.682Z","comments":true,"path":"2022/05/15/Node2/","link":"","permalink":"https://222cabbage.github.io/2022/05/15/Node2/","excerpt":"","text":"Node内置模块","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构","slug":"algorithm1","date":"2022-05-14T07:04:01.000Z","updated":"2022-05-14T07:46:18.604Z","comments":true,"path":"2022/05/14/algorithm1/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/algorithm1/","excerpt":"","text":"数据结构走起！Loading……","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS面试题集合","slug":"Face","date":"2022-05-13T17:40:15.000Z","updated":"2022-05-14T07:09:37.265Z","comments":true,"path":"2022/05/14/Face/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/Face/","excerpt":"","text":"闲了很久，来看看JS面试题 涩涩狗子镇楼！1：延迟加载JS的方式？async 与 defer async 是解析与渲染DOM结构同时进行 defer虽然也是解析script脚本与渲染DOM同时进行，但是会等待DOM结构渲染完成以后再去加载script 12&lt;script defer src=&quot;../&quot;&gt;&lt;script&gt;&lt;script async src=&quot;../&quot;&gt;&lt;script&gt; 2：数据类型javascript数据类型分为基本类型与引用类型两大类 基本类型：string，number，boolean，null，undefined，symbol，bigInt(存在争论，有些人认为不应该) 引用类型：object（object是一个大类，包含对象，数组，函数等引用类型） 3：null和undefined的区别最初javascript木有undefined类型，是作者后续添加的，他本人认为不能将一切表示为无的值都设置为null，可以将无的基本类型设置为undefined 4：&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; 的区别&#x3D;&#x3D; 在数据比较时，会隐式转换（调用valueof进行转换对比）,只比较值不比较类型 而&#x3D;&#x3D;&#x3D;比较类型也比较值 必须到完全的相同，因此在项目中比较两个值应该采用&#x3D;&#x3D;&#x3D;的方式 1234let a = 2if（a == &#x27;2&#x27;）&#123; console.log(&#x27; a = &#x27;2&#x27; &#x27;)&#125; 5：微任务和宏任务script脚本中包含同步与异步逻辑，页面会首先执行同步代码，再执行异步代码 而异步代码又区分为微任务和宏任务，与事件循环机制相关 在执行宏任务之前，会查看页面有没有未执行的微任务，先清空页面微任务再执行宏任务 微任务：Promise.then 宏任务：定时器，事件 123456789101112131415161718setTimeout(()=&gt;&#123; console.log(&#x27;123&#x27;)&#125;,2000)new Promise((resolve,reject)=&gt;&#123; console.log(&#x27;promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then1&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then2&#x27;) resolve()&#125;)console.log(&#x27;同步&#x27;)result: &#x27;promise&#x27; &#x27;同步&#x27; &#x27;then1&#x27; &#x27;then2&#x27; &#x27;123&#x27; 6：作用域:smile_cat:1：除了函数外 js是没有块级作用域的 12345678910function aa()&#123; let a = 10&#125;aa()console.log(a) ::a is not definedfor(var i = 1; i &lt; 10 : i++)&#123; &#125;console.log(i) : i = 10 2：作用域链 内部可以访问外部变量 外部无法访问内部变量 从内到外依次查找 遵循内部优先 12345678let a = 10function fn（）&#123; function fnn（）&#123; console.log(a) &#125;fnn()&#125;fn() : 10 3；声明变量不带var 那么就是挂载window上 任意位置都能访问 var a &#x3D; b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 window.b &#x3D; 10 var a,b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 var b &#x3D; 10 4：js有变量提升 国外称为变量悬挂声明 123456function fn()&#123; //var str console.log(str) // undefined var str = 20&#125;fn() 5：优先级 声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升 7：对象1234567console.log([1,2,3] === [1,2,3]) //false 因为两个对象都是new出来的并不相同var a = &#123; a：1&#125;var b = aconsole.log(a === b) //true 因为史诗同一个引用对象 因此相同 对象的key都是字符串类型 1234567891011有趣的面试题var a = &#123;&#125;var b = &#123; key：&#x27;a&#x27;&#125;var c = &#123; key:&#x27;c&#x27;&#125;a[b] = &#x27;123&#x27; // a[obj obj] = &#x27;123&#x27;a[c] = &#x27;456&#x27; // a[obj obj] = &#x27;456&#x27;console.log(a[b]) //console.log(a[obj obj]) 对象是如何查找某个属性？ 对象是通过构造函数生成的 123456789function Fun（）&#123; this.a = &#x27;fun&#x27;&#125;Fun.prototype.a = &#x27;fun原型&#x27;let obj = new Fun()obj.a = &#x27;对象本身&#x27;obj.__proto__.a = &#x27;对象原型&#x27;console.log(obj.a) // &#x27;对象本身&#x27;先查找对象本身 =&gt; 构造函数的内部 =&gt; 对象的原型 =&gt; 构造函数的原型 =&gt; 对象上一层原型 8：作用域 + this指向 + 原型Loading—— 9：判断数组方法使用场景：虚拟dom判断子节点是不是数组 1：isArray 2：instanceof [坑多，typeof更多 不建议用] 3：原型判断 4:：isPrototypeOf() 5：constructor 123456let arr = [1,2,3]console.log(Array.isArray(arr)) //trueconsole.log(arr instanceof Array) //trueconsole.log(Object.prototype.toString.call(arr).indexOf(&#x27;Array&#x27;) != -1) //8 [Object Array]console.log(Array.prototypee.isPrototypeOf(arr)) console.log(arr.constructor.toString().indexOf(&#x27;Array&#x27;) &gt; -1) 10：slice与spliceslice的作用，splice是否会改变原数组 12345678//slice截取作用 参数可以写一个 代表从该参数位置开始截取到最后let arr = [a,b,c,d]let arr2 = arr.slice(1,3) //从索引1开始 截取到3之前一位 [b,c] 返回新数组//splice 删除 ，插入，替换 会改变原数组let arr2 = [a,b,c,d]let arr3 = arr2.splice(1,1) // b 返回删除的元素数组 原本的arr2 [a,c,d]let arr4 = arr2.splice(1,1,&#x27;你好&#x27;) // 从1开始 删除一个元素 在原本位置插入你好 11：多维数组最大值12345678910111213141516let arr = [ [4,4,5], [10,123,123], [123123,12,323,123]]分别找到每个数组最大的值输出[5,123,123123]code：function(arr)&#123; let newArr = [] arr.forEach((iitem,index)=&gt;&#123; newArr.push(Math.max(...item)) &#125;) reurn newArr&#125; 12：字符串新增方法实现某些功能给字符串定义一个方法addStart，当传入该方法一个字符串时，返回当前字符串+参数前缀 123String.prototype.addStr = function(str)&#123; return str + this&#125; 13：找出字符串出现最多次数字符和次数1234567891011121314151617181920212223241:var str = &#x27;111222333333444444444444&#x27;var obj = &#123;&#125;for(var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++ &#125;else&#123; obj[str[i]] = 1 &#125;&#125;console.log(obj) // &#123;a:b:c:d:&#125;///统计最大值var max = 0for(var k in obj)&#123; if(max &lt; obj.key)&#123; max = obj.key &#125;&#125;for(var key in obj)&#123; if(mx == obj[key])&#123; console.log(obj[key]) // 最多次数的字符 console.log(max) //最次数 &#125;&#125; 14：new操作符1：创建一个空的对象 2：将空对象的原型指向构造函数原型 3：将空对作为构造函数上下文（改变this指向） 4：对构造函数有返回值的处理判断 如果这个构造函数返回基本类型 那么会忽略 如果是引用类型则会返回这个引用类型 new失效 1234567891011121314151617181920212223function Fo（）&#123; &#125;console.log(new Fo()) //obj 创建一个空的对象console.log(new Fo.__proto__ === Fo.prototype)console.log()实现一个相同的函数function Fun(age,name)&#123; this.age = age this.name = name&#125;function create(fn,..args)&#123; //创建空对象 var obj = &#123;&#125; //将空对象原型指向构造函数原型 Object.setPrototypeOf(obj,fn.prototype) //改变this指向 var result = fn.apply(obj.args) //最后处理 return result instanceof Object ? result : obj&#125;function(create(Fun,18,&#x27;lisi&#x27;)) 15：闭包1：闭包是什么 一个函数加上到创建函数作用域的连接 闭包关闭了函数在自由变量 js中尽量不要写全局变量 因为系统并不知道什么时候会垃圾回收 2：闭包可以解决什么问题【优点】 内部函数可以访问到外部函数局部变量 3：闭包的缺点 变量会驻留在内存中 造成内存损耗问题 内存泄露是在ie的情况 解决方式手动清空 123456789101112131415161718192021222324function a ()&#123; var b = 10 return function()&#123; console.log(b) &#125;&#125;a()() // a()执行完以后没有销毁 因此a()()能够打印出b//优点let lis = document.getElementsByTagName(&#x27;li&#x27;)for(var i = 0; i &lt; 3; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125;&#125;改造成闭包的形式for(var i = 0; i &lt; 3; i++)&#123; function((i)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125; lis[i] = null //手动清空 &#125;)(i)&#125; 16：原型链17：js继承方式18：call，apply，bind区别19：sort背后原理20：深拷贝与浅拷贝21：本次存储localStorage&#x2F;sessionStorage与cookie区别未完待续……","categories":[{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"HaoUI第二次尝试","slug":"HaoUI2","date":"2022-05-13T04:08:17.000Z","updated":"2022-05-13T06:16:36.669Z","comments":true,"path":"2022/05/13/HaoUI2/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI2/","excerpt":"","text":"之前完成了h-icon与h-button的封装，今天来尝试一下完成HaoUI其他组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"HaoUI开始","slug":"HaoUI1","date":"2022-05-12T17:45:55.000Z","updated":"2022-05-13T04:13:48.598Z","comments":true,"path":"2022/05/13/HaoUI1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI1/","excerpt":"","text":"HaoUI h-icon 与 h-buttonh-icon 图标组件 h-button按钮组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"邂逅Node","slug":"Node1","date":"2022-05-12T17:20:29.000Z","updated":"2022-05-15T07:18:40.385Z","comments":true,"path":"2022/05/13/Node1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/Node1/","excerpt":"","text":"邂逅Node1：浏览器内核Geoko，Trident，Webkit，Blink 但是前端经常提到的浏览器内核一般是浏览器的排版引擎 排版引擎 ，浏览器引擎，页面渲染引擎，样排引擎 2：比较常见的javascript引擎SpiderMonkey：js作者开发 Chakra：微软开发 JavascriptCore：Webkit中的js引擎 apple开发 V8：谷歌的，脱颖而出 V8执行js代码的原理 3：Nodenode是基于v8引擎的js运行环境 如果想在一台电脑运行多个node版本 那么可以借助nvm与n工具 但是这两个工具不支持windows，不过有其他人开发出了支持windows的版本 4：全局对象和模块化开发node index.js env&#x3D;development 可以在后面跟随传递参数 在index.js中根据console.log(process.argv)获取 console.clear() 清空 console.trace() 追踪 打印函数调用栈 常见全局对象require，__dirname，module，URL，exports等，可以去官网查看更多全局对象 模块化最终目的：将程序划分为一个个结构，每个结构包含自己的逻辑到&#x3D;代码，不会影响到其他作用域 可以暴露出变量，函数，对象供其他结构导入使用 js缺陷：var定义的变量作用域问题，没有模块化的问题 可以用立即执行函数解决 1234567var module = (function()&#123; var name = &#x27;zhangsan&#x27; var age = &#x27;21&#x27; return &#123; name,age &#125;&#125;)() Commonjsexports，module.exports导出 require导入 12345a.jsexports.name = &#x27;aaa&#x27;b.jslet a = require(&#x27;a.js&#x27;)console.log(a.name) // &#x27;aaa&#x27; module的原理 每个模块默认有个module指向一个空对象 exports.name &#x3D; name 是将空对象中的name 变为 name require是想办法将这个对象作为返回值返回 实际上是浅层拷贝 module.exports 与 exports 区别 exports是Module的一个实例 实际上exports是使用的module.exports 源码中将 module.exports &#x3D; exports require细节 require的查找规则 1：path&#x2F;http模块 2：.&#x2F; ..&#x2F; &#x2F; 开头 有后缀名按照后缀名查找 否则先查找不带后缀名 &#x3D;&gt; .js &#x3D;&gt; .json &#x3D;&gt; .node 如果是目录名 那么就会去该目录查找.js .json .node 3：既不是模块也不是目录 那么就会去node_modules查找 &#x2F;&#x2F;not found 模块的引入查找是数据结构图的便遍历 广度优先和深度优先 Node是采用的深度优先 AMDrequire.js cuel.js CMDsea.js ES Module使用import 与 export 默认导出exort default 一个模块只能有一个 es module加载过程 是异步的script type&#x3D;”module” 相当于加了async 并不会影响加载 es modole 原理 123456789export &#123; name,age&#125; //相当于 &#123; const name = name, const age = age&#125;//如果是基本类型import &#123; name,age &#125; from &#x27;index.js&#x27;name = &#x27;123&#x27; // 语法错误 不能直接修改const的值 如果name是引用地址可以修改","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"},{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"},{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]}