{"meta":{"title":"Hexo","subtitle":"","description":"","author":"不知名小白菜","url":"https://222cabbage.github.io","root":"/"},"pages":[{"title":"我","date":"2022-05-13T06:12:28.221Z","updated":"2022-05-13T06:12:28.221Z","comments":false,"path":"about/index.html","permalink":"https://222cabbage.github.io/about/index.html","excerpt":"","text":"只是一个菜菜QQ：1305970446 WeChat：QZHZD6"},{"title":"书单","date":"2022-05-12T18:12:36.201Z","updated":"2022-05-12T15:59:45.020Z","comments":false,"path":"books/index.html","permalink":"https://222cabbage.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-12T15:59:45.021Z","updated":"2022-05-12T15:59:45.021Z","comments":true,"path":"links/index.html","permalink":"https://222cabbage.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-13T03:00:34.720Z","updated":"2022-05-13T03:00:34.720Z","comments":false,"path":"categories/index.html","permalink":"https://222cabbage.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-05-12T18:23:13.873Z","updated":"2022-05-12T15:59:45.022Z","comments":false,"path":"repository/index.html","permalink":"https://222cabbage.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-13T03:03:19.251Z","updated":"2022-05-13T03:03:19.251Z","comments":false,"path":"tags/index.html","permalink":"https://222cabbage.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网络相关知识（学自掘金小满zs）","slug":"network1","date":"2024-10-23T04:29:20.000Z","updated":"2024-10-23T17:23:52.160Z","comments":true,"path":"2024/10/23/network1/","link":"","permalink":"https://222cabbage.github.io/2024/10/23/network1/","excerpt":"","text":"计算机网络osi七层模型 7.应用层应用层就是我们使用最多的一层，例如ajax调用接口发送http请求，再比如域名系统DNS，邮件协议SMTP，webSocket长连接，SSH协议 6.表示层表示层主要做了几件重要的事情 安全，压缩，也是程序在网络中的一个翻译官。1.安全 在你的数据发送之前进行加密，在接受者的表示层进行解密。2.表示层还会对图片文件等格式进行解码和编码 例如 JPEG、ASCll 图片是人类能读懂的计算机需要转换成计算机能读懂的编码。 5.会话层会话层，是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方，与电话通话有点相似。会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，以及当双方发生拥塞时仍然能保持对话。会话层包含了一种称为检查点（Checkpoint） 的机制来维持可靠会话。检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或损坏时需要回滚以便恢复丢失或损坏数据的点，即断点下载的原理 4.传输层传输层主要就是定义我们的端口号，以及控流，和校验。并且拥有两个熟知的协议 TCP UDPTCP 是面向连接的协议并且TCP是可靠的因为TCP会进行三次握手四次挥手所以是可靠的，但是这样会降低速度UDP 具有较好的实时性 效率比TCP高UDP是没有三次握手四次挥手的，故此不稳定，但是速度快 常用于直播，游戏 3.网络层网络层是最复杂的一层，在这一层就定义了我们的IP，220.xxx.xxx.xxx。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备1.寻址：对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址）2.路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。我们的路由器就是在第三层工作的在数据链路层的时候说过了如果所有的使用互联网的用户在同一个网段中，会产生广播风暴，所以要将用户进行划分，让他们在不同的网段中，自己在自己的小网段中广播。而互联网就是这无数的子网络构成的一个巨型网络。在网络层中引入了一套新的地址，让我们能够区分不同的网段。这套地址就叫做“网络地址”，简称“网址”。于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。这一层中有一个规定网络地址的协议，叫做IP协议，它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。因为IPv4的地址已经不够用了，所以现在推广IPv6， 2.数据链路层建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 MAC地址：每个网卡的唯一标识有了Mac地址之后就可以知道谁是接收者，谁是发送者，并且知道了数据的内容并且进行了分组。 那么他如何进行传播数据，他是进行广播的方式进行传输,在局域网内所有的计算机都能收到消息 1.物理层物理层是直接和物理介质打交道的。 物理层的设备 网卡，网线，集线器，中继器，调制解调器 物理层信道，有线信道，光纤，无线电波 TCP握手与挥手浏览器输入url到按下回车发生了什么强缓存，协商缓存回流，重绘回流：页面部分或者重新渲染重绘：只需要更新相应内容，不会导致整个页面更新 CDN内容分发寻求更近的资源服务器请求资源，减少请求延迟，提高用户体验。 跨域jsonp，原理是script的src不受跨域访问限制，只能发送get，不安全，不容易维护，后端返回一个函数，前端定义一个函数，后端吧值注入到前端函数参数中 123456789101112131415const jsonp = (name) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;) script.src = &#x27;loacl..../jsonp?callback?=&#x27; + name document.body.append(script) return new Promise((resolve, reject)=&gt;&#123; window[name] = (data) =&gt; &#123; resolve(data) &#125; &#125;)&#125; jsonp(`callback$&#123;new Date().getTime()&#125;`).then(res =&gt; &#123; console.log(res)&#125;) 前端代理安装webpack和vite配置webpack.config.js和vite.config.js 后端解决设置头，但是不安全 运维nginx xhr，fetch（掘金小满zs）application&#x2F;x-www-form-urlencoded , 表单数据multipart&#x2F;form-data , 文件数据fetch 的 API 设计更加现代化、简洁和易于使用，使用起来更加直观和方便。相比之下，XHR 的 API 设计比较繁琐，需要进行多个参数的配置和回调函数的处理。fetch API 默认只支持 GET 和 POST 请求方法，而 XHR 则支持所有标准的 HTTP 请求方法。在 fetch 中设置请求头部的方式更加清晰和直接，可以通过 Headers 对象进行设置，而 XHR 的方式相对较为繁琐。在发送 POST 请求时，fetch API 要求将请求体数据作为参数传递给 fetch 方法中的 options 对象，而 XHR 可以直接在 send() 方法中设置请求体数据。在解析响应数据时，fetch API 提供了多种方法，包括 .json(), .blob(), .arrayBuffer() 等，而 XHR 只支持文本和二进制数据两种数据类型。在进行跨域请求时，fetch API 提供了一种简单而强大的解决方案——使用 CORS（跨域资源共享）头部实现跨域请求，而 XHR 则使用了一个叫做 XMLHttpRequest Level 2 的规范，在代码编写上相对较为繁琐。 fetch 返回格式text(): 将响应体解析为纯文本字符串并返回。json(): 将响应体解析为JSON格式并返回一个JavaScript对象。blob(): 将响应体解析为二进制数据并返回一个Blob对象。arrayBuffer(): 将响应体解析为二进制数据并返回一个ArrayBuffer对象。formData(): 将响应体解析为FormData对象。 sse，websocket（掘金小满zs）SSE（Server-Sent Events）是一种用于实现服务器主动向客户端推送数据的技术，也被称为“事件流”（Event Stream）。它基于 HTTP 协议，利用了其长连接特性，在客户端与服务器之间建立一条持久化连接，并通过这条连接实现服务器向客户端的实时数据推送 SSE 和 Socket 区别SSE（Server-Sent Events）和 WebSocket 都是实现服务器向客户端实时推送数据的技术，但它们在某些方面还是有一定的区别。 技术实现 SSE 基于 HTTP 协议，利用了其长连接特性，通过浏览器向服务器发送一个 HTTP 请求，建立一条持久化的连接。而 WebSocket 则是通过特殊的升级协议（HTTP&#x2F;1.1 Upgrade 或者 HTTP&#x2F;2）建立新的 TCP 连接，与传统 HTTP 连接不同。 数据格式 SSE 可以传输文本和二进制格式的数据，但只支持单向数据流，即只能由服务器向客户端推送数据。WebSocket 支持双向数据流，客户端和服务器可以互相发送消息，并且没有消息大小限制。 连接状态 SSE 的连接状态仅有三种：已连接、连接中、已断开。连接状态是由浏览器自动维护的，客户端无法手动关闭或重新打开连接。而 WebSocket 连接的状态更灵活，可以手动打开、关闭、重连等。 兼容性 SSE 是标准的 Web API，可以在大部分现代浏览器和移动设备上使用。但如果需要兼容老版本的浏览器（如 IE6&#x2F;7&#x2F;8），则需要使用 polyfill 库进行兼容。而 WebSocket 在一些老版本 Android 手机上可能存在兼容性问题，需要使用一些特殊的 API 进行处理。 安全性 SSE 的实现比较简单，都是基于 HTTP 协议的，与普通的 Web 应用没有太大差异，因此风险相对较低。WebSocket 则需要通过额外的安全措施（如 SSL&#x2F;TLS 加密）来确保数据传输的安全性，避免被窃听和篡改，否则可能会带来安全隐患。总体来说，SSE 和 WebSocket 都有各自的优缺点，适用于不同的场景和需求。如果只需要服务器向客户端单向推送数据，并且应用在前端的浏览器环境中，则 SSE 是一个更加轻量级、易于实现和维护的选择。而如果需要双向传输数据、支持自定义协议、或者在更加复杂的网络环境中应用，则 WebSocket 可能更加适合。 1. EventSource() 构造函数2. EventSource.readyState 属性3. EventSource.close() 方法4. EventSource.onopen 事件5. EventSource.onerror 事件6. EventSource.onmessage 事件以上就是 EventSource 对象的常用 API 介绍，需要注意的是，在使用 EventSource 对象的过程中，如果服务器没有正确地设置响应头信息（如：Content-Type: text&#x2F;event-stream），可能会导致 EventSource 对象无法接收到服务器发送的数据。 navigator.sendBeacon（掘金小满zs）数据上报，用户行为性能数据监测在 web 开发中，我们经常需要将用户行为或性能数据上报到服务器。为了不影响用户体验，开发者通常会在页面卸载时进行数据上报。然而，传统的数据上报方式，如 XMLHttpRequest 或 Fetch API，容易受到页面卸载过程中的阻塞，导致数据丢失。为了解决这个问题，navigator.sendBeacon API 被引入，它可以在页面卸载时安全、可靠地发送数据。 navigator.sendBeacon 对比 Ajax fetch优点 不受页面卸载过程的影响，确保数据可靠发送。异步执行，不阻塞页面关闭或跳转。能够发送跨域请求。 缺点 fetch 和 ajax 都可以发送任意请求 而 sendBeacon 只能发送POSTfetch 和 ajax 可以传输任意字节数据 而 sendBeacon 只能传送少量数据（64KB 以内）fetch 和 ajax 可以定义任意请求头 而 sendBeacon 无法自定义请求头sendBeacon 只能传输 ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams 类型的数据如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效 navigator.sendBeacon 应用场景 发送心跳包：可以使用 navigator.sendBeacon 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。埋点：可以使用 navigator.sendBeacon 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。发送用户反馈：可以使用 navigator.sendBeacon 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进 其他注意事项 typeping请求 是html5 新增的 并且是sendBeacon 特有的 ping 请求 只能携带少量数据，并且不需要等待服务端响应，因此非常适合做埋点统计，以及日志统计相关功能。 123456789&lt;button class=&quot;send&quot;&gt;发送&lt;/button&gt;const send = document.querySelector(&#x27;.send&#x27;)send.addEventListener(&#x27;click&#x27;, () =&gt; &#123; let data = JSON.stringify(&#123;name:&#x27;test&#x27;&#125;) const blob = new Blob([data], &#123; type: &#x27;application/json&#x27; &#125;) navigator.sendBeacon(&#x27;http://localhost:3000/api/beacon&#x27;,blob,&#123; type:&quot;beacon&quot; &#125;)&#125;) nodejs 12345678910import express from &#x27;express&#x27;;const app = express();app.post(&#x27;/api/beacon&#x27;, (req: any, res) =&gt; &#123; console.log(req.body); res.send(&#x27;ok&#x27;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;Listening on port 3000&#x27;);&#125;);","categories":[{"name":"计算机网路","slug":"计算机网路","permalink":"https://222cabbage.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"}],"tags":[{"name":"计算机网路","slug":"计算机网路","permalink":"https://222cabbage.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"}]},{"title":"git版本回退","slug":"git1","date":"2024-10-22T14:49:00.000Z","updated":"2024-10-22T14:57:04.218Z","comments":true,"path":"2024/10/22/git1/","link":"","permalink":"https://222cabbage.github.io/2024/10/22/git1/","excerpt":"","text":"git版本回退git checkout：切换分支或恢复文件到指定提交。git checkout 命令用于切换分支或恢复工作目录中的文件到指定的提交。 恢复工作目录中的文件到某个提交： 1git checkout &lt;commit&gt; -- &lt;filename&gt; 例如，将 file.txt 恢复到 abc123 提交时的版本： 1git checkout abc123 -- file.txt 切换到特定提交： 1git checkout &lt;commit&gt; 例如： 1git checkout abc123 这种方式切换到特定的提交时，处于分离头指针（detached HEAD）状态。 git reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。git reset 命令可以更改当前分支的提交历史，它有三种主要模式：–soft、–mixed 和 –hard。 –soft：只重置 HEAD 到指定的提交，暂存区和工作目录保持不变。 1git reset --soft &lt;commit&gt; –mixed（默认）：重置 HEAD 到指定的提交，暂存区重置，但工作目录保持不变。 1git reset --mixed &lt;commit&gt; –hard：重置 HEAD 到指定的提交，暂存区和工作目录都重置。 1git reset --hard &lt;commit&gt; 例如，将当前分支重置到 abc123 提交： 1git reset --hard abc123 git revert：创建一个新的提交以撤销指定提交，不改变提交历史，适用于已经推送到远程仓库的提交。1git revert &lt;commit&gt; 例如，撤销 abc123 提交： 1git revert abc123 git reflog：查看历史操作记录，找回丢失的提交。git reflog 命令记录了所有 HEAD 的移动。即使提交被删除或重置，也可以通过 reflog 找回。 1git reflog 利用 reflog 可以找到之前的提交哈希，从而恢复到特定状态。例如： 1git reset --hard HEAD@&#123;3&#125; 实例以下是一个综合示例，演示如何使用这些命令恢复历史版本： 查看提交历史： 1git log --oneline 假设输出如下： 123abc1234 Commit 1def5678 Commit 2ghi9012 Commit 3 切换到 Commit 2（处于分离头指针状态）： 1git checkout def5678 重置到 Commit 2，保留更改到暂存区： 1git reset --soft def5678 重置到 Commit 2，取消暂存区更改： 1git reset --mixed def5678 重置到 Commit 2，丢弃所有更改： 1git reset --hard def5678 撤销 Commit 2： 1git revert def5678 查看 reflog 找回丢失的提交： 1git reflog 找到之前的提交哈希并恢复： 1git reset --hard HEAD@&#123;3&#125;","categories":[{"name":"git","slug":"git","permalink":"https://222cabbage.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://222cabbage.github.io/tags/git/"}]},{"title":"babel浅析","slug":"babel1","date":"2024-10-22T14:45:21.000Z","updated":"2024-10-22T14:49:51.776Z","comments":true,"path":"2024/10/22/babel1/","link":"","permalink":"https://222cabbage.github.io/2024/10/22/babel1/","excerpt":"","text":"Babel浅析1：Babel的编译原理是对字符串的操作，因为代码的本质就是字符串。2：需要使用分词器tokenizer将代码语句分隔，再进行语法分析(parser)ast，语义分析，最后转化生成generator或者执行interpretor3：程序都可以用json表示4：AST将代码转换为json","categories":[{"name":"babel","slug":"babel","permalink":"https://222cabbage.github.io/categories/babel/"}],"tags":[{"name":"babel","slug":"babel","permalink":"https://222cabbage.github.io/tags/babel/"}]},{"title":"利用canvas可以做什么","slug":"html5","date":"2024-10-21T08:05:16.000Z","updated":"2024-10-21T08:22:33.161Z","comments":true,"path":"2024/10/21/html5/","link":"","permalink":"https://222cabbage.github.io/2024/10/21/html5/","excerpt":"","text":"电子签名版原理利用canvas绘制一个画板，再结合mouse相关事件获取鼠标点击后移动过的坐标，赋值给canvas绘制api","categories":[{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"}],"tags":[{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"}]},{"title":"Websocket","slug":"html4","date":"2024-10-20T17:13:32.000Z","updated":"2024-10-20T17:33:17.119Z","comments":true,"path":"2024/10/21/html4/","link":"","permalink":"https://222cabbage.github.io/2024/10/21/html4/","excerpt":"","text":"HTML5 WebSocket 取自菜鸟教程WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 以下 API 用于创建 WebSocket 对象。 1var Socket = new WebSocket(url, [protocol] ); 以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。 WebSocket 属性Socket.readyState只读属性 readyState 表示连接状态，可以是以下值： 0 - 表示连接尚未建立。 1 - 表示连接已建立，可以进行通信。 2 - 表示连接正在进行关闭。 3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 WebSocket 事件事件 事件处理程序 描述open Socket.onopen 连接建立时触发message Socket.onmessage 客户端接收服务端数据时触发error Socket.onerror 通信发生错误时触发close Socket.onclose 连接关闭时触发 WebSocket 方法方法 描述Socket.send() 使用连接发送数据Socket.close() 关闭连接 WebSocket 实例WebSocket 协议本质上是一个基于 TCP 的协议。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"}],"tags":[{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"}]},{"title":"html5拖放api","slug":"html3","date":"2024-10-20T16:24:59.000Z","updated":"2024-10-20T16:41:28.032Z","comments":true,"path":"2024/10/21/html3/","link":"","permalink":"https://222cabbage.github.io/2024/10/21/html3/","excerpt":"","text":"HTML5拖拽api（Drag与Drop）取自于菜鸟教程12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;拖放api&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125; function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt; &lt;/body&gt;&lt;/html&gt; 设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ： 1&lt;img draggable=&quot;true&quot;&gt; 拖动什么 - ondragstart 和 setData()然后，规定当元素被拖动时，会发生什么。 在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 dataTransfer.setData() 方法设置被拖数据的数据类型和值： 1234function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; Text 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id (“drag1”)。 放放到何处 - ondragoverondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据&#x2F;元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1event.preventDefault() 进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。 在上面的例子中，ondrop 属性调用了一个函数，drop(event)： 123456function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125; 代码解释： 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。被拖数据是被拖元素的 id (“drag1”)把被拖元素追加到放置元素（目标元素）中 来回拖放图片12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1, #div2 &#123; float:left; width:100px; height:35px; margin:10px; padding:10px; border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev) &#123; ev.preventDefault();&#125;function drag(ev) &#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125;function drop(ev) &#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt; &lt;img src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; width=&quot;88&quot; height=&quot;31&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"}],"tags":[{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"}]},{"title":"canvas与svg","slug":"html2","date":"2024-10-20T16:24:46.000Z","updated":"2024-10-20T16:32:09.421Z","comments":true,"path":"2024/10/21/html2/","link":"","permalink":"https://222cabbage.github.io/2024/10/21/html2/","excerpt":"","text":"canvasHTML5 canvas标签 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成. svgsvg概念：SVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用于定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失SVG 是万维网联盟的标准 svg优势SVG 图像可通过文本编辑器来创建和修改SVG 图像可被搜索、索引、脚本化或压缩SVG 是可伸缩的SVG 图像可在任何的分辨率下被高质量地打印SVG 可在图像质量不下降的情况下被放大 SVG 与 Canvas两者间的区别SVG 是一种使用 XML 描述 2D 图形的语言。 Canvas 通过 JavaScript 来绘制 2D 图形。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较Canvas依赖分辨率不支持事件处理器弱的文本渲染能力能够以 .png 或 .jpg 格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘 svg不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序（比如谷歌地图）复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）不适合游戏应用","categories":[{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"}],"tags":[{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"}]},{"title":"IE浏览器兼容html5","slug":"html1","date":"2024-10-20T15:07:56.000Z","updated":"2024-10-20T16:24:00.429Z","comments":true,"path":"2024/10/20/html1/","link":"","permalink":"https://222cabbage.github.io/2024/10/20/html1/","excerpt":"","text":"IE浏览器兼容html51234567891011121314151617完美的 Shiv 解决方案&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;渲染 HTML5&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;html5shiv.js 引用代码必须放在 &lt;head&gt; 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。","categories":[{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"}],"tags":[{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"}]},{"title":"看一下mongodb","slug":"mongostudy","date":"2022-12-11T10:01:56.000Z","updated":"2022-12-11T15:29:43.307Z","comments":true,"path":"2022/12/11/mongostudy/","link":"","permalink":"https://222cabbage.github.io/2022/12/11/mongostudy/","excerpt":"","text":"最近想做个日程表下载mongodb cmd打开窗口 show dbs 展示已有数据库 use block 创建一个名为block的数据库","categories":[{"name":"mongo","slug":"mongo","permalink":"https://222cabbage.github.io/categories/mongo/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://222cabbage.github.io/tags/mongo/"}]},{"title":"vuejs设计与实现的阅读","slug":"realizationvue","date":"2022-12-07T13:00:21.000Z","updated":"2022-12-07T16:23:57.250Z","comments":true,"path":"2022/12/07/realizationvue/","link":"","permalink":"https://222cabbage.github.io/2022/12/07/realizationvue/","excerpt":"","text":"声明式@click&#x3D;”toXXXX” 注重过程，内部实现了该事件 命令式xxx.textContent &#x3D; ‘xxx’ 注重过程 声明式和命令式的对比，命令式性能更好，声明式是在方便开发，利于维护的情况下尽量去减少性能的损耗 虚拟DOM紧跟着的是虚拟DOM 循环向数组push对象和循环向一个节点appendChild对比起来，明显前者效率更高，性能更好 如何让声明式的性能更加接近命令式呢，就需要最小化的寻找到二者之间对比的差异 提供一个render函数，将一个树形结构对象递归转换成真实DOM 缺少了一部分，我们只是将属性结构对象递归转换成真实DOM，缺少将真实DOM转换成树形结构的方法 因此complier函数设计出来 let dom &#x3D; 节点 let obj &#x3D; compiler(dom) &#x2F;&#x2F;转换成树形结构对象 render(obj，document.body)&#x2F;&#x2F;将转换后的树形结构渲染成真实DOM插入body中 tree-shaking去除打包后项目中的无用代码，必须依赖于es module 什么是副作用函数？就是内部操作会影响外部变量的函数","categories":[{"name":"vue实现","slug":"vue实现","permalink":"https://222cabbage.github.io/categories/vue%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"vue实现","slug":"vue实现","permalink":"https://222cabbage.github.io/tags/vue%E5%AE%9E%E7%8E%B0/"}]},{"title":"与react-native在职场上的碰撞","slug":"reactnative","date":"2022-12-01T14:53:48.000Z","updated":"2022-12-03T14:44:09.389Z","comments":true,"path":"2022/12/01/reactnative/","link":"","permalink":"https://222cabbage.github.io/2022/12/01/reactnative/","excerpt":"","text":"与react-native在职场上的碰撞","categories":[{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/tags/react-native/"}]},{"title":"react-native上手","slug":"rn1","date":"2022-10-19T15:15:21.000Z","updated":"2022-10-19T16:39:40.508Z","comments":true,"path":"2022/10/19/rn1/","link":"","permalink":"https://222cabbage.github.io/2022/10/19/rn1/","excerpt":"","text":"react-native，一个按照官网来搭建环境都能搭建错的app开发方案环境什么的就不说了，百度一下大概就知道 安装node，react-native-cli，android-studio，jdk8版 react-native init mypro –version 0.68.2 不带后面的版本会报错 yarn android运行 然后有报奇奇怪怪的错","categories":[{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/tags/react-native/"}]},{"title":"讲讲入职第一天的工作","slug":"work1","date":"2022-10-17T14:15:26.000Z","updated":"2022-10-17T14:21:51.070Z","comments":true,"path":"2022/10/17/work1/","link":"","permalink":"https://222cabbage.github.io/2022/10/17/work1/","excerpt":"","text":"分享一下入职第一天的生活第一天入职嘛，难免紧张 这是我实习结束后的第一份正式工作，我想在任何方面都做好 在办理玩入职后，有小姐姐带我领取了一台电脑，并带领我去了工位 我的工位旁就是带我的老大，还是蛮刺激的 老大后续带我去会议室和我讲解了一下团队的项目 光看成品还没什么，看代码才是真头痛 看代码的同时顺路搭建react native环境，这安卓环境是真难安装，按照react native官网上的步骤一步一步来都不知道哪里搞错了 再结合代码的难度，目录我都看不懂，因此让我萌生出了放弃的想法 但是再困难也得坚持下去，坚持才会有胜利的希望，我坚信我会变得越来越好 也很感谢那些激励我的小伙伴们，没有大家的鼓励我也很难重拾信心，啾咪……","categories":[{"name":"工作日志","slug":"工作日志","permalink":"https://222cabbage.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"https://222cabbage.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"移动端适配","slug":"mobile1","date":"2022-10-09T06:10:24.000Z","updated":"2022-10-09T10:56:19.987Z","comments":true,"path":"2022/10/09/mobile1/","link":"","permalink":"https://222cabbage.github.io/2022/10/09/mobile1/","excerpt":"","text":"移动端适配的方案常见方案响应式布局，通过@media媒体查询实现一套html配合多套css实现适配 通过rem或者vh，vw实现不同设备有相同比例进而进行适配 或者媒体查询配合rem适配 实现原理viewport视口标签，想要统一标准视口 需要在head中添加 rem实现原理rem是font-size的倍数大小，只需要在不同设备相同比例下设置不同的font-size大小就可 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;rem适配&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; /* 随意写大小，px to rem工具自动适配 */ width: 5rem; height: 5rem; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; // 动态设置font-size function resetHtmlFontSize()&#123; document.documentElement.style.fontSize = screen.width / 10 + &#x27;px&#x27; &#125; // window.onresize = resetHtmlFontSize window.addEventListener(&#x27;resize&#x27;,resetHtmlFontSize) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 弊端是如果设计稿修改，那么整体都要修改 px to rem插件在vscode插件中搜索 安装后自动匹配px进行转换rem 12需要一个配置文件，在目录下创建.cssrem复制 存在的弊端 转换错误后无法观看转换前的大小，所以一般是保留px，后期通过第三方工具，比如gulp动态监听转换 媒体监听媒体监听不是缩放，是同一个内容在不同设备上有合理的表现 123@media screen and （maxwidth：1000px）&#123; &#125; 优缺点对比rem：原理相对不好理解 从px到rem想要灵活的转换需要借助工具 灵活可控，完美复制设计稿 比较适合具有完全移动端的项目 媒体查询：没有学习成本 如何适配需要重新定义，设计稿麻烦 复杂的组件很难完美呈现 适合只有pc端设计稿，但是需要兼容移动端的项目 综合方案：同时使用media和rem 实现比较复杂 自由度更好 颗粒度不好把握 微信小程序的css单位px换算单位1px&#x3D;2rpx，应该和rem适配原理大概相同 如果是vue，可以使用postcss-px-to-viewport我也看到别人说的其实没有最好的适配，或者移动端准备一套，pc准备一套 或者tailwindcss 每个人对技术的感悟都是不同的，都有各自的看法，最后采用什么样的技术方案也还是得根据实际项目来，没有什么最好的方案一说","categories":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://222cabbage.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}],"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://222cabbage.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"canvas2D绘图","slug":"canvas1","date":"2022-10-07T06:40:05.000Z","updated":"2022-10-08T06:11:53.455Z","comments":true,"path":"2022/10/07/canvas1/","link":"","permalink":"https://222cabbage.github.io/2022/10/07/canvas1/","excerpt":"","text":"canvas2D绘图基本使用12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Canvas标签的默认大小为：300 x 150 (像素)，而这里咱们设置为了：200 x 200（像素）。 Canvas标签中的文字是在不支持Canvas标签的浏览器中使用的，因为支持Canvas标签的浏览器会忽略容器中包含的内 容正常渲染Canvas标签，而不支持Canvas标签的浏览器则相反，浏览器会忽略容器而显示其中的内容 --&gt; &lt;canvas width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; 渲染上下文canvas标签提供了一个容器画布，如果想要进行绘制就得找到渲染上下文 getContext() getContext方法是有一个接收参数，它是绘图上下文的类型 2d：建立一个二维渲染上下文。这种情况可以用 CanvasRenderingContext2D()来替换getContext(‘2d’)。 webgl（或 experimental-webgl）： 创建一个 WebGLRenderingContext 三维渲染上下文对象。只在实现WebGL 版本1(OpenGL ES 2.0)的浏览器上可用。 webgl2（或 experimental-webgl2）：创建一个 WebGL2RenderingContext 三维渲染上下文对象。只在实现 WebGL 版本2 (OpenGL ES 3.0)的浏览器上可用。 bitmaprenderer：创建一个只提供将canvas内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext。 1234567891011&lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot;&gt; 当前浏览器不支持canvas元素，请升级或者更换浏览器&lt;/canvas&gt;&lt;script&gt; let canvas = document.getElementById(&#x27;canvas&#x27;) console.log(canvas.getContext) if(canvas.getContext)&#123; let ctx = canvas.getContext(&#x27;2d&#x27;) &#125;&lt;/script&gt; 在获取上下文之后就可以绘制基本形状 绘制形状直线123456789101112131415moveTo(x, y)设置初始位置，参数为初始位置x和y的坐标点lineTo(x, y)绘制一条从初始位置到指定位置的直线，参数为指定位置x和y的坐标点stroke()通过线条来绘制图形轮廓if(canvas.getContext)&#123; let ctx = canvas.getContext(&#x27;2d&#x27;) ctx.moveTo(50,50) ctx.lineTo(300,300) ctx.stroke()&#125; 三角形12345678if(canvas.getContext)&#123; let ctx = canvas.getContext(&#x27;2d&#x27;) ctx.moveTo(50,50) //起点坐标 ctx.lineTo(300,300) ctx.lineTo(50,300) ctx.lineTo(50,50) //终点坐标。闭合点 ctx.stroke()&#125; 矩形矩形的绘制并不是单纯的直线拼凑，canvas提供了相关api绘制矩形 strokeRect(x, y, width, height) 绘制一个矩形的边框 fillRect(x, y, width, height) 绘制一个填充的矩形 clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明。 1234// 矩形ctx.strokeRect(50,50,200,100)ctx.fillRect(50,160,200,100)ctx.clearRect(60,180,50,50 圆弧和圆arc(x, y, radius, startAngle, endAngle, anticlockwise)。x和Y为圆心的坐标，radius为半径，startAngle为圆弧或圆的开始位置，endAngle为圆弧或圆的结束位置，anticlockwise是绘制的方向（不写默认为false，从顺时针方向) 1234567891011121314151617181920212223242526272829303132// 原型和弧ctx.arc(60, 60, 50, 0, Math.PI, false);ctx.stroke()需要注意的是：在画弧的时候，arc()函数中角的单位是弧度而不是角度。角度换算为弧度的表达式为：弧度=(Math.PI/180)*角度。// 原型和弧// ctx.arc(60, 60, 50, 0, Math.PI, false);// ctx.stroke()// // 绘制一个圆弧// ctx.arc(200, 60, 50, 0, Math.PI*2, false);// ctx.stroke();// 如果按照上述写法绘制一根弧线和圆 会出现路径相连，因此需要开启和闭合路径// beginPath// 新建一条路径，生成之后，图形绘制命令被指向到路径上。// closePath// 闭合路径之后图形绘制命令又重新指向到上下文中。 具体怎么使用这两个函数呢？下面咱们介绍一下，直接上代码：// 原型和弧ctx.beginPath()ctx.arc(60, 60, 50, 0, Math.PI, false);ctx.fill(); //填充黑色ctx.stroke()ctx.closePath()// 绘制一个圆弧ctx.beginPath()ctx.arc(200, 60, 50, 0, Math.PI*2, false);ctx.fill();ctx.stroke()ctx.closePath() 在咱们开启和关闭路径的时候，关闭路径其实并不是必须的，对于新路径其实每次都开启新路径就ok。 填充fill 123456// 绘制一个圆弧ctx.beginPath()ctx.arc(200, 60, 50, 0, Math.PI*2, false);ctx.fill();ctx.stroke()ctx.closePath() 椭圆ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) x、y：椭圆的圆心位置 radiusX、radiusY：x轴和y轴的半径 rotation：椭圆的旋转角度，以弧度表示 startAngle：开始绘制点 endAngle：结束绘制点 anticlockwise：绘制的方向（默认顺时针），可选参数。 12345678910111213141516171819202122232425结合了一下，有点搞笑// 椭圆ctx.beginPath();ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);ctx.stroke();ctx.beginPath()ctx.arc(100, 150, 50, 0, Math.PI*2, false);ctx.fill();ctx.stroke()ctx.closePath()ctx.beginPath();ctx.ellipse(400, 150, 50, 100, 0, 0, 2 * Math.PI);ctx.stroke();ctx.beginPath()ctx.arc(400, 150, 50, 0, Math.PI*2, false);ctx.fill();ctx.stroke()ctx.closePath()ctx.beginPath();ctx.ellipse(250, 350, 20, 200, Math.PI/2, 0, 2 * Math.PI); // 旋转90°ctx.fill(); 贝塞尔曲线123456789101112131415161718 // 贝塞尔曲线 // 贝塞尔曲线一般用来绘制复杂有规律的图形，在Canvas中也是一个十分有用的路径类型。 // 二次贝塞尔曲线 // 语法：quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点 // 绘制一段二次贝塞尔曲线 ctx.moveTo(50, 50); ctx.quadraticCurveTo(200, 200, 350, 50); // 绘制 ctx.stroke();// 三次贝塞尔曲线// 和二次贝塞尔曲线不同的是三次贝塞尔曲线有两个控制点。// 语法：ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。ctx.beginPath() // 开启路径ctx.moveTo(50, 200);ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);// 绘制ctx.stroke(); 绘制样式线条样式lineWidth 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164let canvas = document.getElementById(&#x27;canvas&#x27;) console.log(canvas.getContext) if(canvas.getContext)&#123; let ctx = canvas.getContext(&#x27;2d&#x27;) // 线条样式 // lineWidth 设置当前绘线的粗细。属性值必须为正数。默认值是 1.0。 // lineCap // lineCap 设置线段端点显示的样子。可选值为：butt，round 和 square。默认是 butt。 // lineJoin // lineJoin 该属性可以设置两线段连接处所显示的样子。可选值为：round, bevel 和 miter。默认是 // ctx.lineWidth = 10; // ctx.lineCap=&#x27;round&#x27; // ctx.moveTo(50,50) // ctx.lineTo(300,300) // ctx.stroke() // ctx.beginPath() // ctx.lineWidth = 10; // ctx.lineJoin=&#x27;miter&#x27; // ctx.moveTo(50, 20); // ctx.lineTo(100, 60); // ctx.lineTo(150, 20); // ctx.lineTo(200, 60); // ctx.lineTo(250, 20); // ctx.stroke(); // ctx.closePath(); // miterLimit // miterLimit 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 // 线段之间夹角比较大时，交点不会太远，但随着夹角变小，交点距离会呈指数级增大。 // 如果交点距离大于miterLimit值，连接效果会变成了 lineJoin = bevel 的效果。 // ctx.beginPath() // ctx.lineWidth = 5; // ctx.lineJoin=&#x27;miter&#x27; // ctx.miterLimit = 10 // ctx.moveTo(0, 100); // for (i = 0; i &lt; 30 ; i++) &#123; // var dy = i % 2 == 0 ? 200 : 100; // ctx.lineTo(Math.pow(i, 1.5) * 2, dy); // &#125; // ctx.stroke(); // ctx.closePath(); // setLineDash/getLineDash // setLineDash 可以设置当前虚线样式。 // getLineDash 则是返回当前虚线设置的样式，长度为非负偶数的数组。 // ctx.setLineDash([5, 10, 20]); // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20] // ctx.beginPath(); // ctx.moveTo(0,100); // ctx.lineTo(400, 100); // ctx.stroke(); // // 再绘制一条虚线 // ctx.setLineDash([5, 10, 20, 40]); // console.log(ctx.getLineDash()); // [5, 10, 20, 40] // ctx.beginPath(); // ctx.moveTo(0,200); // ctx.lineTo(400, 200); // ctx.stroke(); // lineDashOffset // lineDashOffset 设置虚线样式的起始偏移量 // 绘制一条虚线 // ctx.setLineDash([5, 10, 20]); // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20] // ctx.beginPath(); // ctx.moveTo(0,100); // ctx.lineTo(400, 100); // ctx.stroke(); // // 再绘制一条虚线 // ctx.setLineDash([5, 10, 20, 40]); // console.log(ctx.getLineDash()); // [5, 10, 20, 40] // ctx.beginPath(); // ctx.moveTo(0,200); // ctx.lineTo(400, 200); // ctx.stroke(); // 设置 globalAlpha 属性或者使用有透明度的样式作为轮廓或填充都可以实现 // 绘制一个矩形 // ctx.beginPath(); // // 指定透明度的填充样式 // ctx.fillStyle = &quot;rgba(0, 255, 0, 0.2)&quot;; // ctx.fillRect(10,10,300,100); // // 绘制一个矩形边框 // ctx.beginPath(); // // 指定透明度的描边样式 // ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.7)&quot;; // ctx.strokeRect(10, 90, 100, 300); // // 绘制一个圆 // ctx.beginPath() // ctx.fillStyle = &quot;rgba(255, 255, 0, 1)&quot;; // // 设置透明度值 // ctx.globalAlpha = 0.5; // ctx.arc(200, 200, 100, 0, Math.PI*2, true); // ctx.fill(); // 渐变 // 线性渐变和径向渐变 // 线性渐变 // 语法： createLinearGradient(x1, y1, x2, y2)，参数分别为 起点的坐标和终点的坐标。 // 在渐变的设置中还需要一个方法来添加渐变的颜色，语法为：gradient.addColorStop(offset, color)， // 其中color就是颜色，offset 则是颜色的偏移值，只为0到1之间的数。 // 创建渐变 // var gradient1 = ctx.createLinearGradient(10, 10, 400, 10); // gradient1.addColorStop(0, &quot;#00ff00&quot;); // gradient1.addColorStop(1, &quot;#ff0000&quot;); // var gradient2 = ctx.createLinearGradient(10, 10, 400, 10); // // 从0.5的位置才开始渐变 // gradient2.addColorStop(0.5, &quot;#00ff00&quot;); // gradient2.addColorStop(1, &quot;#ff0000&quot;); // ctx.beginPath() // ctx.fillStyle = gradient1; // ctx.fillRect(10, 10, 400, 100); // ctx.beginPath(); // ctx.fillStyle = gradient2; // ctx.fillRect(10, 150, 400, 100); // 径向渐变 // ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)，参数分别为开始圆的坐标和半径以及结束圆的坐标和半径。 // 结束坐标为点 // var gradient1 = ctx.createRadialGradient(100, 100, 100, 100, 100, 0); // gradient1.addColorStop(0, &quot;#ff770f&quot;); // gradient1.addColorStop(1, &quot;#ffffff&quot;); // // 结束坐标为半径30的圆 // var gradient2 = ctx.createRadialGradient(320, 100, 100, 320, 100, 30); // gradient2.addColorStop(0, &quot;#ff770f&quot;); // gradient2.addColorStop(1, &quot;#ffffff&quot;); // // 从0.5的位置才开始渲染 // var gradient3 = ctx.createRadialGradient(100, 320, 100, 100, 320, 0); // gradient3.addColorStop(0.5, &quot;#ff770f&quot;); // gradient3.addColorStop(1, &quot;#ffffff&quot;); // // 开始坐标和结束坐标不一样 // var gradient4 = ctx.createRadialGradient(320, 320, 100, 250, 250, 0); // gradient4.addColorStop(0, &quot;#ff770f&quot;); // gradient4.addColorStop(1, &quot;#ffffff&quot;); // ctx.beginPath(); // ctx.fillStyle = gradient1; // ctx.fillRect(10, 10, 200, 200); // ctx.beginPath(); // ctx.fillStyle = gradient2; // ctx.fillRect(220, 10, 200, 200); // ctx.beginPath(); // ctx.fillStyle = gradient3; // ctx.fillRect(10, 220, 200, 200); // ctx.beginPath(); // ctx.fillStyle = gradient4; // ctx.fillRect(220, 220, 200, 200); // Canvas中想绘制图案效果，需要用 createPattern 方法来实现。 // 语法：createPattern(image, type)，参数分别为：Image 参数可以是一个 Image 对象，也可以是一个 canvas 对象，Type 为图案绘制的类型，可用的类型分别有：repeat，repeat-x，repeat-y 和 no-repeat。 // 创建一个 image对象 // var img = new Image(); // img.src = &quot;./image.png&quot;; // img.onload = function() &#123; // // 图片加载完以后 // // 创建图案 // var ptrn = ctx.createPattern(img, &#x27;no-repeat&#x27;); // ctx.fillStyle = ptrn; // ctx.fillRect(0, 0, 500, 500); // &#125; &#125; loading…… 透明度渐变图案样式绘制文本strokeText描边fillText填充文本样式阴影绘制图片drawImage变形状态的保存和恢复移动、旋转和缩放transform，setTransform，resetTransform合成与裁剪合成裁剪动画高级动画绘制小球速率边界加速度拖尾效果应用保存图片反相颜色像素数据跟着掘金上的一篇文章学习的 作者：ndz链接：https://juejin.cn/post/7119495608938790942来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://222cabbage.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://222cabbage.github.io/tags/canvas/"}]},{"title":"学一下Go","slug":"go1","date":"2022-09-27T15:41:02.000Z","updated":"2022-09-27T17:37:22.310Z","comments":true,"path":"2022/09/27/go1/","link":"","permalink":"https://222cabbage.github.io/2022/09/27/go1/","excerpt":"","text":"来看看Go，躺平无出路，内卷才是真go对比其他语言阿巴阿巴，百度一下长篇大论很多 我是看的电子书，因为感觉看视频学习太慢了，看书的话效率或许会高一些 安装还能怎么安装？官网下载安装包双击启动一把梭哈，无脑下一步，再配置配置环境变量GOPATH(安装后自动生成)，完美 cmd后输入go env 回车测试go安装成功与否 目录src：放置项目和库的源文件pkg：放置编译后生成的包&#x2F;库的归档文件bin：放置编译后生成的可执行文件loading……学完再提交","categories":[{"name":"Go","slug":"Go","permalink":"https://222cabbage.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://222cabbage.github.io/tags/Go/"}]},{"title":"vue3的优化","slug":"vue32","date":"2022-09-24T05:02:16.000Z","updated":"2022-09-24T14:34:09.863Z","comments":true,"path":"2022/09/24/vue32/","link":"","permalink":"https://222cabbage.github.io/2022/09/24/vue32/","excerpt":"","text":"vue3做了什么样的优化？为什么需要这些优化？vue从1-2最大的变化就是引入了虚拟dom vue3的优化 更好的代码管理方式monorepo，将不同模块拆分到不同的package中每个package有各自的API，类型定义和测试 package-比如reactive，是可以独立于vue.js使用的，这样用户如果只想使用单个vue的能力而不必去依赖整个库。减少了引用包的体积大小，v2是做不到的 import { reactive } from ‘vue’ 采用了ts开发v2是flow，v3使用ts重构 flow是facebook出品的js静态类型检查工具，以非常小的成本对已有js代码迁入，v2采用时就是考虑到了flow的轻便灵活性 但是flow对于复杂场景类型十分不友好，v2源码有吐槽 ts则相反，更好的类型检查 性能优化减少了包的体积，移除冷门的feature，使用了tree-shaking tree-shaking是依赖es6的静态结构，import和export。通过编译阶段的静态分析，找到没有引入的模块并打标记 间接减少了vue包的体积 数据劫持优化 vue的数据从1x版本开始就是响应式的 123456789101112131415161718vue2是通过object.deineProperty(data,&#x27;a&#x27;,&#123; get()&#123; //track &#125;, set()&#123; //trigger &#125;&#125;)缺点：必须要先知道拦截对象的key，因此无法检测对象属性的删除和添加因此退出了$set和$deleteobj.define缺陷：如果对象层级较深，为了对所有属性进行劫持，需要遍历劫持，性能消耗高因此vue3采用了proxyproxy检测的是整个对象，因此对于新增删除都可以监听到但是proxy无法监听内部深层次的对象变化，因此v3的处理方式是在getter中去递归响应式这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归 编译优化除了在数据劫持部分的优化，也可以在耗时较多的patch阶段想办法 2x 3x 通过在编译阶段优化编译结果，实现运行时patch过程的优化 2x版本对于数据更新并触发重新渲染的粒度是组件级的 每次diff都会全部对比，vnode和模板大小正相关 当只有小部分更改时，多余的便利是对性能的浪费 v3通过编译阶段对静态模板的分析，编译生成了Block tree &#x2F;&#x2F;将模板基于动态节点指令切割的嵌套区域，每个区块内部的节点结构是固定的，每个区块只需要一个Array来追踪自身包含的动态节点 借助block tree vue将vnode更新性能由整体模板大小相关变成了与动态内容修改的数量有关 3x版本在编译节点还包含对slot的编译优化，事件侦听函数的缓存优化，并且在运行时重写了diff算法 优化逻辑组织3x还提供了comonsition api 2x被称为options api options api在组件小的时候一目了然，大的时候就很复杂，每当修改某一个关注点，就需要上下滑动变动多个位置 优化逻辑复用v2采用mixins，可以定义props，data，容易导致定义相同名称变量，导致命名冲突 而且在使用时，对于不在当前组件定义的变量等事物，使用时数据来源不清器 v3采用hook方式 更好的类型支持 因为componsition具备更好的类型支持，因为都是函数，类型容易被推导，和v2不同，v2使用this不容易推导。 componsition api对tree-shaking更友好，代码压缩更容易 引入RFC：使每个版本改动可控v2部分采用REF(reqquest for comments) &#x2F;&#x2F;为新功能进入框架提供一个一致且受控的路径 v3大规模采用RFC，你可以了解每一个feature采用或者被废弃的前因后果 小缺点：vue3是采用es6的语法开发，有些api如proxy是没有polyfill的，这就意味着官方需要单独出一个ie11的compat版本来支持ie11 v2官方声明继续维护18个月，也就是说18个月以后，如果你的项目出了什么问题，那么就需要你自己阅读源码解决","categories":[{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/tags/vue3/"}]},{"title":"看看WebGIS，极简单的智慧校园小demo","slug":"webgis1","date":"2022-09-22T18:30:26.000Z","updated":"2022-09-24T04:57:51.260Z","comments":true,"path":"2022/09/23/webgis1/","link":"","permalink":"https://222cabbage.github.io/2022/09/23/webgis1/","excerpt":"","text":"最近闲来无事，看看WebGIS什么是GIS？GIS是一门综合型学科，结合了地理学与地图学以及遥感和计算机科学 GIS开发方向桌面端开发&#x2F;桌面GIS-C&#x2F;S架构，web开发&#x2F;webgis-BS架构，移动端开发&#x2F;移动gis-高德地图，美团外卖等 WebGIS开发前端可视化技术和GIS相结合 以canvas和webGL为代表的的前端可视化技术提供了很多效果和交互 处理二维GIS的openLayers，MapBox，leaflet 处理三维GIS的cesium WebGIS和云计算，分布式机构结合，GIS云平台的出现 - 中地数码推出的GIS云平台 为什么选择WebGIS相对于其他技术和编程语言，难度较低，上手快，成就感大 基础平台MapGIS，ArcGIS，SuperMap &#x2F;&#x2F;类似安卓和苹果 可以基于基础平台开发定制应用 有些应用方向也会提供自己的平台，比如地图导航应用，高德开放平台，百度开放平台 面向大众提供地图API接口服务 所有的开放平台都一样，都能解决WebGIS的核心问题 高德比较好配置，轻量 术语地图组成结构 地图容器创建指定的id容器，和echarts一样，需要一个容器承载所有图层，点标记，矢量图形，控件 图层layer一个地图通常由一个或者多个图层组成 高德地图提供了很多标准图层和自定义图层 标准图层 卫星图层 路网图层 路况图层 矢量图形覆盖在图层上，通过矢量的方式，几何的方式，展示大小变化，但是其代表的实际路径和范围不变 除了折线，圆，多变性之外，JS的API还提供了矩形椭圆等 常用矢量图形 点标记一个点要素，标记点 地图控件悬浮在所有图层和地图要素上，满足一定交互和提示功能 放大缩小，调整方向 地图级别ZoomLevel级别与地图比例尺成正比，每增大一级，比例尺放大一倍，地图显示的越详细，最小级别通常为3级，高德地图目前最大级别为20级 经纬度LngLat经纬度坐标 东西经180度，(-180-180)，西半球为负，东半球为正 南北纬(-85-85)，北半球为正，南半球为负 底图BaseLayer位于所有图层和图形的最下方的图层，通常不透明，可以是单一图层，比如官方标准图层，也可以是图层组合，比如卫星图层和路网图层结合 地图要素Map Features展示在地图上的地理要素，道路，区域面，建筑，POI标注，路名等，开发者自定义的点标记矢量图形也可以看做是地图要素 标注Label地图上带有标示信息的文字或图标，POI标注，道路名称标注 地图平面像素坐标Plane Coordinates投影为平面之后的地图上的平面像素坐标…… 投影将地球球面的经纬度坐标映射到动图平面坐标的变换和映射关系，高德地图使用Web墨卡托投影，采用EPSG:3857坐标系统 注册高德开放平台进入高德开放平台注册登录认证，在控制台点击应用管理新增一个应用 新增完后点击右上角添加key，选择web 添加成功后会出现key和安全密匙 后续可看开发支持中的开发文档 因为第一次接触，所以使用的是不带框架的用法，后面研究一下搭配vue或者react如何使用，应该要安装然全局配置首先需要准备一个具备宽高的容器container GeoJSON一种保存地理信息数据的格式 数据持久化在地图上绘制了多个标记点后，刷新页面标记点消失，是因为代表着标记点的变量是临时在内存中开辟出来的，刷新后就会消失 持久化的方式1：使用GDB数据库，将数据保存在地理数据库中 2：使用GeoJSON，将数据保存在该格式的文件中 智慧校园小demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;智慧校园demo&lt;/title&gt; &lt;title&gt;点标记锚点&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; window._AMapSecurityConfig = &#123; securityJsCode:&#x27;注册高德开发者后得到的安全密匙&#x27;, &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=2.0&amp;key=注册高德开发者后得到的key&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;info&quot;&gt;点击地图标注热门地点&lt;/div&gt; &lt;script&gt; let map = new AMap.Map(&#x27;container&#x27;,&#123; center: [105.888,29.3915], zoom:16.5, viewMode:&#x27;3D&#x27;, pitch:45 &#125;) //使用空间 AMap.plugin([ &#x27;AMap.ToolBar&#x27;, &#x27;AMap.Scale&#x27;, &#x27;AMap.HawkEye&#x27;, &#x27;AMap.MapType&#x27;, &#x27;AMap.Geolocation&#x27;, &#x27;AMap.ControlBar&#x27;, // &#x27;AMap.GeoJSON&#x27; ], function()&#123; // 在图面添加工具条控件，工具条控件集成了缩放、平移、定位等功能按钮在内的组合控件 map.addControl(new AMap.ToolBar()); // 在图面添加比例尺控件，展示地图在当前层级和纬度下的比例尺 map.addControl(new AMap.Scale()); // 在图面添加鹰眼控件，在地图右下角显示地图的缩略图 // map.addControl(new AMap.HawkEye(&#123;isOpen:true&#125;)); // 在图面添加类别切换控件，实现默认图层与卫星图、实施交通图层之间切换的控制 // map.addControl(new AMap.MapType()); // 在图面添加定位控件，用来获取和展示用户主机所在的经纬度位置 // map.addControl(new AMap.Geolocation()); map.addControl(new AMap.ControlBar()); // map.addControl(new AMap.GeoJSON()) &#125;); // 定义一个全局对象保存json 持久化 有点小问题，按照官网来的报错 // let geojson = new AMap.GeoJSON(&#123; // geoJSON:null // &#125;) // // //导入数据 如果存在数据，n那么才导入数据，不存在数据什么都不做 // if(JSON.stringify(getStorageData) != &#x27;[]&#x27;)&#123; // geojson.importData(getStorageData()) // &#125; // map.add(geojson) // console.log(geojson) // 标记点 刷新页面会丢失 map.on(&#x27;click&#x27;,(e)=&gt;&#123; // 获取点击地点信息 var marker = new AMap.Marker(&#123; position:e.lnglat, // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9] &#125;); //使用覆盖物的点击事件 marker.on(&#x27;click&#x27;,(e)=&gt;&#123; console.log(e) &#125;) map.add(marker); // 通过geojson对象来管理覆盖物 // geojson.addOverlay(marker) // setStorageData(geojson.toGeoJSON()) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结束也意味着新的开始……","categories":[{"name":"WebGIS","slug":"WebGIS","permalink":"https://222cabbage.github.io/categories/WebGIS/"}],"tags":[{"name":"WebGIS","slug":"WebGIS","permalink":"https://222cabbage.github.io/tags/WebGIS/"}]},{"title":"跟着官网过过微信小程序","slug":"miniweixin","date":"2022-09-14T05:01:21.000Z","updated":"2022-09-14T06:24:09.272Z","comments":true,"path":"2022/09/14/miniweixin/","link":"","permalink":"https://222cabbage.github.io/2022/09/14/miniweixin/","excerpt":"","text":"跟着官网过过微信小程序记录一些小的知识点 场景值记录用户进入小程序的路径，where进入 对于小程序，可以在 App 的 onLaunch 和 onShow，或wx.getLaunchOptionsSync 中获取上述场景值。 对于小游戏，可以在 wx.getLaunchOptionsSync 和 wx.onShow 中获取上述场景值 部分场景值：官网copy 场景值 场景 appId含义 1020 公众号 profile 页相关小程序列表 来源公众号 1035 公众号自定义菜单 来源公众号 1036 App 分享消息卡片 来源App 1037 小程序打开小程序 来源小程序 1038 从另一个小程序返回 来源小程序 1043 公众号模板消息 来源公众号 页面路由 路由方式 触发时机 路由前页面 路由后页面 初始化 小程序打开的第一个页面 onLoad, onShow 打开新页面 调用 API wx.navigateTo使用组件 &#96;&#96; onHide onLoad, onShow 页面重定向 调用 API wx.redirectTo使用组件 &#96;&#96; onUnload onLoad, onShow 页面返回 调用 API wx.navigateBack使用组件&#96;&#96;用户按左上角返回按钮 onUnload onShow Tab 切换 调用 API wx.switchTab使用组件 &#96;&#96;用户切换 Tab 各种情况请参考下表 重启动 调用 API wx.reLaunch使用组件 &#96;&#96; onUnload onLoad, onShow 注意事项 navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 异步API大多数 API 都是异步 API，如 wx.request，wx.login 等。这类 API 接口通常都接受一个 Object 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果： Object 参数说明 参数名 类型 必填 说明 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 其他 Any - 接口定义的其他参数 12345678910111213141516wx.login(&#123; success(res) &#123; console.log(res.code) &#125;&#125;)异步调用返回promise// callback 形式调用wx.chooseImage(&#123; success(res) &#123; console.log(&#x27;res:&#x27;, res) &#125;&#125;)// promise 形式调用wx.chooseImage().then(res =&gt; console.log(&#x27;res: &#x27;, res)) 云开发API开通并使用微信云开发，即可使用云开发API，在小程序端直接调用服务端的云函数。 代码示例 123456789101112131415wx.cloud.callFunction(&#123; // 云函数名称 name: &#x27;cloudFunc&#x27;, // 传给云函数的参数 data: &#123; a: 1, b: 2, &#125;, success: function(res) &#123; console.log(res.result) // 示例 &#125;, fail: console.error&#125;)// 此外，云函数同样支持 promise 形式调用 loading……","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://222cabbage.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://222cabbage.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"实现一个vue-router","slug":"vuerouterandvuex","date":"2022-09-06T08:15:58.000Z","updated":"2022-09-07T09:20:00.419Z","comments":true,"path":"2022/09/06/vuerouterandvuex/","link":"","permalink":"https://222cabbage.github.io/2022/09/06/vuerouterandvuex/","excerpt":"","text":"实现一个vue-router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272myrouter.jsimport HashHistory from &quot;./hashHistory&quot;class VueRouter &#123; constructor(options) &#123; this.options = options // 如果不传mode，默认为hash this.mode = options.mode || &#x27;hash&#x27; // 判断模式是哪种 switch (this.mode) &#123; case &#x27;hash&#x27;: this.history = new HashHistory(this) break case &#x27;history&#x27;: // this.history = new HTML5History(this, options.base) break case &#x27;abstract&#x27;: &#125; &#125; init(app) &#123; this.history.listen((route) =&gt; app._route = route) // 初始化时执行一次，保证刷新能渲染 this.history.transitionTo(window.location.hash.slice(1)) &#125; // 根据hash变化获取对应的所有组件 createMathcer(location) &#123; const &#123; pathMap &#125; = createRouteMap(this.options.routes) const record = pathMap[location] const local = &#123; path: location &#125; if (record) &#123; return createRoute(record, local) &#125; return createRoute(null, local) &#125;&#125;let _VueVueRouter.install = (Vue) =&gt; &#123; _Vue = Vue // 使用Vue.mixin混入每一个组件 Vue.mixin(&#123; // 在每一个组件的beforeCreate生命周期去执行 beforeCreate() &#123; if (this.$options.router) &#123; // 如果是根组件 // this 是 根组件本身 this._routerRoot = this // this.$options.router就是挂在根组件上的VueRouter实例 this.$router = this.$options.router // 执行VueRouter实例上的init方法，初始化 this.$router.init(this) // 相当于存在_routerRoot上，并且调用Vue的defineReactive方法进行响应式处理 Vue.util.defineReactive(this, &#x27;_route&#x27;, this.$router.history.current) &#125; else &#123; // 非根组件，也要把父组件的_routerRoot保存到自身身上 this._routerRoot = this.$parent &amp;&amp; this.$parent._routerRoot // 子组件也要挂上$router this.$router = this._routerRoot.$router &#125; &#125; &#125;) Object.defineProperty(Vue.prototype, &#x27;$route&#x27;, &#123; get() &#123; return this._routerRoot._route &#125; &#125;)&#125;function createRouteMap(routes) &#123; const pathList = [] const pathMap = &#123;&#125; // 对传进来的routes数组进行遍历处理 routes.forEach(route =&gt; &#123; addRouteRecord(route, pathList, pathMap) &#125;) console.log(pathList) // [&quot;/home&quot;, &quot;/home/child1&quot;, &quot;/home/child2&quot;, &quot;/hello&quot;, &quot;/hello/child1&quot;] console.log(pathMap) // &#123; // /hello: &#123;path: xxx, component: xxx, parent: xxx &#125;, // /hello/child1: &#123;path: xxx, component: xxx, parent: xxx &#125;, // /hello/child2: &#123;path: xxx, component: xxx, parent: xxx &#125;, // /home: &#123;path: xxx, component: xxx, parent: xxx &#125;, // /home/child1: &#123;path: xxx, component: xxx, parent: xxx &#125; // &#125; // 将pathList与pathMap返回 return &#123; pathList, pathMap &#125;&#125;function addRouteRecord(route, pathList, pathMap, parent) &#123; // 拼接path const path = parent ? `$&#123;parent.path&#125;/$&#123;route.path&#125;` : route.path const &#123; component, children = null &#125; = route const record = &#123; path, component, parent &#125; if (!pathMap[path]) &#123; pathList.push(path) pathMap[path] = record &#125; if (children) &#123; // 如果有children，则递归执行addRouteRecord children.forEach(child =&gt; addRouteRecord(child, pathList, pathMap, record)) &#125;&#125;function createRoute(record, location) &#123; const res = [] if (record) &#123; while (record) &#123; res.unshift(record) record = record.parent &#125; &#125; return &#123; ...location, matched: res &#125;&#125;export default VueRouterhashHistory.jsclass HashHistory &#123; constructor(router) &#123; // 将传进来的VueRouter实例保存 this.router = router // 一开始给current赋值初始值 this.current = createRoute(null, &#123; path: &#x27;/&#x27; &#125;) // 如果url没有 # ，自动填充 /#/ ensureSlash() // 监听hash变化 this.setupHashLister() &#125; // 监听hash的变化 setupHashLister() &#123; window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123; // 传入当前url的hash this.transitionTo(window.location.hash.slice(1)) &#125;) &#125; // 跳转路由时触发的函数 transitionTo(location) &#123; console.log(location) // 找出所有对应组件 let route = this.router.createMathcer(location) console.log(route) // hash更新时给current赋真实值 this.current = route // 同时更新_route this.cb &amp;&amp; this.cb(route) &#125; // 监听回调 listen(cb) &#123; this.cb = cb &#125;&#125;// 如果浏览器url上没有#，则自动补充/#/function ensureSlash() &#123; if (window.location.hash) &#123; return &#125; window.location.hash = &#x27;/&#x27;&#125;export function createRoute(record, location) &#123; const res = [] if (record) &#123; while (record) &#123; res.unshift(record) record = record.parent &#125; &#125; return &#123; ...location, matched: res &#125;&#125;export default HashHistoryrouter-view组件const myView = &#123; functional: true, render(h, &#123; parent, data &#125;) &#123; const &#123; matched &#125; = parent.$route data.routerView = true // 标识此组件为router-view let depth = 0 // 深度索引 while(parent) &#123; // 如果有父组件且父组件为router-view 说明索引需要加1 if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123; depth++ &#125; parent = parent.$parent &#125; const record = matched[depth] if (!record) &#123; return h() &#125; const component = record.component // 使用render的h函数进行渲染组件 return h(component, data) &#125;&#125;export default myViewrouter-link组件const myLink = &#123; props: &#123; to: &#123; type: String, required: true, &#125;, &#125;, // 渲染 render(h) &#123; // 使用render的h函数渲染 return h( // 标签名 &#x27;a&#x27;, // 标签属性 &#123; domProps: &#123; href: &#x27;#&#x27; + this.to, &#125;, &#125;, // 插槽内容 [this.$slots.default] ) &#125;,&#125;export default myLink//学习自掘金林三心老师的代码","categories":[{"name":"vue","slug":"vue","permalink":"https://222cabbage.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://222cabbage.github.io/tags/vue/"}]},{"title":"手写一个简单的promise","slug":"promise1","date":"2022-09-06T08:09:46.000Z","updated":"2022-09-07T03:03:04.152Z","comments":true,"path":"2022/09/06/promise1/","link":"","permalink":"https://222cabbage.github.io/2022/09/06/promise1/","excerpt":"","text":"手写一个简单的promisepromise是什么？promise是js异步编程的解决方案，比传统的回调函数的方式更合理和强大，完美解决回调地狱，使的异步操作更加容易 Promises&#x2F;A+规范想要编写一个完整的，规范的promise就要哦根据promises&#x2F;A+规范编写 https://promisesaplus.com/英文地址 https://blog.csdn.net/qq_41800366/article/details/120788569?spm=1001.2014.3001.5501中文地址 最简单的promise使用123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; settimeOut(()=&gt;&#123; if(true)&#123; resolve(&#x27;true&#x27;) &#125;else&#123; reject(&#x27;false&#x27;) &#125; &#125;,1000)&#125;)p.then(value =&gt; &#123; console.log(value) // true&#125;).catch(err =&gt; &#123; console.log(err) // false&#125;) 写一个promise基本结构12345678910111213141516171819202122232425262728promise是一个构造函数new Promise传入一个函数立即执行执行函数有resolve和reject两个参数有一个then方法，接收两个参数class Promise &#123; contructor(exector)&#123; const resolve = value =&gt; &#123; console.log(value) &#125; const reject = reason =&gt; &#123; console.log(reason) &#125; try&#123; exector(resolve,reject) &#125; catch(err) &#123; throw err &#125; &#125; then(arg1,arg2)&#123; &#125;&#125;let p = new Promise((resolve,reject)=&gt;&#123; &#125;) promise的状态pending，fullfilled：解决&#x2F;resolved，rejected 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263三个状态调用resolve和reject时状态要从pending变为fullfilled或者rejectedconst PENDING = &#x27;pending&#x27;const FULLFILLED = &#x27;fullfilled&#x27;const REJECT = &#x27;rejected&#x27;class Promise &#123; contructor(exector)&#123; this.state = PENDING //初始pending状态 this.value = undefined this.reason = undefined this.obFullFillCallBack = undefined //保存promise内部执行的函数 this.onRejectedCallBack = undefined //保存执行的函数 const resolve = value =&gt; &#123; if(this.state = PENDING)&#123; this.state = FULLFILLED this.value = value this.onFUllFillCallBack &amp;&amp; this.onFUllFillCallBack() &#125; &#125; const reject = reason =&gt; &#123; if(this.state = PENDING)&#123; this.state = REJECT this.reason = reason this.onRejectedCallBack() &amp;&amp; this.onRejectedCallBack() &#125; &#125; try&#123; exector(resolve,reject) &#125; catch(err) &#123; throw err &#125; &#125; then(onFullfilled,onRejected //都是可选参数，如果不是函数直接忽略)&#123; // typeof onFullfilled === &#x27;function&#x27; &amp;&amp; onFullfilled() // typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected() if(this.state === FULLFILLED)&#123; typeof onFullfilled === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123; onFullfilled(this.value) &#125;,0) &#125;else if(this.state === REJECTED)&#123; typeof onRejected === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123; onRejected(this.reason) &#125;,0) &#125; else &#123; typeof onFullfilled === &#x27;function&#x27; &amp;&amp; (this.onFUllFillCallBack = value =&gt; &#123; setTimeout(()=&gt;&#123; onFullfilled(value) &#125;,0) &#125;) type onRejected === &#x27;function&#x27; &amp;&amp; (this.onRejectedCallBack = reason =&gt; &#123; setTimeout(()=&gt;&#123; onRejected(reason) &#125;,0) &#125; &#125; &#125;&#125;let p = new Promise((resolve,reject)=&gt;&#123; &#125;) 再修改一下 &#x2F;&#x2F;最基础版Promise实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const PENDING = &#x27;pending&#x27;const FULLFILLED = &#x27;fullfilled&#x27;const REJECT = &#x27;rejected&#x27;class Promise &#123; contructor(exector)&#123; this.state = PENDING //初始pending状态 this.value = undefined this.reason = undefined this.obFullFillCallBacks = [] //保存promise内部执行的函数 this.onRejectedCallBacks = [] //保存执行的函数 const resolve = value =&gt; &#123; if(this.state = PENDING)&#123; this.state = FULLFILLED this.value = value this.onFUllFillCallBacks &amp;&amp; this.onFUllFillCallBacks.forEach(fn =&gt; fn(value)) &#125; &#125; const reject = reason =&gt; &#123; if(this.state = PENDING)&#123; this.state = REJECT this.reason = reason this.onRejectedCallBacks &amp;&amp; this.onRejectedCallBacks.forEach(fn =&gt; fn(reason)) &#125; &#125; try&#123; exector(resolve,reject) &#125; catch(err) &#123; throw err &#125; &#125; then(onFullfilled,onRejected //都是可选参数，如果不是函数直接忽略)&#123; // typeof onFullfilled === &#x27;function&#x27; &amp;&amp; onFullfilled() // typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected() if(this.state === FULLFILLED)&#123; typeof onFullfilled === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123; onFullfilled(this.value) &#125;,0) &#125;else if(this.state === REJECTED)&#123; typeof onRejected === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123; onRejected(this.reason) &#125;,0) &#125; else &#123; typeof onFullfilled === &#x27;function&#x27; &amp;&amp; (this.onFUllFillCallBack.push(value =&gt; &#123; setTimeout(()=&gt;&#123; onFullfilled(value) &#125;,0) &#125;)) type onRejected === &#x27;function&#x27; &amp;&amp; (this.onRejectedCallBack.push(reason =&gt; &#123; setTimeout(()=&gt;&#123; onRejected(reason) &#125;,0) &#125;) &#125; &#125;&#125;let p = new Promise((resolve,reject)=&gt;&#123; &#125;) 完整版promise实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;function resolvePromise(promise, x, resolve, reject) &#123; if (promise === x) &#123; reject(new TypeError(&#x27;Chaining cycle detected for promise&#x27;)); &#125; else if (typeof x === &#x27;function&#x27; || (typeof x === &#x27;object&#x27; &amp;&amp; x !== null)) &#123; let called = false; try &#123; const then = x.then; if (typeof then === &#x27;function&#x27;) &#123; then.call(x, y =&gt; &#123; if (called) return; called = true; resolvePromise(promise, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; called = true; reject(r); &#125;); &#125; else &#123; resolve(x); &#125;; &#125; catch (error) &#123; if (called) return; called = true; reject(error); &#125; &#125; else &#123; resolve(x); &#125;&#125;; class FullPromisePerfect &#123; state = PENDING; value = undefined; reason = undefined; onFulfilledCallback = []; onRejectedCallback = []; constructor(executor) &#123; const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.state = FULFILLED; this.value = value; this.onFulfilledCallback.forEach(onFulfilled =&gt; onFulfilled(value)); &#125; &#125;; const reject = reason =&gt; &#123; if (this.state === PENDING) &#123; this.state = REJECTED; this.reason = reason; this.onRejectedCallback.forEach(onRejected =&gt; onRejected(reason)); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125;; &#125;; then(onFulfilled, onRejected) &#123; const onFulfilledNow = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value; const onRejectedNow = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125;; const promise2 = new FullPromisePerfect((resolve, reject) =&gt; &#123; const handleResolve = value =&gt; &#123; try &#123; const x = onFulfilledNow(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125;; &#125;; const handleReject = reason =&gt; &#123; try &#123; const x = onRejectedNow(reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125;; &#125;; if (this.state === FULFILLED) &#123; setTimeout(() =&gt; handleResolve(this.value), 0); &#125; else if (this.state === REJECTED) &#123; setTimeout(() =&gt; handleReject(this.reason), 0); &#125; else &#123; this.onFulfilledCallback.push(value =&gt; setTimeout(() =&gt; handleResolve(value), 0)); this.onRejectedCallback.push(reason =&gt; setTimeout(() =&gt; handleReject(reason), 0)); &#125; &#125;); return promise2; &#125;;&#125;;module.exports = FullPromisePerfect; 测试想要测试写的代码，可以使用npm i promises-aplus-tests -D 随后编写测试文件 123456789101112131415161718192021222324252627yarn add promises-aplus-tests -D在 package.json 中添加脚本&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;promises-aplus-tests 填写测试文件地址&quot; // 如 ./src/testFullPromise.js&#125;,首先在 FullPromise.js 中导出 FullPromisemodule.exports = FullPromise;然后编写测试文件const FullPromise = require(&#x27;../FullPromise&#x27;); // 导入 FullPromise// 参照 promises-tests 仓库提供的方法FullPromise.defer = FullPromise.deferred = function()&#123; let dfd = &#123;&#125;; dfd.promise = new FullPromise((resolve, reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;;module.exports = FullPromise; // 最后导出即可运行命令即可开始测试yarn test ending","categories":[{"name":"promise","slug":"promise","permalink":"https://222cabbage.github.io/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://222cabbage.github.io/tags/promise/"}]},{"title":"数据结构和算法再see","slug":"algorithm2","date":"2022-09-01T06:19:48.000Z","updated":"2022-10-12T15:54:47.794Z","comments":true,"path":"2022/09/01/algorithm2/","link":"","permalink":"https://222cabbage.github.io/2022/09/01/algorithm2/","excerpt":"","text":"之前草草过了一遍数据结构，这次再来复习一下时间复杂度：执行当前算法所花费的时间 大O表示法 O(1) O(n) O(n2) O(llogn) …… O(1)，花费时间不受某个变量变化影响，除了循环递归意外，基本都是O1 123456789101112const a = 1const b = 2function fn(num)&#123; return num&#125;fn(6) O(n) 123for(let i = 0;i &lt; 100; i++)&#123; console.log(i)&#125; O(n平方) 12345for(let i = 0;i &lt; 100; i++)&#123; for()&#123; &#125;&#125; O(logN) 12345let i = 1const n = 6while(i &lt; n)&#123; i = i * 2&#125; 空间复杂度：执行当前算法需要多少内存空间 大O表示法 O(1) O(n) O(n2) 。。。。。。 O(1) 1let a = 1 O(n) 1234let arr = []for(let i = 0;i &lt; 100; i++)&#123; arr.push(i)&#125; O(n2平方) 1234567let arr = []for(let i = 0;i &lt; 100; i++)&#123; arr.push(i) for(let j = 0;j &lt; 100; j++)&#123; arr[j].push(j) &#125;&#125; 栈1234后进先出向后面添加元素，从后向前删除元素上下电梯，最后一个进去，第一个出来入栈出栈，栈底栈顶 栈-leetcode有效括号123456789101112131415161718192021function fn(s)&#123; let arr = [] for(let i = 0; i &lt; s.length; i++)&#123; const start = s[i] if(s[i] === &#x27;(&#x27; || s[i] === &#x27;&#123;&#x27; || s[i] === &#x27;[&#x27;)&#123; arr.push(s[i]) &#125;else&#123; const end = arr[arr.length - 1] if(start == &#x27;)&#x27; &amp;&amp; end == &#x27;(&#x27; start == &#x27;]&#x27; &amp;&amp; end == &#x27;[&#x27; start == &#x27;&#125;&#x27; &amp;&amp; end == &#x27;&#123;&#x27; )&#123; arr.pop() &#125;else&#123; return false &#125; &#125; &#125; return arr.length == 0&#125;fn(str) 栈-leetcode删除字符串中所有相邻重复项1234function fn()&#123; &#125;fn(str) 队列先进先出 leetcode 933最近请求次数1234class RecentCounter &#123; &#125; 事件循环js是一门单线程的浏览器脚本语言，因此诞生出了异步，同步任务会被推入堆或者执行栈，异步任务被推入异步任务队列，在执行栈中的任务完成后，会将异步队列中的任务依次推入执行栈执行，这就是事件循环 在异步任务中也分为宏任务和微任务，主线程查询任务队列，执行微任务，执行完微任务后，主线程查询任务队列，执行第一个宏任务，执行完毕后再查找所有微任务，再查找第一个宏任务 链表多个元素组成的链表，不是按照顺序存储，而是按照next指针联系在一起的 js的原型链和链表结构相同 数组和链表区别 1：数组有序存储，删除或添加某个元素，其他元素会重新计算 2：链表不是按照顺序存储，没有下标，删除和添加元素不会影响其他元素 3：查找时，数组根据下标，链表只能从头或者从后找起 链表分为单向链表，双向链表，环形链表，，，，，， instanceof原理12345678910111213141516let arr = [1,2,3]console.log(arr instanceof Array) //trueconsole.log(arr instanceof Object) //true const instanceof = (target,obj) =&gt; &#123; let p = target while(p)&#123; if(p == obj.prototype)&#123; return true &#125; p = p.__proto__ &#125; return false &#125; console.log(instanceof([1,2,3],Array)) 环形链表leetcode-141环形链表12345678910function hasCycle = function(head)&#123; let f = head let s = head while( f! = null &amp;&amp; f.next != null)&#123; s = s.next f = f.next.next if( s = f ) return true &#125; return false&#125; leetcode-237删除链表中的节点12345无法访问head，只能访问要删除的node，要删除的node不是末尾节点function deleteEle(node)&#123; node.val = node.next.val node.next = node.next.next&#125; leetcode-83删除排序链表中的重复元素12345678910111213141516171819202122给一个head，升序序列，删除所有重塑元，使每个元素只出现一次function deleteEle(head)&#123; //我写的 let p = head while( p.val = p.next.val )&#123; p.next.val = p.next.next.val p.next.next = p.next.next.next &#125; //视频写的 if(!head)&#123; return head &#125; let cur = head while(cur.next)&#123; if(cur.val = cur.next.val)&#123; cur.next = cur.next.next &#125;else&#123; cur = cur.next &#125; &#125; return head&#125; leetcode-206反转链表1234567891011function reserve(head)&#123; let prev = null let curr = head while(curr)&#123; const next = curr.next curr.next = prev prev = curr curr = next &#125; return prev&#125; 字典和哈希表字典键值对的存储，类似js对象，js对象的键在某些情况会转换成对象类型，字典类型键不会转换类型 1234567let map = new Map()map.set(&#x27;key&#x27;,123)map.get(&#x27;key&#x27;)map.has(&#x27;key&#x27;)map.delete(&#x27;key&#x27;)map.clear()console.log(map.size) //length 哈希表和字典相比，省去了按照插入顺序排列的查找 又称为散列表 基于数组，可以通过下标hash值访问元素 js没有哈希表，哈希表是字典的一种实现 字典是根据添加顺序排列的，哈希表不是 1234567891011121314151617181920212223实现哈希表class Hash &#123; constructor&#123; this.table = [] &#125; hashCode(key)&#123; let hash = 0 for(let i = 0; i &lt; key.length; i++)&#123; hash += key.charCodeAt(i) &#125; return hash &#125; put(key,value)&#123; let hashKey = this.hashCode(key) this.table[hashKey] = value &#125; get(key)&#123; let hashKey = this.hashCode(key) return this.table[hashKey] &#125;&#125;let hash = new Hash() leetcode哈希表1两数之和1234567891011给定一个数组，给定一个目标值，求数组中和为目标值的两个整数，返回下标function computed(nums, target)&#123; let map = new Map() for(let i = 0; i &lt; nums.length; i++)&#123; num = target - nums[i] if(map.has(num))&#123; return [map.get(num),i] &#125; map.set(nums[i],i) &#125;&#125; leetcode哈希表存在重复元素123456789101112给定一个数组，判断是否存在重复元素如果一个值在该数组中至少出现两次，函数返回true，如果数组中每个元素都不相同，返回falsefunction same(nums)&#123; let map = new Map() for(let i = 0; i &lt; nums.length;i++)&#123; if(map.has(nums[i]))&#123; return true &#125; map.set(nums[i],i) &#125; return false&#125; leetcode哈希表349两个数组交集12345给定两个数组，编写函数计算交集function com(nums1,nums2)&#123; let set = new Set(nums) return [...new Set(nums1)].filter(val =&gt; set.has(val))&#125; 判断一个字符串中出现最多的字符并统计次数123456789101112131415function num(str)&#123; let maxNum = 0 let maxStr = &#x27;&#x27; let map = new Map() for(let item of str)&#123; map.set(item, (map.get(item) || 0) + 1) &#125; for(let [key,value] of map)&#123; if(value &gt; maxNum)&#123; maxNum = value maxStr = key &#125; &#125; return [maxStr,maxNum]&#125; leetcode哈希表1207独一无二的出现次数12345678910111213141516给予一个都是整数项的数组，统计每个项出现的次数，如果每个数出现的次数都是独一无二的，返回true，否则返回falsefunction U(arr)&#123; const map = new Map() for(let item of arr)&#123; if(map.has(item))&#123; map.set(item,map.get(item) + 1) &#125;else&#123; map.set(item,1) &#125; &#125; const set = new Set() for(let [key,value] of map)&#123; set.add(value) &#125; return set.size == map.size&#125; leetcode 03无重复字符的最长子串1234567891011121314151617181920212223242526272829303132333435363738给定一个字符串s，找出其中不含重复字符的最长子串的长度如果是aassdd去重后卫asd，最长子串为3function Max(s)&#123; 自己想的两种方式，但是不知道为什么无法通过测试用例，我自己在浏览器调试的时候是可以的 // 后续搞明白了，没注意看题目，是最长子串，不是最长序列，题目我也没整明白，整成了去重后的长度，放这里记录一下错误 1 // let map = new Map() // let arr = s.split(&#x27;&#x27;) // for(let i = 0; i &lt; arr.length; i++)&#123; // if(map.has(arr[i]))&#123; // continue // &#125;else&#123; // map.set(arr[i],(map.get(arr[i]) || 0) + 1) // &#125; // &#125; // return map.size 2 // let set = new Set() // for(let i = 0; i &lt; s.length; i++)&#123; // set.add(s[i]) // &#125; // return set.size 涉及到了滑动窗口的概念 let map = new Map() let l = 0 let num = 0 for(let i = 0; i &lt; s.length; i++)&#123; if(map.has(s[i]) &amp;&amp; map.get(s[i]) &gt;= l)&#123; l = map.get(s[i]) + 1 &#125; num = Math.max(num,i - l + 1) map.set(s[i],i) &#125; return num&#125; 树分层数据关系 深度优先遍历从根节点出发，尽可能深的搜索树的节点，往一个节点深处遍历，遍历完后再遍历下一个节点一直遍历 技巧 1：访问根节点 2：对根节点children挨个进行深度优先遍历 12345678910111213141516171819202122232425const tree = &#123; val:&#x27;a&#x27;, children:[&#123; val:&#x27;b&#x27;, children:[&#123; val:&#x27;d&#x27;, children:[&#123; val:&#x27;e&#x27;, children:[] &#125;] &#125;] &#125;,&#123; val:&#x27;c&#x27; &#125;]&#125;const fn = (root) =&gt; &#123; //if(root.children)&#123; console.log(root.val) root.children.forEach(fn) //&#125;&#125;fn(tree) 广度优先遍历优先查找离根节点最近的节点，再查找最近的节点的子节点 技巧： 1：新建一个队列，吧根节点入队列 2：吧队头出队 3：吧对头的children挨个入队 4：重复2,3 12345678910function fn = (root) =&gt; &#123; const arr = [root] while(arr.length &gt; 0)&#123; const obj = arr.shift() console.log(obj.val) obj.forEach(item =&gt; &#123; arr.push(item) &#125;) &#125;&#125; 二叉树前序遍历多叉树dom结构 二叉树子节点只会有两个 1234567891011121314151617const tree = &#123; val:&#x27;a&#x27;, left:[&#123; val:&#x27;b&#x27;, left:[], right:[] &#125;], right:[&#123; val:&#x27;c&#x27;, left:[&#123; val:&#x27;d&#x27;; left:[], right:[] &#125;], right:[] &#125;]&#125; leetocde144二叉树前序遍历前序遍历&#x2F;先序遍历根，左，右 12345678910111213141516171819202122232425262728function tree(root)&#123; 1:递归版 let arr = [] let fn = (node) =&gt; &#123; if(node)&#123; //先根节点 arr.push(node.value) //遍历左子树 fn(node.left) //遍历右子树 fn(node.right) &#125; &#125; fn(root) return arr //[1,2,3,4,5] //2:通过栈的形式，非递归版 if(!root)return [] let arr = [] let stack = [root] while(stack.length)&#123; let o = stack.pop() arr.push(o.val) p.right &amp;&amp; stack.push(o.right) p.left &amp;&amp; stack.push(o.left) &#125; return arr&#125; leetcode94二叉树中序遍历左，根，右 123456789101112131415161718192021222324252627function fnn(root)&#123; 1：递归版 const arr = [] const fn = ( root ) =&gt; &#123; if(!root)return fn(root.left); arr.push(root.val) fn(root.right) &#125; fn(root) return arr 2：非递归版 const arr = [] const stack = [] let o = root while(stack.length || o)&#123; while(o)&#123; stack.push(o) o = o.left &#125; const n = stack.pop() arr.push(n.value) o = n.right &#125; return arr&#125; leetcode145二叉树后序遍历左右根 12345678910111213141516171819202122232425function tree(root)&#123; 1：递归版 const arr = [] const fn = (node) =&gt; &#123; if(node)&#123; fn(node.left) fn(node.right) arr.push(node.value) &#125; &#125; fn(root) return arr 2： if(!root)return [] const arr = [] const stack = [root] while(stack.length)&#123; const o = stack.pop() arr.unshift(o.value) o.left &amp;&amp; stack.push(o.left) o.right &amp;&amp; stack.push(o.right) &#125; return arr&#125; leetcode111二叉树最小深度123456789101112function tree(root)&#123; if(!root)return 0 const stack = [ [root,1] ] while(stack.length)&#123; const [o,n] = stack.shift() if(!o.left || !o.right)&#123; return n &#125; if(o.left)stack.push([o.left,n+1]) if(o.right)stack.push([o.right,n+1]) &#125;&#125; leetcode104二叉树最大深度123456789101112131415function tree(root)&#123; if(!root)return 0 const stack = [root] let num = 0 while(stack.length)&#123; let len = stack.length num++ while(len--)&#123; const o = stack.shift() o.left &amp;&amp; stack.push(o.left) o.right &amp;&amp; stack.push(o.right) &#125; &#125; return num&#125; leetcode104翻转二叉树123456789function tree(root)&#123; if(root == null)return null let tem = root.left root.left = rot.right root.right = tem tree(root.left) tree(root.right) return root&#125; leetcode100相同的树1234567判断两个树结构相同，值相同function tree(p,q)&#123; if(p == null &amp;&amp; q == null)return true if(p == null || q == null)return false if(p.val != q.val)return false return tree(p.left,q.left) &amp;&amp; tree(p.right,q.right)&#125; 堆loading……","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法1","slug":"数据结构与算法1","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951/"}]},{"title":"React18走起","slug":"react18","date":"2022-08-31T03:21:47.000Z","updated":"2022-08-31T04:40:10.163Z","comments":true,"path":"2022/08/31/react18/","link":"","permalink":"https://222cabbage.github.io/2022/08/31/react18/","excerpt":"","text":"React走起，不要怪我卷，你们逼我的vue框架的使用基本差不多了，后续再钻研源码，看到别人各种夸奖react，我也想去学一下","categories":[{"name":"React","slug":"React","permalink":"https://222cabbage.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://222cabbage.github.io/tags/React/"}]},{"title":"vue3新特性，node多版本管理工具nvm和nrm的使用","slug":"vue31","date":"2022-08-25T05:11:53.000Z","updated":"2022-08-29T11:47:33.456Z","comments":true,"path":"2022/08/25/vue31/","link":"","permalink":"https://222cabbage.github.io/2022/08/25/vue31/","excerpt":"","text":"vue3从前实习做的项目和自己做的项目基本上都是vue2版本 到目前，vue3版本已经很成熟了，很多公司也都开始使用上了vue3，那么我也去学习一下吧 新特性vue3的双向绑定是基于proxy实现，与vue2的defineProperty不同 1：祛除了麻烦的for in 循环遍历监听 2：可以监听复杂对象变化 3：代码简化: 4：可以监听删除的属性和数组长度索引 vue3对VDOM进行了更新，对文本节点等内容进行标记，更新只对比想同类型节点，不同于vue2全局diff vue3支持多根节点 同时支持render JSX写法 支持多v-model 支持tree-shaking componsition-api也就是vue3-hook 配置开发环境123456npm init vite@latest //注：npm 和 yarn的用法不同 //之前看过一些vite，命令都不一样npm ivite是通过script type=&quot;module&quot;的方式进行构建因此比传统的webpack启动服务更快修改一小块内容，只是对那一部分内容进行刷新，而不是全部刷新基于rollup nvm对node进行版本管理的工具 12345678建议先弄个梯子，不然github都进不去下载.exe文件安装安装目录名不要有中文字符nvm list //查看当前nvm使用的node版本集nvm list available //查看所有node版本nvm install 版本号//安装对应node版本 需要修改nvm安装目录下的setting文件，将包源切换为淘宝，不然除非科学上网，否则很难成功下载nodenvm use 版本号//使用某个版本的node，记得命令行使用管理员权限打开nvm uninstall 版本号//卸载某个版本的node nrm切换源的工具 123nrm ls //展示源列表nrm use 源 //使用某源nrm test npm/taobeo/...... //测试速度 vetur和volarvetur是vue2时辅助开发的插件，但是vue3不适用，语法不同，如果使用vue2，则需要禁用volar，反之亦然 模板语法和指令12345678910111213141516模板语法const mes:syring = &#x27;my name&#x27;&#123;&#123; name &#125;&#125;花括号中可以写三元表达式，运算等等指令v-textv-htmlv-ifv-else-ifv-elsev-showv-on/@v-modelv-bind/:v-for 虚拟dom和diff算法虚拟dom：通过js来生成一个AST节点树 1算了算了，懂懂概念还行，写就算了 ref全家桶1234567891011121314151617181920212223242526272829303132333435363738import &#123; ref,Ref &#125; from &#x27;vue&#x27;const mes:Ref&lt;string&gt; = ref(&#x27;&#x27;)mes经过ref包装后，成为了响应式的对象，需要通过mes.value取值isRef // 判断是否是ref对象console.log(isRef(mes))shallowRef //创建一个跟踪自身.value变化的ref，单内部属性不会变成refconst mes = shallowRef(&#123;name:&#x27;hao&#x27;&#125;)const btnClivk = () =&gt; &#123; mes.value.name = &#x27;123&#x27; //无效 mes.value = &#123;name:&#x27;123&#x27;&#125; //有效，内部属性不是响应式&#125;triggerRef //强制更新const mes = shallowRef(&#123;name:&#x27;hao&#x27;&#125;)const btnClivk = () =&gt; &#123; mes.value.name = &#x27;123&#x27; //无效 triggger(mes) //有效，强制更新&#125;customRef //自定义reffunction myRef&lt;T&gt;(value:T)&#123; return customRef((trank,trigger)=&gt;&#123; //trank为依赖 return &#123; get()&#123; trank() return value &#125;, set(newValue:T)&#123; value = newValue trigger() &#125; &#125; &#125;)&#125;let mes = myRef&lt;string&gt;(&#x27;123&#x27;) shallowRef造成视图更新的问题……1 reactive全家桶1234567891011121314151617181920212223242526272829import &#123; reactive &#125; from &#x27;vue&#x27;let mes = reactive([]/&#123;&#125;) //只接收复杂类型对象，如果插入简单数据类型，会提示错误，源码做了类型限制T extends object，只能是对象，又利用了isObject判断ref适用于基本类型reactive适用于复杂类型修改ref数据需要xxx.value = &#x27;&#x27;reactive则不需要 xxx.name = &#x27;123&#x27;//注，ref底层转换响应式使用了reactivereactive数据不能直接赋值，会破坏响应式解决方式：可以使用ref定义，或者定义一个reactive对象，内部属性是响应式readonlylet mes = ref(&#x27;mes&#x27;)let copy = readonly(mes)copy.value = &#x27;123&#x27; //不允许，只读shallowReactive只能动浅层的数据，如果是深层的数据只会改变值，不会改变视图let mes = shallowReactive(&#123; test:&#x27;123&#x27;, people:&#123; friends:&#123; name:&#x27;&#x27;, age:&#x27;&#x27; &#125; &#125;&#125;) toRef，toRefs，toRaw12345678910111213141516171819toRef如果原始数据没有经过reactive包裹，那么通过toRef转换的数据内部值修改，视图不更新const obj = &#123;name:&#x27;hao&#x27;&#125;const state = toRef(onj,&#x27;name&#x27;)state.value = &#x27;ge&#x27;toRefslet obj = reactive(&#123; name:&#x27;hao&#x27;, age:21&#125;)let &#123;name,age&#125; = toRefs(obj) //通过toRefs结构出来的数据变成响应式，否则失去响应式toRaw //转换非响应式对象let obj = reactive(&#123; name:&#x27;hao&#x27;, age:21&#125;)let copy = toRaw(obj) computed计算属性1234567891011121314const age = computed(()=&gt;&#123; return 21&#125;)const age = computed(&#123; get()&#123; return 123 &#125;, set()&#123; 123 &#125;&#125;)具有缓存 watch侦听器123456789101112131415161718192021222324252627282930313233343536373839404142let mes = ref&lt;string&gt;(&#x27;hao&#x27;)watch(mes,(oldValue,newValue)=&gt;&#123; console.log(&#x27;旧值&#x27;,oldValue) console.log(&#x27;新值&#x27;,newValue)&#125;)@click = () =&gt; &#123; mes.value = &#x27;123&#x27;&#125;支监听多个let mes = ref&lt;string&gt;(&#x27;hao&#x27;)let mes2 = ref&lt;string&gt;(&#x27;hao2&#x27;)watch([mes,mes2],(oldValue,newValue)=&gt;&#123; console.log(&#x27;旧值&#x27;,oldValue) //打印出来同为数组 console.log(&#x27;新值&#x27;,newValue) //打印出来同为数组&#125;)深度监听let mes = ref(&#123; nav:&#123; name:&#123; &#125; &#125;&#125;)watch(mes,(oldValue,newValue)=&gt;&#123; console.log(&#x27;旧值&#x27;,oldValue) //打印出来同为数组 console.log(&#x27;新值&#x27;,newValue) //打印出来同为数组&#125;,&#123; deep:true, //深层次监听，如果用ref定义复杂类型则需要使用这个，如果使用reactive则不需要 immediate:true //页面最开始加载调用一次&#125;)只监听某个数据let mes = reactive(&#123; name:&#x27;123&#x27;, name2:&#x27;232&#x27;&#125;)只监听单一项watch(()=&gt;mes.name,(old,value)=&gt;&#123; &#125;) watchEffect123456789101112131415161718192021222324252627282930313233高级侦听器，非惰性，进入页面自动调用，全部监听watchEffect(()=&gt;&#123; console.log(mes.name)&#125;)监听之前需要做什么watchEffect((oninvalidate)=&gt;&#123; oninvalidate(()=&gt;&#123; console.log(&#x27;先执行该回调，处理一些事情&#x27;) &#125;) console.log(mes.name)&#125;)停止监听const stopWatch = watchEffect((oninvalidate)=&gt;&#123; oninvalidate(()=&gt;&#123; console.log(&#x27;先执行该回调，处理一些事情&#x27;) &#125;) console.log(mes.name)&#125;)@click = () =&gt; stopWatch() //停止额外配置选项watchEffect(()=&gt;&#123; //如果在此处访问dom，非惰性的原因会返回null console.log(mes.name)&#125;,&#123; flush:&quot;post&quot;, //dom加载完后再读取dom onTrigger(e)&#123; //调试 debugger &#125;&#125;) 组件和生命周期12345import Hello from &#x27;..&#x27;&lt;Hello/&gt; 3.2 引入无须在components里注册就能使用生命周期setup，onBeforeMount，onMounted，onBeforeUpdate，onUpdated，onBeforeUnmount，onUnmounted less，scoped123npm install less less-loader -Dscoped //单页面应用保证同类样式不冲突使用了data-v-xxx，样式修改为属性选择器 父子组件传参123456789101112131415161718192021222324252627282930313233343536373839defineProps写法1:title=&quot;&quot;defineProps(&#123; title:&#123; &#125;&#125;)写法2type Props = &#123;title:string&#125; defineProps&lt;Props&gt;()defineEmits子组件const emit = defineEmits([&#x27;emitMes&#x27;...//可以配置多个事件])@click = () =&gt; &#123; emit(&#x27;emitMes&#x27;,params)&#125;父组件@emitMes=&quot;emitmes&quot;const emitmes = (value) =&gt; &#123; console.log(value)&#125;defineExpose子组件const mes = ref(&#x27;hao&#x27;)defineExpose(&#123; mes&#125;)父组件能通过在子组件标签上添加ref的方式获取子组件暴露出来的变量如果希望props有默认值type Props = &#123;title:string&#125; defineProps&lt;Props&gt;()withDefaults(defineProps&lt;Props&gt;(),&#123; title:&#x27;我是默认值&#x27;&#125;) 全局组件，局部组件，递归组件1234567891011121314全局import XXX from &#x27;&#x27;app.component(&#x27;名字&#x27;,XXX) //main.js / main.ts 不能跟随在mount后面进行链式调用局部。。。。。。递归方法1：我引入我自己 //虽然成功但是会有提示警告放发2：再添加一个script，export default &#123;name:&#x27;&#x27;&#125;利用这个name作为组件名称 动态组件123456789import A from &#x27;./&#x27;import B from &#x27;./&#x27;&lt;component :is=&quot;A&quot;&gt;v3的is只能传组件不能传字符串，v2可以传字符串markRaw，为对象添加_v_skip,true时跳过const coms = [&#123; name:&quot;A&quot;, comName:markRaw(A) //组件是无需代理的，需要用markRaw包裹&#125;] 插槽全家桶12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849匿名插槽子组件&lt;slot&gt;&lt;/slot&gt;父组件&lt;子组件名&gt; &lt;template v-slot&gt; 我是插入的内容 &lt;/template&gt;&lt;/子组件名&gt;具名插槽子组件&lt;slot name=&quot;A&quot;&gt;&lt;/slot&gt;&lt;slot name=&quot;B&quot;&gt;&lt;/slot&gt;父组件&lt;子组件名&gt; &lt;template v-slot:A&gt; 我是插入A的内容 &lt;/template&gt; &lt;template v-slot:B&gt; 我是插入B的内容 &lt;/template&gt; //也可简写#===v-slot &lt;template #B&gt; 我是插入B的内容 &lt;/template&gt;&lt;/子组件名&gt;作用域插槽&lt;slot name=&quot;A&quot; :title=&quot;mes&quot;&gt;&lt;/slot&gt;&lt;子组件名&gt; &lt;template v-slot:A=&quot;&#123;title&#125;&quot;&gt; 我是插入A的内容&#123;&#123; title &#125;&#125; &lt;/template&gt;&lt;/子组件名&gt;动态插槽&lt;slot name=&quot;A&quot;&gt;&lt;/slot&gt;&lt;slot name=&quot;B&quot;&gt;&lt;/slot&gt;&lt;子组件名&gt; &lt;template #[name]&gt; 我是插入的内容 &lt;/template&gt;&lt;/子组件名&gt;const name = ref(&#x27;A&#x27;) //插入A@click = () =&gt; &#123; name.value = &#x27;B&#x27; //点击后插入B&#125; 异步组件，代码分包，suspense性能优化1234567891011121314151617181920异步组件defineAsyncComponentdemo：如果A组件是根据异步返回的数据v-for生成，那么视图不会更新，需要使用defineAsyncComponentconst A = defineAsyncComponent(()=&gt;import(&#x27;./A.vue&#x27;))&lt;Suspense&gt; 插槽1： &lt;template #default&gt; &lt;A/&gt; &lt;/template&gt; 插槽2：在异步加载组件之前可以做点什么 &lt;template #fallback&gt; &lt;div&gt; Loading &lt;/div&gt; &lt;/template&gt;&lt;/Suspense&gt;代码分包通过异步组件使代码build后拆分文件，被单独打包suspense teleport传送组件12345将模板渲染至指定DOM节点，不受父级style，v-show影响。但是data，prop数据依旧共用的技术类似于react的Portal&lt;teleport to=&quot;body/.class/#id&quot;&gt; //to=?? 指定传送位置 &lt;div&gt;我是需要传送的内容&lt;/div&gt;&lt;/teleport&gt; keep-alive缓存组件，源码解析1234567891011121314151617不希望组件重复渲染，节省性能include //缓存什么组件，如果无效可能是需要导出组件nameexclude //不缓存什么组件max //最大缓存多少个组件，优先不缓存使用频率低的组件，而不是根据顺序&lt;keep-alive :include=&quot;[&#x27;A&#x27;]&quot;&gt; //只缓存A组件&lt;keep-alive :exclude=&quot;[&#x27;A&#x27;]&quot;&gt; /不缓存A组件 &lt;A/&gt; &lt;B/&gt;&lt;/keep-alive&gt;新增生命周期v3，v2是actived和deactivedonActived //keep-alive初始化onDeactived //keep-alive组件切换卸载keep-alive内部只能有一个根节点源码中对插槽做了判断 缓存机制，map结构，判断key 组件也不是真正卸载 transition动画组件12345678910111213141516171819202122232425262728293031&lt;transition name=&quot;animatename&quot;&gt; &lt;A/ v-if=&quot;flag&quot;&gt; &lt;/transition&gt;@click = () =&gt; &#123; flag.value = !flag.value //隐藏与显示切换太过生硬&#125;style中 //vue提供的类名.animatename-enter-from&#123; width:0px; height:0px&#125;.animatename-enter-active&#123; transition:all 1.5s ease&#125;.animatename-enter-to &#123; width:200px; height:200px&#125;.animatename-leave-from&#123; width:200px; height:200px&#125;.animatename-leave-active&#123; transition:all 1.5s ease&#125;.animatename-leave-to &#123; width:0px; height:0px&#125; transition组件结合animate.css1234567891011自定义classenter-from-class=&quot;&quot; enter-avtive-class=&quot;&quot; enter-to-class=&quot;&quot;leave-from-class=&quot;&quot; leave-active-class=&quot;&quot; leave-to-class=&quot;&quot;duration配置其他属性 动画持续时长duration=&quot;500&quot; //动画持续时长 500毫秒duration=&#123;enter:&quot;500&quot;,leave:&quot;500&quot;&#125; 结合animate.cssnpm install animate.cssimport &#x27;animate.css&#x27;animate.css官网赋值类名为transition标签添加 transition生命周期和GSAP1234567891011121314151617181920212223242526272829303132333435363738@before-enter=&quot;enterFrom&quot; //对应enter-from@enter= //enter-active@after-enter= //enter-to@enter-cancelled= //显示过渡打断@before-leave= //leave-from@leave= //enter-active@after= //leave-to@leave-cancelled= //离开过渡打断const enterFrom = (el:Element) =&gt; &#123; 进入之前&#125;npm install gsap -D //动画库import gsap from &#x27;gsap&#x27;const enterFrom = (el:Element) =&gt; &#123; gsap.set(el,&#123; width:0, height:0 &#125;)&#125;const enterActive = (el:Element,done:gasp.CallBack) =&gt; &#123; gsap.to(el,&#123; width:200, height:200, onComplete:done &#125;)&#125;const leave = (el:Element,done:gasp.CallBack) =&gt; &#123; gsap.to(el,&#123; width:0, height:0, onComplete:done &#125;)&#125; transition的Appear属性1234567&lt;transition appearappear-from-class=&quot;&quot;appear-active-class=&quot;&quot;appear-to-class=&quot;&quot;&gt; &lt;/transition&gt; transitionGroup12345678910111213const list = reactive([1,2,3,4])&lt;transition-group //添加动画属性和transtion相同&gt;列表动画 &lt;div v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt;&lt;/transition-group&gt;const add = () =&gt; &#123; list.push(&#x27;x&#x27;)&#125;const delete = () =&gt; &#123; list.pop()&#125; 平滑过渡动画123456789flip动画库lodash制作随机数let list = [数字们]nom install lodash -Dnpm install @types/lodash -Dimport _ from &#x27;lodash&#x27;@click = () =&gt; &#123; list.value = _.shuffle(list.value) //变换数字排序&#125; 状态过渡1...... 依赖注入provide，inject123import &#123;provide,inject&#125; from &#x27;vue&#x27;provide(&#x27;mes&#x27;,mes) //发送const mes = inject(&#x27;mes&#x27;) //接收 兄弟组件传参12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455利用父组件传参，每次都要在父组件处理，麻烦A@click = () =&gt; &#123; emit(&#x27;change&#x27;,true)&#125;BdefineProps(&#123; flag,&#125;)父组件&lt;A @change=&quot;change&quot;/&gt;const flag = ref(false)const change = (value) =&gt; &#123; flag.value = value&#125;&lt;B :flag=&quot;flag&quot;/&gt;eventBus封装的bus.tstype BusClass &#123; emit:(name:string)=&gt;void on:(name:string,callback:Function)=&gt;void&#125;type PramsKey = string | number | symboltype List = &#123; [key:PramsKey]:Array&lt;Function&gt;&#125;class Bus implements BusClass &#123; list:List constructor()&#123; this.list = &#123;&#125; &#125; emit(name:string,...args:Array&lt;any&gt;)&#123; let eventName:Array&lt;Function&gt; = this.list[name] eventName.forEach(fn =&gt; &#123; fn.apply(this,args) &#125;) &#125; on(name:string,callback:Function)&#123; let fn:Array&lt;Function&gt; = this.list[name] || [] fn.push(callback) this.list[name] = fn &#125;&#125;export default new Bus()import bus from &#x27;//&#x27;bus.emit(&#x27;xx&#x27;,123)bus.on(&#x27;xx&#x27;,(value)=&gt;&#123; console.log(value) //123&#125;) Mitt123456789101112131415161718192021222324252627282930313233343536373839404142Mitt是封装的eventBus库npm install mitt -S局部注册 //不带tsimport mitt from &quot;mitt&quot;;const emitter = mitt();export default emitter全局注册 main.ts import mitt from &#x27;mitt&#x27;consyt Mitt = mitt()需要使用tsdeclare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $Bus:typeof Mitt &#125;&#125;app.config.globalProperties.$Bus = Mitt页面中使用全局注册时import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;const instance = getCurrentInstance()instance?.proxy?.$Bus.emit(&#x27;xx&#x27;,123) //其他页面使用也这样局部注册import bus from &#x27;....&#x27;bus.$emit()bus.$on()监听多个事件bus.$emit(&#x27;A&#x27;)bus.$emit(&#x27;B&#x27;)bus.$on(&#x27;*&#x27;,(type,str)=&gt;&#123; console.log(type,str) //打印出事件名和参数&#125;)取消指定事件bus.$off(&#x27;xx&#x27;)取消所有指定事件bus.all.clear() TSX12345之前使用的是template模板格式npm install @vitejs/plugin-vue-jsx配置太多，手敲太麻烦了，就附带一张长图展示vue使用tsx的配置和注意事项，跟着一步一步来就可以图片最下方有该博主的账号名 ref等api自动引入插件12npm install unplugin-auto-import -D配置百度查看，嘻嘻嘻 v-model深入12345678910111213141516171819202122232425262728293031323334353637v-model是一个语法糖，是结合了props和emit而成默认值的改变：prop: value =&gt; modelValuedemo:控制dialog组件显示与隐藏const flag = ref(true)@click = () =&gt; &#123; flag = !flag&#125;&lt;Dialog v-model=&quot;flag&quot;/&gt;组件内defineProps(&#123; modelValue, &#125;)v-if=&quot;modelValue&quot;事件：input =&gt; update:modelValueconst emit = defineEmits([&#x27;update:modelValue&#x27;])emit(&#x27;update:modelValue&#x27;,123)v-bind的.sync 修饰符和组件的model选项已经移除新增支持多个v-modelv-model:title=&quot;123&quot;新增支持自定义修饰符v-model:hao=&quot;&quot;v-model:title.aass=&quot;title&quot;const props = defineProps(&#123; [绑定属性名]Modifiers?:&#123; hao:string &#125;&#125;)@click = () =&gt; &#123; if(props. [绑定属性名]Modifiers?.hao)&#123; do some thing &#125;&#125; 自定义指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384div v-dir=&quot;123&quot;const vDir = &#123; created()&#123; console.log(&#x27;created&#x27;) &#125;, beforeMount()&#123; &#125;, mounted(...args:Array&lt;any&gt;)&#123; //可以获取一系列信息，节点，值，修饰符等 console.log(args) &#125;, beforeUpdate()&#123; &#125;, updated()&#123; &#125;, beforeUnmount()&#123; &#125;, unmounted()&#123; &#125;&#125;简写const vDir = (el,binding) =&gt; &#123; &#125;小demo，拖拽命令&lt;template&gt; &lt;div v-move class=&quot;box&quot;&gt; &lt;div class=&quot;header&quot;&gt; 头 &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 内容 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref ,reactive,Directive,DirectiveBinding&#125; from &#x27;vue&#x27;;const vMove:Directive&lt;any,void&gt; = (el:HTMLElement,bingding:DirectiveBinding) =&gt; &#123; let moveElement:HTMLDivElement = el.firstElementChild as HTMLDivElement const mousedown = (e:MouseEvent) =&gt; &#123; let X = e.clientX - el.offsetLeft let Y = e.clientY - el.offsetTop const move = (e:MouseEvent) =&gt; &#123; el.style.left = e.clientX - X + &#x27;px&#x27; el.style.top = e.clientY -Y + &#x27;px&#x27; &#125; document.addEventListener(&#x27;mousemove&#x27;,move) document.addEventListener(&#x27;mouseup&#x27;,()=&gt;&#123; document.removeEventListener(&#x27;mousemove&#x27;,move) &#125;) &#125; moveElement.addEventListener(&#x27;mousedown&#x27;,mousedown)&#125;&lt;/script&gt;&lt;style scoped&gt;.box &#123; height: 500px; width: 400px; position: relative; left:200px; top: 300px;&#125;.header &#123; width: 100%; height: 60px; border: 1px solid #ccc; line-height: 60px;&#125;.content &#123; width: 100%; height: 400px; border: 1px solid #ccc;&#125;&lt;/style&gt; 自定义hooks123456789101112与v2mixin很像，mixin含有的问题，生命周期调用的比组件快开源库vueUse，hook库import &#123; useAttrs &#125; from &#x27;vue&#x27; //是一个收集props的hooklet attrs = useAttrs()console.log(attrs)export default function () &#123; return 123&#125;import useXX from &#x27;..&#x27;const xx = useXX() 全局函数和变量12345678910111213141516171819vue3不能在原型上挂载，要修改方式定义时 //vue3移除了fillter，定义一个$filters过滤器,带tsapp.config,globalProperties.$filters = （）=&gt; &#123; format&lt;T&gt;(str:T):string&#123; return `过滤器$&#123;str&#125;` &#125;&#125;,app.config,globalProperties.$env = &#x27;1232&#x27;type Filter = &#123; format:&lt;T&gt;(str:T)=&gt;string&#125;declare module &#x27;@vue/runtime-core&#x27; &#123; export interface ComponentCustomProperties &#123; $filters:Filter, $env:string &#125; &#125;使用时&#123;&#123; $filters.format(&#x27;123&#x27;) &#125;&#125; 自定义vue插件12345678910111213141516171819202122232425262728插件是自包含的代码，通常是向Vue添加全局功能，如果是一个对象需要install方法Vue会帮助自动注入install方法，如果是function就可以直接当install使用在createApp之后通过use()添加插件index.tsimport &#123; App , createVNode,render&#125; from &#x27;vue&#x27;import Loading from &#x27;...&#x27;export default &#123; install(app:App)&#123; const vnode:VNode = createVNode(Loading) render(vnode,document.body) app.config.globalPropertiees.$loading = &#123; show:vnode.component?.exposed?.show, hide:vnode.component?.exposed?.hide, &#125; 。//需要先defineExpoed暴露出 &#125;&#125;main.tsimport Loading from &#x27;loading.ts&#x27;app.use(Loading) //如果使用ts需要声明使用：import &#123; getCurrentInstance,ComponentInternalInstance &#125; from &#x27;vue&#x27;const &#123; appContext &#125; = getCurrentInstance() as ComponentInternalInstance// 听说 const &#123; proxy &#125; = getCurrentInstance()可以直接获取到全局方法appContext.config.globalProperties.$loading.show()appContext.config.globalProperties.$loading.hide() elementUI12具体看官网 样式穿透:deep()12345vue3style中:deep(eleUI的样式类名)&#123; &#125; css完整新特性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455除开:deep插槽选择器和全局选择器插槽选择器:slotted(插槽内节点类名)&#123;&#125;全局选择器原本直接在app.vue中修改样式就是全局样式，但是vue3提供了一个优雅的写法:global(div)&#123; &#125;动态css和cssmodule动态cssconst color = ref(&#x27;red&#x27;)div&#123; color:v-bind(color)&#125;如果是对象const color = ref(&#123; colorStyle:&#x27;&#x27;&#125;)div&#123; color:v-bind(color.colorStyle) //不能直接.需要修改成color:v-bind(&#x27;color.colorStyle&#x27;)字符串形式&#125;cssmodule&lt;style module&gt; .div &#123; color:red &#125; .di &#123; border:1px solid red &#125;&lt;style&gt;使用时&lt;div :class=&quot;[$style.div,$style.di]&quot;/&gt;也可import &#123; useCssModule &#125; from &#x27;vue&#x27;const css = useCssModule(&#x27;style&#x27;)console.log(css)&lt;style module=&quot;style&quot;&gt; .div &#123; color:red &#125; .di &#123; border:1px solid red &#125;&lt;style&gt;//改写法比较适用于tsx，jsx写法 vue3集成TailWindCss123TailWindCss是一个js编写的css框架，基于postCss解析postCss是一个js编写的使用js工具和插件转换CSS代码的工具下方截取了其他博主的博客教程，一步步配置即可 EventLoop12345678910111213141516171819事件循环机制js是单线程的，如果是多线程的话，同一时间会操作多个dom，增加或者删除，单线程意味着所有的任务都要排队，如果前面的任务耗时长，那么后续任务就会卡住，影响用户体验，因此出现了异步的概念//HTML5已经支持多线程webWorker，但是不能操作dom同步任务代码从上到下执行异步任务Promise是同步的宏任务script,定时器，ajax，UI交互微任务promise.then,catch,finally,process.nextTick运行机制所有同步任务都是在主线程形成执行栈，主线程之外还有个任务队列，异步任务执行队列会先执行宏任务，然后清空宏任务中的微任务，再进行下一个tick形成循环nextTick就是创建一个异步任务，会等待同步任务执行完以后再执行 nextTick，源码解析123456789101112更新dom内容后，访问还是之前的值import &#123; nextTick &#125; from &#x27;vue&#x27;const mes = ref(&#x27;1&#x27;)const div = ref(null)@click = () =&gt; &#123; mes.value = &#x27;123&#x27;&#125;await nextTick()console.log(div.value.innerText) //正常情况打印应该是123，这里是1，因此需要nextTick源码迷惑后续看吧 vue开发移动，打包APP暂时跳过1暂时跳过...... unoCss原子化123456789什么是css原子化减少css体积，提高css复用减少起名复杂度缺点：增加了记忆成本，势必要记住一些api集合了tailwindcss和其他css框架接入unocss //适用于vite，webpack是阉割版npm i unocss -D 函数式编程和h函数123456789101112131415161718192021222324252627h函数底层，createVNodeh函数接收三个参数type：元素类型propsOrChildren：数据对象，表示props，attrs，dom props，class和stylechilren：子节点h(&#x27;div&#x27;)h(&#x27;div&#x27;,&#123; id:&#x27;foo&#x27;&#125;)h(&#x27;div&#x27;,&#123;class:&#x27;foo&#x27;,innerHTML:&#x27;foo&#x27;&#125;)const div = h(...) //创建，但是并未渲染到页面render(div,document.body) //渲染插入bodytype Props = &#123; text:string&#125;const btn = (props:Props,ctx:any) =&gt; &#123; return h(&#x27;div&#x27;,&#123; class:[&#x27;&#x27;], onClick:()=&gt;&#123; ctx.emit(&#x27;on-click&#x27;,&#x27;123&#x27;) &#125; &#125;,&#123; &#125;)&#125; vue3开发Electron桌面程序 响应性语法糖1都是实验性产物，想使用需要自己开启 配置用户代码片段有个小妙招，可以自定义快捷代码片段输入v3可以快速生成vue3代码片段模板vscode点击左下角配置代码片段，搜索vue3，如果没有就新建一个，百度一下模板很多 环境变量123天天去别人博客扒图的我 //555vite的话需要打印import.meta.env.得到环境变量相关信息之前是打印的process,env... pinia123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135替代vuex完整ts支持轻量，压缩体积只有1kb左右去除mutationactions支持同步和异步npm install pinia -D --savemain.tsimport &#123; createPinia &#125; from &#x27;pinia&#x27; //2和3版本不一样const store = createStore()app.use(store)使用新建store文件夹import &#123; defineStore &#125; from &#x27;pinia&#x27;export const Test = defineStore(&#x27;id&#x27;,&#123; state:()=&gt;&#123; return &#123; current:1, name:&#x27;hao&#x27; &#125; &#125;, // 类似computed,具有缓存 getters:&#123; &#125;, // 类似methods,同步异步都可以做 actions:&#123; &#125;&#125;)引入页面使用import &#123; Test &#125; from &#x27;...&#x27;const test = Test()&lt;div&gt;&#123;&#123; test.name &#125;&#125;&lt;/div&gt;修改state方式1：可以在页面直接@click = () =&gt; &#123; text.name = &#x27;xu&#x27;&#125;2：通过pinia@click = ()=&gt; &#123; Test.$patch(&#123; current:2, name:&#x27;xu&#x27; &#125;)&#125;3：依旧是patch@click = () =&gt; &#123; Test.$patch((state)=&gt;&#123; state.current = 3 state.name = &#x27;xu&#x27; &#125;)&#125;4：弊端，直接覆盖，必须修改整个对象@click = () =&gt; &#123; Test.$state = &#123; current:4, name:&#x27;ye&#x27; &#125;&#125;5：actionactions:&#123; setCurrent(params)&#123; this.current = 999 || params &#125;&#125;@click = () =&gt; &#123; Test.setCurrent(//也可以传参123)&#125;解构storeconst &#123; current,name &#125; = Test和reactive是一样的，解构失去响应式解决方式import &#123; storeToRefs &#125; from &#x27;pinia&#x27;const &#123; current,name &#125; = storeToRefs(Test)源码是先将数据转换成toRaw再判断赋予响应getters和actionsactions支持同步和异步，可以相互调用getters：&#123; newName():string&#123; return `$-$&#123;this.name&#125;` &#125;&#125;其他apiTest.$reset()订阅state改变Test.$subscribe((args,state)=&gt;&#123;console.log(args,state)&#125;,&#123;detached:true,deep:true,flush:&quot;post&quot;&#125;)订阅action的调用Test.$onAction((args)=&gt;&#123;console.log(args)&#125;,true)见下方图持久化插件vuex和pinia刷新都会丢失数据const store = createStore()const setStorage = (key:string,value:any) =&gt; &#123; localStorage.setItem(key,JSON.stringify(value))&#125;const getStorage = (key:string) =&gt; &#123; localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key) as string) : &#123;&#125;&#125;typr Option = &#123; key?:string&#125;const defaultPiniaKey:string = &#x27;hao&#x27;const piniaPlugin = (options:Option) =&gt; &#123; return (context:PiniaPluginContext) =&gt; &#123; const &#123; store &#125; = context const data = getStorage(`$&#123;options?.key ?? defaultPiniaKey&#125;-$&#123;store.$id&#125;`) store.$subscribe((args,state)=&gt;&#123; setStorage(`$&#123;options?.key ?? defaultPiniaKey&#125;-$&#123;store.$id&#125;`,toRaw(store.$state)) &#125;) return &#123; ...data &#125;&#125;store.use(piniaPlugin(&#123; key:&#x27;pinia&#x27;&#125;)) 穿插的可视化项目1 摸鱼神器JSON2TS插件自动生成ts 新建一个json文件 将返回的数据粘贴里面 滑动至json文件底部 ctrl +alt + v Router路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288npm init vue#latestnpm init vite@latest //该方式创建时没有router选项npm install vue-router -srouter/index.tsimport &#123; createRouter,createWebhistory ,RouteRecordRaw&#125; from &#x27;vue-router&#x27;const routes:Array&lt;RouteRecordRaw&gt; = [&#123; path:&#x27;/login&#x27;, component:Login | () =&gt; import(&#x27;./Login.vue&#x27;)&#125;]const router = createRouter(&#123; history:createWebhistory(), routes&#125;)export default routermain.tsimport router from &#x27;..&#x27;app.use(router)app.vuerouter-viewrouter-link to=&quot;/login&quot;路由模式的变化vue2 mode =&gt; vue3 modehash =&gt; createHashHistoryhistory =&gt; createWebHistoryabstract =&gt; createMemoryHistoryhash模式实现原理是location.hashlocation.hash = &#x27;/login&#x27;监听左右箭头前进和回退window.addEventListener(&#x27;hashchange&#x27;,(e)=&gt;&#123;console.log(e)&#125;)//监听前进和回退history模式不带#，是基于h5的history实现的监听左右箭头window.addEventListener(&#x27;popstate&#x27;,(e)=&gt;&#123;console.log(e)&#125;)跳转方式history.pushState(&#123;&#125;,&#x27;&#x27;,&#x27;/login&#x27;)编程式导航&#123; path:&#x27;&#x27;, name:&#x27;Login&#x27;, component:&#x27;&#x27;&#125;router-link to=&quot;path&quot;router-link :to=&quot;&#123;name:&#x27;Login&#x27;&#125;&quot;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()@click = () =&gt; &#123; router.push(&#x27;/login&#x27;) router.push(&#123; path:&#x27;/login&#x27;, &#125;) router.push(&#123; name:&#x27;Login&#x27;, &#125;)&#125;不保存历史记录router-link replace :to=&quot;&#123;name:&#x27;Login&#x27;&#125;&quot; //添加replace以后不保存历史记录@click = () =&gt; &#123; router.replace(&#x27;/login&#x27;)&#125;前进和后退router.go(1) //前进router.back(1) //后退路由传参新的和json2TS差不多的插件=》 json to tsctrl + shift + alt + s@click = (obj) =&gt; &#123; router.push(&#x27;/login&#x27;) router.push(&#123; path:&#x27;/login&#x27;, query:obj //query只能接收对象 &#125;) router.push(&#123; name:&#x27;Login&#x27;, params:&#123;&#125; //地址栏不会显示传参信息，params参数存在内存中，因此刷新页面参数会丢失 &#125;)&#125;在跳转的页面获取传值import &#123; useRoute &#125; from &#x27;vue-router&#x27;const route = useRoute()route.paramsroute.query动态路由传参&#123; path:&#x27;/login/:id&#x27;, name:&#x27;Login&#x27;, component:&#x27;&#x27;&#125;router.push(&#123; name:&#x27;Login&#x27;, params:&#123; id:item.id //和路径后动态的参数名要相同 &#125; //地址栏不会显示传参信息，params参数存在内存中，因此刷新页面参数会丢失 &#125;) 嵌套路由 &#123; path:&#x27;/home&#x27;, name:&#x27;Home&#x27;, component:Home, children:[&#123; path:&#x27;/login&#x27;, //最后的跳转路径 /home/login name:&#x27;Login&#x27;, component:Login, &#125;]&#125;命名视图命名视图可以在同一级/同一个组件中展示更多的路由视图，而不是嵌套展示，命名视图可以让一个组件中具有多个路由渲染出口。对于一些固定布局的组件非常有用，类似具名插槽，视图默认名称也是default一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件&#123; path:&#x27;/home&#x27;, name:&#x27;Home&#x27;, components:&#123; default:()=&gt;import(Home), header:()=&gt;import(Header), content:()=&gt;import(Content) &#125;&#125;使用时router-view router-view name=&quot;header&quot;router-view name=&quot;content&quot;路由重定向，路由别名重定向方式1：字符串形式 &#123; path:&#x27;/home&#x27;, name:&#x27;Home&#x27;, component:Home, children:[&#123; path:&#x27;/login&#x27;, //最后的跳转路径 /home/login name:&#x27;Login&#x27;, component:Login, &#125;]&#125;,&#123; path:&#x27;/&#x27;, redirect:&quot;/home&quot;, //重定向&#125;重定向方式2：对象形式&#123; path:&#x27;/&#x27;, redirect:&#123; path:&#x27;/home&#x27; &#125;&#125;重定向方式2：回调函数形式&#123; path:&#x27;/&#x27;, redirect: (to) =&gt; &#123; return &#x27;/home&#x27; return &#123; path:&#x27;/home&#x27;, params:&#123; name:&#x27;hao&#x27; //传参 &#125; &#125; &#125;&#125;路由别名alias&#123; path:&#x27;/home&#x27;, component:Home, alias:[&#x27;/red&#x27;,&#x27;/green&#x27;,&#x27;/blue&#x27;] // 无论访问哪个路由，都是/home&#125;导航守卫全局前置守卫router.beforeEach((to,next,from)=&gt;&#123; &#125;)后置守卫router.afterEach((to,next,from)=&gt;&#123; &#125;)导航进度条，设置动画window.requestAnimationFrame()window.cancelAnimationFrame()路由元信息&#123; path:&#x27;/home&#x27;, component:Home, meta:&#123; title:&#x27;首页&#x27;, //页面标题 nedd:true //是否需要权限 &#125;&#125;使用守卫中console.log(to) //to中包含meta路由过渡动效/copy的小满大佬文章想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 v-slot API： &lt;router-view #default=&quot;&#123;route,Component&#125;&quot;&gt; &lt;transition :enter-active-class=&quot;`animate__animated $&#123;route.meta.transition&#125;`&quot;&gt; &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/router-view&gt;上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息和动态的 name 结合在一起，放在&lt;transition&gt; 上： declare module &#x27;vue-router&#x27;&#123; interface RouteMeta &#123; title:string, transition:string, &#125;&#125; const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/views/Login.vue&#x27;), meta:&#123; title:&quot;登录页面&quot;, transition:&quot;animate__fadeInUp&quot;, &#125; &#125;, &#123; path: &#x27;/index&#x27;, component: () =&gt; import(&#x27;@/views/Index.vue&#x27;), meta:&#123; title:&quot;首页！！！&quot;, transition:&quot;animate__bounceIn&quot;, &#125; &#125; ]&#125;)滚动行为使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。vue-router 可以自定义路由切换时页面如何滚动。当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法const router = createRouter(&#123; history: createWebHistory(), scrollBehavior: (to, from, savePosition) =&gt; &#123; 记录上个页面滚动至的位置，返回依旧处于那个位置 if(savePosition)&#123; return savePosition &#125; else &#123; return &#123; top:0 &#125; &#125; 或者 console.log(to, &#x27;==============&gt;&#x27;, savePosition); return new Promise((r) =&gt; &#123; //支持异步 setTimeout(() =&gt; &#123; r(&#123; top: 10000 &#125;) &#125;, 2000); &#125;) &#125;,scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。scrollBehavior 返回滚动位置的对象信息，长这样：&#123; left: number, top: number &#125;const router = createRouter(&#123; history: createWebHistory(), scrollBehavior: (to, from, savePosition) =&gt; &#123; return &#123; top:200 &#125; &#125;动态路由 暂时到这里了，后面复习一下","categories":[{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/tags/vue3/"}]},{"title":"webgl入一下门","slug":"webgl1","date":"2022-08-25T04:12:33.000Z","updated":"2022-08-25T05:16:53.366Z","comments":true,"path":"2022/08/25/webgl1/","link":"","permalink":"https://222cabbage.github.io/2022/08/25/webgl1/","excerpt":"","text":"webGL入门webGL是openGL的子集 12const canvas = document.querySelector(&#x27;canvas&#x27;)const gl = canvas.getContext(&#x27;webgl&#x27;) 老的浏览器 。。。先暂停一下，涉及到知识盲区了，得先去恶补一下","categories":[{"name":"webGL","slug":"webGL","permalink":"https://222cabbage.github.io/categories/webGL/"}],"tags":[{"name":"webGL","slug":"webGL","permalink":"https://222cabbage.github.io/tags/webGL/"}]},{"title":"vite入门","slug":"vite1","date":"2022-08-24T13:22:57.000Z","updated":"2022-08-25T04:11:27.995Z","comments":true,"path":"2022/08/24/vite1/","link":"","permalink":"https://222cabbage.github.io/2022/08/24/vite1/","excerpt":"","text":"Vite入门为什么需要工程化？ 太多的资源文件，高级语法，优化代码体积，提升代码效率，热更新 提供模块加载方案，兼容不同模块规范 高级语法转译，如sass，ts。资源加载，图片，字体，worker 产物压缩，无用代码剔除，对不支持高级语法的浏览器等平台进行语法降级 热更新 特点No-bundle开发服务，源文件无需打包 生产环境基于Rollup的Bundler 高性能，dev启动速度和热更新速度非常快 相比于webpack配置简单易用，开发体验好 传统构建工具缺点：编译慢，热更新慢 瓶颈；bundle带来的性能开销，js语言本身的性能瓶颈 vite：基于原生js的ESM，浏览器无需打包源代码，祛除了bundle的性能开销，天然的按需加载，可以利用文件级的浏览器缓存 深度使用esbuild 1234567npm i pnpm -gpnpm create vite // 根据项目进行条件选择pnpm i // 下载依赖pnpm run devpnpm i sass -D其他配置tree shaking在vite中默认开启 为什么要进行预打包？避免node_modules过多文件请求 将commonjs转换为ESM格式 实现原理：服务启动前检查项目依赖 用esbuild对依赖代码进行预打包 改写import语句，指定依赖为预构建产物路径 1234567891011改写前import React from &#x27;react&#x27;改写后import React from &#x27;./node_modules/.vite/react.js&#x27;关键技术：单文件编译使用esbuild完成局限性：不支持类型检查，不支持语法降级到es5，最低es6，因此在生产环境需要调用tsc关键技术：代码压缩关键技术：插件机制开发阶段 =&gt; 模拟rollup插件机制生产阶段 =&gt; 直接使用rollup注：不是所有rollup插件都能兼容vite vite后续学习路线：esbuild，rollup：可以去看官方文档，编写的很好 先尝试基础的配置 再进阶插件开发 为什么需要插件机制vite钩子： 插件的配置和使用demo 代码拆包…… babeljs语法标准繁多，浏览器支持程度不同，将高级语法降级 原理：将代码转换为高级语法抽象语法树，再转换为低级语法抽象树，再通过babel的generator转换为代码 语法安全降级解决方案：vite上层解决方案：@vitejs&#x2F;plugin-legacy 底层原理：借助babel进行语法降级，提前注入Polyfill实现，如core-js，regeneraator-runtime 服务端渲染SSR 未完待续……","categories":[{"name":"vite","slug":"vite","permalink":"https://222cabbage.github.io/categories/vite/"}],"tags":[{"name":"vite","slug":"vite","permalink":"https://222cabbage.github.io/tags/vite/"}]},{"title":"接触一下ts","slug":"tsstudy1","date":"2022-07-10T03:11:20.000Z","updated":"2022-10-07T05:40:49.106Z","comments":true,"path":"2022/07/10/tsstudy1/","link":"","permalink":"https://222cabbage.github.io/2022/07/10/tsstudy1/","excerpt":"","text":"学习TS12345678910首先全或者在对应文件夹下npm install typeescript -g / -Dtsc init 生成ts配置文件outDir输出目录rootDir代码根目录tsc 打包安装ts-node可以直接运行ts代码，无序将ts编译成js、npm install ts-node -D安装nodemon可以自动检测目录中文件改动后自动重新启动npm install nodemon -D 12345678910&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;&#125;,监听src文件夹下后缀名为ts的文件变化，一有变化就重新执行index.ts文件parcle打包运行 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;, &quot;start&quot;: &quot;parcel ./index.html&quot; &#125;, 概念12345678类是拥有相同属性和方法的集合，有静态特征和动态特征静态特征：属性，姓名属性动态特征：方法，吃饭走路创建类的过程1：在堆中开辟一块空间2：调用对应构造函数 new XXX() 匹配构造器constructor3：把对象赋值给对象变量/吧实例赋值给实例对象/改变this指向 类的源码，底层，原生es5 转换为es5函数 引用属性数组，函数，类，对象，对象数组，集合类set，map，自定义，集合类 12345678910constructor中的参数本身需要通过this.xx = xx为属性赋值，括号纵只是参数但是如果添加了public等修饰符，就不用再赋值，会隐式操作挂载为属性constructor(name,age)&#123; this.name = name this.age = age&#125;添加public等修饰符后constructor(public name,public age)&#123; 不需要再赋值，隐式挂载&#125; 函数重载12345678910111213141516171819202122232425262728293031323334353637不使用重载function(value: number | Message):Message | Array&lt;Message&gt; | undefined &#123; if(typeof value === &#x27;number&#x27;)&#123; return messages.find(item =&gt; item.id === value) &#125; else &#123; return messages.filter(item =&gt; item.type === value) &#125;&#125;缺点：联合类型中，方法属性会受到限制，会提取公用属性和方法，交集TS无法根据参数来推倒最终返回的类型中的数据类型只可以根据方法定义的类型来展现使用重载函数重载规则函数签名 = 函数名 + 函数参数 + 函数参数类型 + 返回值类型，不包括函数体函数重载定义由一个实现签名或者多个实现签名组成外部调用时，只能调用重载签名，不能调用实现签名调用重载函数时，会根据传递的参数来判断你调用的是哪一个函数只有一个函数体，只有实现签名配备了函数体function getMessage(id:number):numberfunction getmessage(message:Message):Array&lt;Message&gt;function getMessage(value:any):number | Array&lt;Message&gt; | undefined &#123; if(typeof value === &#x27;number&#x27;)&#123; return messages.find(item =&gt; item.id === value) &#125; else &#123; return messages.filter(item =&gt; item.type === value) &#125;&#125;有利于功能扩展任何类型都是unknown的子类型何时用any，何时用unknownunknown只能作为父类，不能作为子类let x:unknown = 3let z:number = x 方法重载12345规则与函数重载相同，有细小区别方法是特定情境下的函数，由对象变量/实例变量直接调用的函数都是方法let p = new P()p.sendMessage()//方法方法签名 = 方法名称 + 方法参数 + 方法参数类型 + 方法返回值类型 在new时，会隐式的将this返回给左边的对象变量。this和等号左边变量都指向当前正创建的对象 重载应用，求图形面积12345678910111213141516171819202122232425262728type type_s = &#123; width:number, height:number, radious?:number&#125; class Square &#123; public width:number public height:number constructor(width:number,height:number) // 重载签名 constructor(type:type_s) // 重载签名 constructor(value:any,height?:number)&#123; this.width = value this.height = height if(typeof value === &#x27;object&#x27;)&#123; let &#123; width,height &#125; = value this.width = width this.height = height &#125;else&#123; this.width = value this.height = height &#125; &#125; public getArea()&#123; return this.width * this.height &#125; &#125; let s = new Square(30,40) let s2 = new Square(&#123;width:20,height:30&#125;) 单件设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243单件设计模式概述一个类对外有且仅有一个实例如果一个类对外只提供一个对象类，并且在该类的内部提供了一个外部可以访问该对象的属性和方法通过静态方法访问public static getXXX()&#123; &#125;静态方法和对象无关，外部变量无法访问静态方法和属性，可以通过类名调用静态方法和原型方法/对象方法是不同的，互相都不能访问一个静态方法改变了某个静态属性，其他静态方法或者外部任何地方访问这个属性都会改变除了栈，堆之外，还有静态内存区静态成员保存在内存的静态区，静态成员的内存分配要早于对象空间的分配，也就是对象创建之前，Ts就已经为静态成员分配好了空间，一个静态方法分配一个空间，只要服务器电脑不重启，静态方法就一直保存在内存空间，无论调用多少次，访问的都是同一片空间export default class MyLocal&#123; // 饿汉式 直接先创建 static localStorage:MyLocal = new MyLocal（） private constructor()&#123; &#125; // 给外部提供访问内部对象的方法 public static getConstructor()&#123; // 懒汉式 调用方法才创建 if(!this.localStorage)&#123; this.localStorage = new MyLocal() &#125; return this.localStorage &#125; public static setItem(key:string,value:any)&#123; localStorage.setItem(key,JSON.stringify(value)) &#125; public getItem(key:string)&#123; let value = localStorage.getItem(key) return value != null ? JSON.parse(value) : null &#125; public removeItem(key:string)&#123; localStorage.removeItem(key) &#125;&#125;import &#123; MyLocal &#125; from &#x27;./MyLoacl.js&#x27;MyLocal.getConstructor()什么情况适合采用单件模式。较多复用的内容，后续多使用，方法类，对象属性并不多，创建实例意义不大 继承Loading学习到5-5先跳过1 类型断言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 类型断言，类型转换// a数据类型 as b数据类型 // a和b必须要有交叠 // 判断交叠的条件// 场景1 a和b都是类并且是父子继承关系 通常是将父类类型转换为子类类型// class Father &#123;// public name:string// &#125;// class Son extends Father&#123;// study()&#123;// &#125;// &#125;// let fat = new Father()// let res = fat as Son 将father类型转换为son类型// 什么是类型转换// let res = &lt;Son&gt;fat// res.// let son = new Son()// let res2 = son as Father// res2.// new 的底层发生了什么// 场景2 ab都是类 但是没有继承关系 转换后的类型必须包含转换前的类型的所有属性 转换之前的属性是转换之后的子集// class A &#123;// public name:string// &#125;// class B &#123;// public name:string// public age:number// &#125;// let a = new A()// let res = a as B// let b = new B()// 场景3 A是类，b是接口，A类实现了B接口 implements// interface B &#123;// username:string,// age:number// &#125;// class A implements B &#123;// public username: string// public age: number// &#125;// 场景4 A是类 B是接口 A类没有实现B接口// 场景5 A是类 B是type定义的类型// type B = &#123;// username:string,// age:number// &#125;// class A implements B &#123;// public username: string// public age: number// &#125;// 场景6 A是类 B是type定义的类型 A没有实现B定义的数据类型// type B = &#123;// username:string,// age:number// &#125;// class A &#123;// public username: string// public age: number// &#125;// 场景7 A是一个函数上参数的联合类型变量// function SS(name:string | number)&#123;// let num = name as number + 3// &#125;// 场景8 多个类组成的联合类型如何断言// let a:A | B | C// a as A// a as B// a as C// 场景9 转换为any或者unknown类型 类型守卫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354类型守卫需要了解一下new 的过程class Person &#123; name age&#125;let per = new Person()1：创建一个obj对象var obj = &#123;&#125;2：使创建对象的__proto__指向构造函数/类的prototypeobj.__proto = Person.prototype3：借用构造函数/类的apply为obj对象添加name与age属性Person.apply(obj,[&quot;1232&quot;,123])类型守卫在词句的块级作用域内，if语句内或者条目运算符表达式以内，缩小变量类型的一种类型推断的行为类型守卫产生时机 获得更精准的变量类型，减少不必要的类型断言类型判断 typeof属性或方法判断 in 判断属性或者方法是不是在该对象中 &quot;name&quot; in obj &quot;getname&quot; in obj实例判断 instanceof字面量相等判断 == === != !==typeof 局限性检测范围 string | number | bigint | boolean | symbol | undefined | object | function检测变量并不完全准确typeof null 结果为objecttypeof [] 结果为objecttypeof替代方案Object.prototype.toString.call(检测对象)仍然无法解决自定义函数类，使用instanceofinstanceofa instanceof b 可用于原型链继承关系 子类 instanceof 父类 左边是否是右边的实例对象 会一直在左边的实例对象的__proto__一直查找到Object的prototype空间instanceof应用场景class car &#123;&#125;class Bus &#123;&#125;car 和 Bus类中各自包含一个求总价的方法class GetTotal &#123; returnTotal(cartype:car | Bus)&#123; if(cartype instanceof car)&#123; return car.total() &#125; else if(cartype instanceof Bus)&#123; return Bus.total() &#125; &#125;&#125;根据不同车类型返回价格 自定义守卫12345678910111213141516自定义守卫格式function 函数名 （形参：参数类型/大多为any）：形参 is A类型 = boolean + 类型守卫能力&#123; return true / false&#125;function isString(str:any):str is string&#123; return typeof str === &#x27;string&#x27;&#125;function isFunc(str:any):str is Function&#123; return typeof str === &#x27;function&#x27;&#125; 抽象类123456789101112131415161718192021抽象类一个在任何位置都不能实例化的类就是一个抽象类，实例化无意义的类包含0个或多个带有方法体的方法和不带有方法体的抽象方法父类的抽象方法会在子类强制实现abstract class A &#123; public name:string public eat()&#123; &#125; public abstract run():void&#125;class B extends A &#123; public run(): void &#123; console.log(&#x27;1232&#x27;) &#125;&#125;let a = new A() // 抽象类无法实例化抽象类扩大，适配器后端称为适配器adapterexport &#123;&#125; 多态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768多态定义：父类的对象变量可以接收任何一个子类的对象从而用这个父类的对象变量来调用子类中重写的方法而输出不同的结果产生条件：1：必须存在继承关系2：必须有方法重写利于项目拓展无法调用子类独有方法，必须结合instanceif类型守卫解决属性不必完全重叠，在继承的情况下class Father &#123; name:string eat()&#123; console.log(&#x27;父亲吃饭&#x27;) &#125;&#125;class A extends Father&#123; age:number eat()&#123; console.log(&#x27;A&#x27;) &#125;&#125;class B extends Father &#123; address:string eat(): void &#123; console.log(&#x27;B&#x27;) &#125;&#125;let fat:Father = new B()改写汽车返回价格class Fat &#123; total()&#123; &#125;&#125;class car extends Fat &#123; total()&#123; &#125;&#125;class Bus extends Fat &#123; total()&#123; &#125; aaa()&#123; &#125;&#125;car 和 Bus类中各自包含一个求总价的方法class GetTotal &#123; returnTotal(cartype: Fat)&#123; return cartype.total() // 只能调用total方法 无法调用B类中独有的的aaa方法 &#125;&#125;let gettotal = new GetTotal()let car = new car()let bus = new Bus()gettotal(car)gettotal(bus) 新特性可变元祖1234let arr:[number,string,string,string] = [123,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]let arr2:[number,string,...any[]] = [123,&#x27;2&#x27;,123,&#x27;456&#x27;] let [username,age,...rest]:[username_:string,age_:number,...rest:any[]] = [&quot;123&quot;,123,&#x27;456&#x27;]let [username,age,...rest,desc]:[username_:string,age_:number,...rest:any[],desc_:string] = [&quot;123&quot;,123,&#x27;456&#x27;,&#x27;123&#x27;] 泛型类1234567891011121314class Person&lt;T&gt;&#123; public List:Array&lt;T&gt; constructor()&#123; this.List = [] &#125; add(element:T)&#123; this.List.push(element) &#125;&#125;let person = new Person&lt;string&gt;()泛型的参数可以使A-Z的任一大写字母，也可以是语义化的单词Object是所有类型的父类型，object只是对象类型 Object object unknown和any的区别……. 泛型约束1234567891011121314151617181920212223T extends object表示具体化的类型只能是object类型typeof obj能获得该对象的类型let obj = &#123;name:&#x27;&#x27;,age:2&#125;console.log(typeof obj) //&#123;name:string,age:number&#125;keyof Kkeyof表示获取一个类或者一个对象类型，或者一个接口类型的所有属性名组成的联合类型console.log(keyof 类型/也可以是类) //name | age 甚至可以获取到类上的方法名keyof typeof objT extends keyof KT是K联合类型中的某一个或者全部联合类型let obj = &#123;name:&#x27;&#x27;,age:2&#125;type one = typeof obj //&#123;name:string,age:number&#125;type two = keyof one // //name | age type objKeyType = one[two] / type objKeyType = one[&#x27;name&#x27;] //string || number 得到值的类型 泛型接口12345678910111213141516171819interface List&lt;T&gt;&#123; add(ele:T):void; get(index:number):T; size():number; remove(value:T):T&#125;class Person&lt;T&gt; implements List &lt;T&gt;&#123; public add()&#123; &#125; ......&#125;let per = new Person&lt;&gt;()如果类型是any，会很麻烦，无法判断返回值原型对象所携带的方法，无法智提示一个父类数组对象变量里面的每一个元素都可以是任何一个该父类的子类对象 泛型函数12345function fn&lt;T&gt;(arr:Array&lt;T&gt;):Array&lt;T&gt;&#123; &#125;泛型函数可以在调用返回后得到返回值的具体类型数据，从而可以有自动方法和属性的提示和错误编译提示 泛型函数重载分工明确 12345function fn(data:string):stringfunction fn&lt;T&gt;(data:T):T[]function fn(data:any):any&#123; &#125; 泛型工厂函数1234567891011121314151617181920212223242526272829工厂函数类型定义代表所有类【等价JS的构造函数】的函数类型泛型工厂函数定义：一个可以创建任意类对象的通用函数使用场景：不方便或者没有办法直接new类名()格式来创建对象，在一些测试欧哲调试代码中简化代码使用通用函数类型type fn = （...args：any）=&gt; anyinterface fn &#123; (..args:any):any&#125;function fnn:fn = () =&gt; &#123; &#125;let t = new Test() //在ts中不能直接new一个函数创建实例type fn = new (...args) =&gt; Student学生类type fn = new (...args) =&gt; Teacher老师类更加具备通用性type fn = new (...args) =&gt; any工厂函数泛型工厂函数 交叉类型1234567891011将多个类型合并【多个类型属性和方法的并集】成的类型就是交叉类型type1 = type2 = type3 = let obj:type1 &amp; type2 &amp; type3 = 交叉类型可以获取两个类型的任意变量和方法，联合类型只能获取共有属性和方法应用场景 infer12infer表示在extends条件语句中以占位符出现的用来修饰数据类型的关键字，被修饰的数据类型等到使用时才能被推断出来 ts高级类型extract 1 exclude 1 record 1 pick 1 partial required readonly omit","categories":[{"name":"typescript","slug":"typescript","permalink":"https://222cabbage.github.io/categories/typescript/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://222cabbage.github.io/tags/ts/"}]},{"title":"vue2源码","slug":"vue2code1","date":"2022-07-01T17:37:06.000Z","updated":"2022-07-17T17:47:01.352Z","comments":true,"path":"2022/07/02/vue2code1/","link":"","permalink":"https://222cabbage.github.io/2022/07/02/vue2code1/","excerpt":"","text":"Vue2源码学习感觉工作了几个月了，也该看一看源码了，然后就捣鼓出了个盗版vue.js 实现的功能有模板渲染，生命周期，数据劫持，双向绑定，添加点击事件等很基础的功能，下面是源码 每天看掘金上的源码理论讲解，什么compile和watcher之类的看麻了，实现一下之后就有很大的感悟 首先在Vue的类中将$el和$data挂载在实例对象上，方便后续的操作 模板的编译思想就是，设置正则匹配，获取根节点后，再去获取根节点的子节点，循环去匹配文本节点，利用字符串的replace方法结合正则表达式，匹配到设置了模板字符串的文本节点和键，再利用键从data中获取相应值去替换文本节点 生命周期简单些，就是传递几个函数，判断类型，如果是函数就执行，顺序不能随便放，执行顺序是固定的，后期需要通过bind改变this指向 这是html内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647copyvye.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; str &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; b &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;modelStr&quot;&gt; &lt;button @click=&quot;changeStr&quot;&gt;change str&lt;/button&gt; &lt;h1&gt;&#123;&#123; modelStr &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;./copyVue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; str:&#x27;hao hello&#x27;, b:&#x27;好嗨欧&#x27;, modelStr:&#x27;v-model关联字符&#x27; &#125;, methods: &#123; changeStr()&#123; this.str = &#x27;我终于更新了&#x27; &#125; &#125;, beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created() &#123; console.log(&#x27;created&#x27;) &#125;, beforeMount() &#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted() &#123; console.log(&#x27;mounted&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是copyVue.js内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112copyVue.jsclass Vue &#123; constructor(options)&#123; if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$options = options this.$data = options.data this.$watchEvent = &#123;&#125; this.proxyData() this.observe() if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; // 劫持数据 此时并未更新视图 proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(val)&#123; this.$data[key] = val &#125; &#125;) &#125; &#125; // 数据被修改但是视图并未更新 observe()&#123; for(let key in this.$data)&#123; let value = this.$data[key] let that = this Object.defineProperty(this.$data,key,&#123; get()&#123; return value &#125;, set(val)&#123; value = val if(that.$watchEvent[key])&#123; that.$watchEvent[key].forEach(item =&gt; &#123; item.update() &#125;) &#125; &#125; &#125;) &#125; &#125; compile(node)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; node.childNodes.forEach(item =&gt; &#123; // 首先需要判断节点类型 if(item.nodeType === 1)&#123; if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.hasAttribute(&#x27;v-model&#x27;))&#123; let vmKey = item.getAttribute(&#x27;v-model&#x27;).trim() if(this.hasOwnProperty(vmKey))&#123; item.value = this[vmKey] &#125; item.addEventListener(&#x27;input&#x27;,(event)=&gt;&#123; this[vmKey] = item.value &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType === 3)&#123; // 使用另外一个变量保存文本节点的内容 let nodeContent = item.textContent item.textContent = nodeContent.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125;class Watch &#123; constructor(vm,key,node,attr)&#123; this.vm = vm this.key = key this.node = node this.attr = attr &#125; update()&#123; this.node[this.attr] = this.vm[this.key] &#125;&#125; loading……","categories":[{"name":"vue框架源码","slug":"vue框架源码","permalink":"https://222cabbage.github.io/categories/vue%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Vue2源码","slug":"Vue2源码","permalink":"https://222cabbage.github.io/tags/Vue2%E6%BA%90%E7%A0%81/"}]},{"title":"vue2知识回顾","slug":"Face2","date":"2022-06-25T17:20:40.000Z","updated":"2022-07-08T13:22:29.582Z","comments":true,"path":"2022/06/26/Face2/","link":"","permalink":"https://222cabbage.github.io/2022/06/26/Face2/","excerpt":"","text":"Vue2小知识回顾以后应该很多项目都会使用上v3了，但是v2也不能忘掉，毕竟学习过，那么现在就来复习一下 1生命周期在vue2的生命周期中，created可以访问到data的数据，访问不到dom根节点el，在mounted中可以同时访问到el和data 使用keepalive组件缓存路由后组件后，生命周期会触发activated 2：keepalivevue自带组件，防止重复构建和请求，提升性能，新的数据可以从activated生命周期中获取 3：v-show和v-ifv-if完全的删除以及创建dom’盒子 v-show是display：none，会造成回流以及重绘问题，不占位 初次加载v-if好，重复显示与隐藏v-show更好 4：v-if和v-for的优先级v2中v-for的优先级比v-if高，v3相反 在源码中体现，genElement函数中 5：ref帮助获 取dom，vue的语法糖，方便快捷获取dom信息 配合nextTick使用 6：nextTick获取更新后的data和dom内容，异步 7：scope原理使样式只在当前页面生效，不会全局影响样式 原理：给节点新增自定义属性data-v-xxxxx，利用css属性选择器添加样式 div[data-v-xxxx] { } 8：样式穿透对于外来第三方的组件想要修改样式 1:scss：父元素 &#x2F;deep&#x2F; 想要修改样式的组件类名 { ​ color:red } 2:stylus：lang&#x3D;”stylus” 父元素 &gt;&gt;&gt; 想要修改样式的组件类名 { ​ color:red } 3:::v-deep 9：父子组件通信 自定义props10：子传父 自定义事件this.$emit(event,data) 11：兄弟eventBus，bus.js import Vue from vue export default new Vue import bus from ‘bus.js’ bus.$emit() bus.$on() 14：computed，watch，methodscomputed对比methods： computed具有缓存，基于响应式的依赖，依赖不变就不会调用，走第一次缓存 methods：无缓存，重复调用 computed对比watch： watch：监听数据或者路由发生改变才可以响应执行，是当前监听数据发生改变才会执行 computed：无需发生改变，如果影响计算属性值的某个属性改变，就会触发，多对一 15：vue设置代理看看vue-ccli官网中的devServer配置，解决开发时的跨域问题 publicPath：‘.&#x2F;’， devServer ：{ ​ proxy：需要代理的地址 } 代理在打包完成后是不生效的 可以去xiaoluxian.cn网站去看看打包完后会发生的一些问题 16：打包路径和路由模式history hash 直观点的区分就是# 打包完后出现的空白页是怎么回事？ 默认打包后引入的js资源等文件是以&#x2F;开头，要修改成.&#x2F; publicPath：‘.&#x2F;’ 后续会出现点击跳转错误问题，是因为路由模式的原因，将history模式改成hash就没事 如果既想要模式是history，又想看到内容 就需要和后端说一下，注意地址的问题，让他做重定向 17：代理和环境变量打包完后代理不生效了 需要设置模式和环境变量 生产模式和开发模式 .env.development .env.production axios封装时判断请求根路径 12345678910111213141516171819202122axios（options）&#123; let baseUrl = &#x27;&#x27; if(process.env.VUE_APP_ENV === &#x27;dev&#x27;)&#123; baseUrl = options.url &#125;else&#123; baseUrl = process.env.VUE_APP_BASE_API + options.url &#125; return axios(&#123; url = baseUrl &#125;)&#125; 18：props和data的优先级在源码的initState 1：props最先 2：之后是methods 3：再然后是data 4：computed 5：watch 19：VueX专门为vue设计的管理状态的工具 有什么属性？ state类似data 12345678import &#123;mapState&#125; from vuexcomputed:&#123; ...mapState([&#x27;name&#x27;,&#x27;age&#x27;])&#125; getters类似computed 123456789101112131415161718getters:&#123; changeStr()&#123; return state.name + state.age &#125;&#125;import &#123; mapGetters &#125; from vuexcomputed:&#123; ...mapGetters([&#x27;changeStr&#x27;])&#125; mutations类似methods 1234import &#123; mapMutations &#125; from vuexmethods:&#123; ...mapMutations([&#x27;changeSome&#x27;])&#125; actions类似异步的methods，提交的是mutaions。而不是直接修改state 123456789actions: &#123; submit(&#123;commit&#125;,state)&#123; &#125;&#125;impot &#123; mapActions &#125; from vuexmethods:&#123; ...mapActions([&#x27;submit&#x27;])&#125; modules吧以上四个属性再细分，模块化仓库更好管理 vuex是单项数据流，单相思 vuex持久化存储 本身不是持久化存储 123456789方式1state:&#123; num:localStorage.getItem(&#x27;num&#x27;) || 1 &#125;,add（）&#123; state.num++ localStorage.setItem(&#x27;num&#x27;,state.num)&#125;方式2 使用插件 自行百度vuex持久化插件 20：vue-router 路由路由模式 hash history 区别： history在跳转无效路由时，会发送一个请求 &#x2F;about&#x2F;id 打包后前端自测需要使用hash，如果使用history会出现空白页 21：SPASPA单页面应用 缺点是SEO优化不好，SEO多页面更好 性能不是特别好，所有页面都牵扯到一个页面，可能会涉及到重绘和重排 22：路由路径传值12345678910111213141516171819显式this.router.push(&#123; path:&#x27;/about&#x27;, query:&#123; a:1 &#125;&#125;)/about?a=1this.$route.query隐式this.router.push(&#123; name:&#x27;About&#x27;, params:&#123; a:1 &#125;&#125;)/aboutthis.$route.params 23：路由导航守卫 具体自行百度全局 路由独享 组件内 使用场景较多的是，在进入页面时，判断有无登陆，无登陆就跳转登录页，有登陆就进行后续操作 24：动态路由使用场景：详情页 &#x2F;detail&#x2F;1 &#x2F;detail&#x2F;2 path：’&#x2F;detail&#x2F;:id’ 25：源码 模板编译12345678910111213141516171819202122232425haovue.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324haovue.jsclass HaoVue &#123; constructor(options)&#123; this.$el = document.querySelector(options.el) this.$data = options.data this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; this.compile(item) &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125; 26：源码 生命周期123456789101112131415161718192021222324252627282930313233343536373839404142haovue.jsclass HaoVue &#123; constructor(options)&#123; console.log(options) // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() console.log(this.$data,this.$el) &#125; this.$data = options.data if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() console.log(this.$data,this.$el) &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() console.log(this.$data,this.$el) &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() console.log(this.$data,this.$el) &#125; this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; this.compile(item) &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637haovue.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125;, beforeCreate()&#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created()&#123; console.log(&#x27;created&#x27;) &#125;, beforeMount()&#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted()&#123; console.log(&#x27;mounted&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 27：源码 添加事件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125;, beforeCreate()&#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created()&#123; console.log(&#x27;created&#x27;) &#125;, beforeMount()&#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted()&#123; console.log(&#x27;mounted&#x27;) &#125;, methods:&#123; btnClick()&#123; alert(this.str + &#x27;按钮点击&#x27;) // 此时无法直接this.str使用 得放到数据劫持中 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class HaoVue &#123; constructor(options)&#123; this.$options = options // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$data = options.data if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)( &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125; &#125; 28：源码 劫持1haovue.html 12345678910111213141516haovue.js this.$data = options.data this.proxyData() proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(value)&#123; this.$data[key] = value &#125; &#125;) // 此时虽然数据被修改，但是视图没修改 &#125; &#125; 29：更新视图12345haovue.html btnClick(e)&#123; this.str = &#x27;一点都不好&#x27; console.log(this) // 此时无法直接this.str使用 得放到数据劫持中 &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111haovue.jsclass HaoVue &#123; constructor(options)&#123; this.$options = options this.$watchEvent = &#123;&#125; // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$data = options.data this.proxyData() this.observe() if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; // 将data中的数据挂载在原型上 使得页面通过this.xxx的方式能够访问到 // 并且进行数据劫持 当data中的数据更新 原型上的数据也要更新 双向绑定 劫持 proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(value)&#123; this.$data[key] = value &#125; &#125;) &#125; &#125; // 此时虽然数据被修改，但是视图没修改 observe()&#123; for(let key in this.$data)&#123; let value = this.$data[key] let that = this Object.defineProperty(this.$data,key,&#123; get()&#123; return value &#125;, set(val)&#123; value = val if(that.$watchEvent[key])&#123; that.$watchEvent[key].forEach(item=&gt;&#123; item.update() &#125;) &#125; &#125; &#125;) &#125; &#125; // 编译 compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125;class Watch &#123; constructor(vm,key,node,attr)&#123; // 对象 this.vm = vm // 属性名称 this.key = key // 节点 this.node = node // 改变文本节点的内容字符串 this.attr = attr &#125; // 执行改变update操作 update()&#123; this.node[this.attr] = this.vm[this.key] &#125;&#125; 30：diff算法算法，提升性能，vue和react都有使用和改良，与dom有关系，虚拟dom，数据，将dom数据化 不断的修改dom是十分耗费性能的，因此将dom转换为数据 vue和react中的diff算法主要借鉴了snabbdom和virtual-dom 123456789101112131415161718192021222324搭建snabbdom环境npm init -ynpm install webpack@5 webpack-cli@3 webpack-dev-server@3 -Snpm install snabbdom -S创建一个webpack.config.js配置module.exports = &#123; entry:&#123; index:&quot;./src/index.js&quot; &#125;, output:&#123; path:__dirname + &quot;/public&quot;, filename:&quot;./js/[name].js&quot; &#125;, devServer:&#123; contentBase:&quot;./public&quot;, inline:true &#125;&#125;修改package.json配置 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot; &#125;,npm run dev 一个简单的snabbdom环境就搭建好了 31：v-model首选通过defineProperty劫持数据发生的改变，如果数据改变了就触发set的update，进行更新节点内容，从而实现双向绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; // 判断元素节点是否添加了v-model if(item.hasAttribute(&#x27;v-model&#x27;))&#123; let vmKey = item.getAttribute(&#x27;v-model&#x27;).trim() if(this.hasOwnProperty(vmKey))&#123; item.value = this[vmKey] &#125; item.addEventListener(&#x27;input&#x27;,(event)=&gt;&#123; this[vmKey] = item.value &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125; 32：snabbdom虚拟节点 12345678&#123; children:undefined, data:&#123;&#125;, elm:h1, key:undefined, sel:&#x27;h1&#x27;, text:&#x27;你好h1&#x27;&#125; 真实节点 1&lt;h1&gt;你好h1&lt;/h1&gt; 新老节点替换规则 如果新老节点不是同一个节点名称，那么久脑力删除旧的，创建插入新的节点 判断是否是同一节点是通过key判断的 添加key能够提升性能 key是唯一标识 只能同级比较，跨层直接暴力删除 如果是相同节点 情况更复杂，两种 新节点没有children，证明是文本节点，直接覆盖 新节点有children，分为两种 新的有children，旧的也有children，diff核心，永远都是从旧节点第一个child开始匹配 旧前，新前 旧节点和新节点的第一个相等，那么旧节点和新节点指针相加 旧后，新后 旧节点和新节点的最后一个相等，那么旧节点和新节点指针都– 旧前，新后 旧节点第一个和新节点的最后一个相等，那么旧节点指针加加和新节点指针– 旧后，新前 旧节点最后一个一个和新节点的最后一个相等，那么旧节点指针加加和新节点指针– 以上都不满足 创建和删除 新的有children，旧的没有，创建元素添加，吧旧的内容添加创建新的插入 33：手写diff算法，生成虚拟dom1234567891011121314151617181920212223242526272829303132333435h.jsimport vnode from &#x27;./vnode&#x27;export default function(sel,data,params)&#123; if(typeof params === &#x27;string&#x27;)&#123; // h的第三个参数是字符串类型 意味着他没有子元素 return vnode(sel,data,undefined,params,undefined) &#125;else if(Array.isArray(params))&#123; let child = [] for(let item of params)&#123; child.push(item) &#125; return vnode(sel,data,child,undefined,undefined) &#125;&#125;vnode.jsexport default function(sel,data,children,text,ele)&#123; return &#123; sel, data, children, text, ele &#125;&#125;index.jsimport h from &#x27;./dom/h&#x27;// let vnode = h(&#x27;div&#x27;,&#123;&#125;,&#x27;hello&#x27;)let vnode = h(&#x27;div&#x27;,&#123;&#125;,[ h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni&#x27;), h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni2&#x27;), h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni3&#x27;),])console.log(vnode) 34：手写diff算法，patch不是同一节点1 35：手写diff算法，相同节点有无children 上1 36：手写diff算法，相同节点有无children 中37：手写diff算法，相同节点有无children 下38：MVVM出现的原因： web1.0时代，前后端代码都在一起 前后端代码都是一个人开发，技术没有侧重点，责任不够细分 项目不好维护 mvc都是后端先出的，htmlcssjs页面没有，后端无法工作 web2.0时代 ajax出现了，前端后端数据分离 解决问题，后端不用等前端页面弄完，后端做后端，前端做前端， 单页面，html和css，js都在一个页面，单个页面也会出现不好维护的情况，但是比1.0好 出现前端mvvm框架，前端出现过mvc框架，但是被mvvm干掉了 解决问题，吧大页面进行拆分，单个组件进行维护 什么是mvvm model，view，view model的缩写 view，视图，页面展现的内容 model，数据模型，数据层，data view model 视图模型层 就是vue源码将视图和数据结合的实现","categories":[{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"来看看mysql","slug":"mysql1","date":"2022-06-12T15:55:45.000Z","updated":"2022-10-31T15:30:48.720Z","comments":true,"path":"2022/06/12/mysql1/","link":"","permalink":"https://222cabbage.github.io/2022/06/12/mysql1/","excerpt":"","text":"数据库mysql的学习关系数据库和非关系型数据库关系型数据表会创建很多个二维数据表，表之间相互关联，一对一，一对多，多对多，使用sql语句查询，支持事务，对数据的访问更加安全 非关系型数据库 NoSQL 相对简单一些，存储数据更加自由，性能更高，不支持事务 目前大部分公司在进行后端开发时用的都是关系型数据库，比较·常用的用到非关系型数据库的场景是爬取大量数据 SQL语句mysql –version 查看数据库版本 终端连接 mysql -uroot -p密码 mysql -uroot -phaoge666 进入mysql模式， 输入show databases;（标点符号很重要）可以查看所有数据库 不规范 创建数据库-表 create database 名字； 查看当前使用的数据库 select database()； use haotest； 查看当前使用数据库中的表 show tables； 建表 12345create table 名字（name varchar(10), //可变字符类型age int, //height double) // 插入数据 insert into users（name,age,height） values (‘hao’,22,165); 命令行敲太麻烦 使用GUI几种GUI工具推荐 Navicat后续收费，SQLYog免费，TablePlus免费限制较多 从b站上找到好心的up猪弄来了navicat的绿色版本，根据up猪的指导完成破解 新建连接 SQL语句关键字大写 CREATE SHOW TABLE DATABASE 。。。。 一条语句结尾需要; 遇到关键字表明字段昵称 可以使用&#96;&#96;包裹CREATE TABLE moment 语句分类 DDL语句，数据定义语言，通过DDL语句对数据库或者表进行创建删除修改 DML，数据操作语言，对表进行添加删除修改 DQL，数据查询语言，可以从数据库中查询记录 DCL，数据控制语言，对数据库，表的权限访问进行控制 CREATE DATABASES IF NOT EXISTS haoge 删除数据库 DROP database IF EXISTS haotest; SHOW TABLES CREATE TABLE IF NOT EXISTS students () MYSQL的数据类型数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT 浮点数：FLOAT，DOUBLE（float是4个字节，double是八个）单精度浮点数，双精度浮点数 准确数字类型：DECIMAL，NUMERIC（decimal是numeric的实现形式） 日期类型：YEAR：只有年份，date：只有年份和月日，没有时间，DATETIME：既有年月日也有时分秒 TIMESTAMP和DATETIME类似，但是时间范围是UTC的时间范围，都可以表示微秒，如果想自由设置时间就选择DATETIME 都有各自支持的时间范围 字符串类型： CHAR，创建时为固定长度，一般是0-255之间，在被查询时，会删掉后面的空格，一个字节 VARCHAR是可变长度的字符串类型，长度可以是0-65535的任意值。在被查询时，不会删掉后面的空格 BINARY和VARBINARY是存储二进制的字符串 BLOB是用于存储比较大的二进制类型 TEXT是用于存储大的字符串类型 表约束主键：PRIMARY KEY 一张表中为了记录每一条记录的唯一性，必须有一个字段永远不重复，并且不会为空，这就是主键，主键是表中唯一的索引，必须是NOT NULL，不主动设置，数据库也会自动设置成NOT NULL 主键也可以是多列索引，一般称为联合主键， 开发中主键和业务是无关的，尽量不要使用业务字段作为主键 唯一：UNIQUE 有些 字段是唯一的，不会重复的，身份证等，用UNIQUE约束，使用后该字段必须不相等，允许列值包含多个null 不能为空：NOT NULL不能为空 默认：:DEFAULT 自动递增：AUTO_INCREMENT，id 外键约束：多表关系适用 创建一个完整的表CREATE TABLE IF NOT EXISTS students ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20), age INT DEFAULT 0, phoneNum VARCHAR(20) UNIQUE DEFAULT ‘’, createTime TIMESTAMP); 修改创建完后的表 修改表名ALTER TABLE students RENAME TO haos; 添加新的列ALTER TABLE haos ADD updateTime TIMESTAMP; 修改字段名称ALTER TABLE haos CHANGE phoneNUm tel VARCHAR(20); 修改字段类型ALTER TABLE haos MODIFY name VARCHAR(30); 删除一个字段ALTER TABLE haos DROP tel; 根据一个表结构创建另一个表CREATE TABLE user2 LIKE haos; 根据其他表的所有内容创建CREATE TABLE user3 (SELECT * FROM user2); 只复制内容，其他东西不复制 DML语句 对数据库进行增删改插入 INSERT INTO users VLUES（100,’hoage’）； INSERT INTO users （name，tel） VALUES (‘haoge’,’192xxxxx’) 删除 删除所有数据 DELETE FORM users DELETE FROM users WHERE id &#x3D; 10； 更新数据 此处没有指定哪一个数据修改，会将所有数据修改 UPDATE users SET name &#x3D; ‘zhangsan’，age &#x3D; 22； 更新符合条件的数据 UPDATE users SET name &#x3D; ‘zhangsan’，age &#x3D; 22 WHERE id &#x3D; 22； DQL语句 数据查询语言SELECT 从一个或多个表中国检索选中的行，记录 查询所有字段 SELECT * FROM users; 查询指定字段 SELECT title，price FROM users; 取别名 SELECT title as phonetitle，price FROM users; where条件逻辑运算语句SELECT * FROM users where price &gt; 900 AND&#x2F;&amp;&amp; price &lt; 1000 SELECT * FROM users where price &gt; 900 OR&#x2F;|| price &lt; 1000 将某些值设定为NULL UPDATE products SET url &#x3D; NULL where id； 查询某一个值为null SELECT * FROM users WHERE url IS NULL SELECT * FROM users WHERE url IS NOT NULL 模糊查询搭配LIKE和%与_搭配 %表示匹配任意个字符串，_表示匹配一个的任意字符 SELECT * FROM products WHERE title LIKE ‘%华为%’;只要有华为就可以 SELECT * FROM products WHERE title LIKE ‘_华为%’;最前面的一个字符是任意的，后面接着华为 IN表示取多个值中的其中一个即可 SELECT * FROM products WHERE brand &#x3D; ‘华为’ || brand &#x3D; ‘小米’ 可是如果条件多的话就brand &#x3D; xxx || brand &#x3D; xxx || brand &#x3D; xxx; SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) 对查询结果进行排序 SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) ORDER BY price ASC;根据价格升序 SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) ORDER BY price ASC ，score DESC;根据价格升序后再对比评分降序 分页查询SELECT * FROM users LIMIT 20 OFFSET 0； SELECT * FROM users LIMIT OFFSET LIMIT； SELECT * FROM users LIMIT 0 20； 创建多表聚合函数常用的聚合函数 计算所有商品总价值 SELECT SUM(price) as totalPrice FROM products 求所有华为手机价格的总和 SELECT SUM(price) FROM products WHERE brand &#x3D; ‘华为’， 计算华为手机平均价格 SELECT AVG(price) FROM products WHERE brand &#x3D; ‘华为’， 计算价格最大值 SELECT MAX(price) FROM products， 计算价格最小值 SELECT MIN(price) FROM products， 求华为手机个数 SELECT COUNT(*) FROM products brand &#x3D; ‘华为， 求苹果手机有url的个数 SELECT COUNT(url) FROM products brand &#x3D; ‘苹果， 去除相同价格 SELECT COUNT(DISTINCT price) FROM products， GROUP BY 分组根据品牌进行分组 SELECT brand, AVG(price),COUNT(*),AVG(score) FROM products GROUP BY brand； HAVING根据查询出来的结果筛选出》2000的手机 SELECT brand, AVG(price) as toal,COUNT(*),AVG(score) FROM products GROUP BY brand HAVING total &gt; 2000； 求评分大于7.5的手机的平均价格 SELECT AVG(price) FROM products WHERE score &gt; 7.5 按照品牌分类以后求评分大于7.5的手机的平均价格 SELECT * FROM products WHERE score &gt; 7.5 GROUP BY brand；44 创建多张表CREATE TABLE IF NOT EXISTS brand（ ​ id INT PRIMARY KEY AUTO INCREMENT, ​ name VARCHAR(20) NOT NULL, ​ webSite VARCHAR(100), ​ phoneRank INT ） INSERT INTO brand (name,website,phoneRank) VALUES (‘华为’,’www.baidu.com&#39;,20) ALTER TABLE products add brandid INT；通过新增加的brandid去查询另一张表的数据 但是该brandid必须要限制 外键限制foreign key create table products ( ​ foreign key(brandid) reference brand(id) ) 修改brandid为外键 alter table products ADD FOREIGN KEY（brandid） REFERENCES brand(id) 外键内置两个action，一个是删除时，一个是更新时 不能随意更改外键及其相关值 RESTRICT默认属性，当更新或者删除某个值时，会检查该值是否有关联的外键记录，有的话会报错，不允许更新或删除 CASCADE:关联联动，当更新或者删除每个值时，检查是否有外键记录，如果是更新，那么则更新对应记录如果是删除，则删除对应记录 SET NULL当更新或者删除值时，会检查是否有该值的外键记录，有的话则设置为NULL 将RESTRICT修改为CASCADE 1：获取目前外键名称 SHOW CREATE TABLE products 2：根据名称将外键删掉 ALTER TABLE products DROP FOREIGN KEY products_ibfk_1; 3：重新添加外键约束 ALTER TABLE products ADD FOREIGN KEY （brandid）REFERENCES brand(id) ON UPDATE CASCADE ON DELETE RESTRICT &#x2F;&#x2F; 删除时是非常危险的，不能直接用cascade，建议使用默认值 多表查询多连接sql join 左连接 ：LEFT JOIN 右连接 RIGHT JOIN 内连接 INNER JOIN 全连接 FULL OUTER JOIN 注：mysql不支持","categories":[{"name":"数据库mysql的学习","slug":"数据库mysql的学习","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://222cabbage.github.io/tags/mysql/"}]},{"title":"websocket学习","slug":"websocket1","date":"2022-06-12T15:40:18.000Z","updated":"2022-06-12T15:52:22.467Z","comments":true,"path":"2022/06/12/websocket1/","link":"","permalink":"https://222cabbage.github.io/2022/06/12/websocket1/","excerpt":"","text":"websocket的学习公司自研了一个项目，需要使用到即时通讯，虽然任务最后没有落实到我手上，但是我还是去看了一下下，学会了一些基本的操作 websocket涉及到一些计算机网络相关的知识，此处省略一万字…… npm install nodejs-websocket 1234567891011121314151617181920212223242526272829// node服务端代码结构var ws = require(&quot;nodejs-websocket&quot;)// 创建链接通道数组const conList = []var server = ws.createServer(function (conn) &#123; console.log(&#x27;conn&#x27;,conn) // 将连接通道添加到数组中保存 conList.push(conn) console.log(&quot;创建了一个websocket服务器&quot;,&#x27;有&#x27; + conList.length + &#x27;人连接上了&#x27;) conn.on(&quot;text&quot;, function (str) &#123; console.log(&quot;服务器接收到的数据是&quot;+str) // 循环遍历发送数据 for(var i = 0 ; i &lt; conList.length; i++)&#123; conList[i].sendText(str.toUpperCase()+&quot;!!!&quot;) &#125; &#125;) conn.on(&quot;close&quot;, function (code, reason) &#123; console.log(&quot;websocket服务器关闭&quot;,&#x27;原因是&#x27; + reason) // 如果某一个连接关闭 那么需要将其conList中删除 conList.splice(conList.indexOf(conn),1) console.log(&#x27;当前连接数量&#x27; + conList.length) &#125;) conn.on(&#x27;error&#x27;,function(code,reason)&#123; console.log(&#x27;异常事件&#x27;,code,&#x27;原因是&#x27; + reason) &#125;)&#125;).listen(8001,()=&gt;&#123; console.log(&#x27;running&#x27;)&#125;)// nodemon app.js在8001端口启动一个websocket的服务 html结构 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style lang=&quot;&quot;&gt; div &#123; width: 200px; height: 200px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button&gt;发送&lt;/button&gt; &lt;ul&gt; 消息列表： &lt;/ul&gt; &lt;script&gt; const ws = new WebSocket(&#x27;ws://localhost:8001&#x27;) const btn = document.querySelector(&#x27;button&#x27;) const ipt = document.querySelector(&#x27;input&#x27;) const box = document.querySelector(&#x27;ul&#x27;) // ws.addEventListener(&#x27;open&#x27;,()=&gt;&#123; // &#125;) btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; let value = ipt.value ws.send(value) &#125;) ws.addEventListener(&#x27;message&#x27;,(e)=&gt;&#123; console.log(&#x27;客户端接收到的消息是&#x27;,e.data) let li = document.createElement(&#x27;li&#x27;) li.innerText = e.data box.appendChild(li) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一个小的test就完成了… 后面想弄一个基于uniapp的websocket小程序，或许是五百年以后……","categories":[{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/tags/websocket/"}]},{"title":"http内置模块，Express和Koa","slug":"Node6","date":"2022-06-03T17:47:14.000Z","updated":"2022-09-22T18:20:52.682Z","comments":true,"path":"2022/06/04/Node6/","link":"","permalink":"https://222cabbage.github.io/2022/06/04/Node6/","excerpt":"","text":"http内置模块，Node框架Express和Koahttp模块1234567891011121314151617181920212223242526const http = require(&#x27;http&#x27;);// 创建一个web服务器const server = http.createServer((req, res) =&gt; &#123; res.end(&quot;Hello Server&quot;);&#125;);// 启动服务器,并且制定端口号和主机server.listen(8888, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;);如果没有输入端口号，可以通过server.address().port获取server.listen(() =&gt; &#123; console.log(&quot;服务器启动成功~&quot;); console.log(server.address().port)&#125;);listen函数有三个参数端口port，可以不穿，系统默认分配主机host，通常是localhost，ip127.0.0.1，或者0.0.0.0，默认是0.0.0.0localhost本质上是一个域名会被解析成127.0.0.1127.0.0.1是回环地址，自己主机发出去的包自己解析，在应用层 =&gt; 传输层 =&gt; 网络层 =&gt; 链路层 =&gt; 物理层在网络层就会被获取，不会经过链路层是物理层0.0.0.0监听所有IP地址，再根据端口找到不同的应用程序 req1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253request包含请求路径，方法和头等const server = http.createServer((req, res) =&gt; &#123; console.log(requrl) console.log(req.ethod) console.log(req.eaders) res.end(&quot;Hello Server&quot;);&#125;);urlconst server = http.createServer((req, res) =&gt; &#123; if(req.url== &#x27;/login&#x27;) res.end(&quot;请登录&quot;) &#125;else if(req.url==&#x27;/register&#x27;)&#123; res.end(&quot;请注册&quot;) &#125;&#125;);如果访问地址携带参数，利用url模块和qs模块，明文传输方式const url = require(&#x27;url&#x27;）const qs = require(&#x27;querystring&#x27;); const &#123; pathname, query &#125; = url.parse(req.url); if (pathname === &#x27;/login&#x27;) &#123; console.log(qs.parse(query)); const &#123; username, password &#125; = qs.parse(query); console.log(username, password); res.end(&quot;请求结果~&quot;); &#125;method拿到通过post请求发送的json数据，不在地址栏const server = http.createServer((req, res) =&gt; &#123; console.log(req.method) if(req.methdos == &#x27;POST&#x27;)&#123; //获取body数据 req.setEncoding(&#x27;utf-8&#x27;) //设置数据编码 如果是音频和其他文件就是其他编码 req.on(&#x27;data&#x27;,(data)=&gt;&#123; console.log(data.toString()) //字符串类型 &#123;username:&quot;&#x27;,age:&quot;&#x27;&#125; 转换成js对象 const &#123; username, age &#125; = JSON.parse(data.toString()) &#125;) &#125;&#125;);headersconsole.log(req.headers)contenttype：数据类型content-length：文件长度connection：keep-alive保持连接accept-encoding：告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码。对应.gz文件accept：告知服务器科技接收的文件格式user-agent：客户端相关信息 res1234567891011121314151617181920212223242526responseconst server = http.createServer((req, res) =&gt; &#123; 1：res.end(&quot;响应结果&quot;) 2：res.write(&quot;响应结果&quot;) res.end() &#125;);响应状态码1：需要后续操作2：OK，成功3：重定向4：客户端5：服务端状态码设置方式res.statusCode = 404res.writeHead(404,&#123; 可以传入header相关的事情&#125;)设置头方式1：res.setHeader(&quot;content-type&quot;, &quot;text/plain&quot;)2：res.writeHead(200, &#123; &quot;content-type&quot;:&quot;text/plain&quot;&#125;) http发送网络请求axios在前端使用时，基于xhr，在node端使用时是基于http模块 12345678910111213141516171819202122const http = require(&#x27;http&#x27;)http.get(&#x27;...&#x27;,(res)=&gt;&#123; res.on(&#x27;data&#x27;,(data)+&gt;&#123; console.log(data) //结果 &#125;)&#125;)发送postconst req = http.request(&#123; method:&#x27;POST&#x27;, host:&#x27;localhost&#x27;, port:8888&#125;,(res)=&gt;&#123; res.on(&#x27;data&#x27;,(data)=&gt;&#123; console.log(&#x27;结果&#x27;) &#125;) res.on(&#x27;end&#x27;,()=&gt;&#123; console.log(&#x27;获取到了所有结果&#x27;) &#125;)&#125;)req.end() //必须，否则请求停滞 http方式原生的文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const qs = require(&#x27;querystring&#x27;);const server = http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/upload&#x27;) &#123; if (req.method === &#x27;POST&#x27;) &#123; //必须，图片编码必须设置为binary req.setEncoding(&#x27;binary&#x27;); let body = &#x27;&#x27;; const totalBoundary = req.headers[&#x27;content-type&#x27;].split(&#x27;;&#x27;)[1]; const boundary = totalBoundary.split(&#x27;=&#x27;)[1]; req.on(&#x27;data&#x27;, (data) =&gt; &#123; body += data; &#125;); req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(body); // 处理body // 1.获取image/png的位置 const payload = qs.parse(body, &quot;\\r\\n&quot;, &quot;: &quot;); const type = payload[&quot;Content-Type&quot;]; // 2.开始在image/png的位置进行截取 const typeIndex = body.indexOf(type); const typeLength = type.length; let imageData = body.substring(typeIndex + typeLength); // 3.将中间的两个空格去掉 imageData = imageData.replace(/^\\s\\s*/, &#x27;&#x27;); // 4.将最后的boundary去掉 imageData = imageData.substring(0, imageData.indexOf(`--$&#123;boundary&#125;--`)); fs.writeFile(&#x27;./foo.png&#x27;, imageData, &#x27;binary&#x27;, (err) =&gt; &#123; res.end(&quot;文件上传成功~&quot;); &#125;) &#125;) &#125; &#125;&#125;);server.listen(8000, () =&gt; &#123; console.log(&quot;文件上传服务器开启成功~&quot;);&#125;) Express基本使用123456789101112131415161718192021222324//安装方式 1 脚手架安装npm install express-generator -gexpres demonpm installnode bin/www// 默认启动是loaclhost:3000// 2自己从0实现 npm install express// 引入const express = require(&#x27;express&#x27;);// 返回appconst app = express()//监听请求路径app.get(&#x27;/&#x27;,(req,res,next)=&gt;&#123; res.end(&#x27;hello get&#x27;)&#125;)app.post(&#x27;/&#x27;,(req,res,next)=&gt;&#123; res.end(&#x27;hello post&#x27;)&#125;)app.listen(5000,()=&gt;&#123; console.log(&#x27;开启&#x27;)&#125;) express的中间件，中间件就是回调函数，接受req，res，next，next是执行下一个中间件的方法，express本质上是中间件的调用 中间件中可以执行任何代码，更改请求和响应对象，结束请求，响应周期，返回数据，调用栈中的下一个中间件 如果没有res.end就需要next传递给下一个中间件，否则请求会被挂起，不会结束 express提供了两种方式将中间件应用与程序中，app&#x2F;router.use和app&#x2F;router.methods 可以是app，也可以是router，methods是指常用的请求方式app.get或者app.post 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768中间件类型1//最普通的中间件app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第一个普通中间件&#x27;)&#125;)只会执行一个中间件app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第一个普通中间件&#x27;) res.end() // 想要让第二个中间件执行得 next()&#125;)app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第二个普通中间件&#x27;) res.end() // 报错 不能在end之后再end，end只能有一个&#125;)中间件类型2//path匹配中间件app.use(path,callback)app.use(&#x27;/home&#x27;,(req,res,next)=&gt;&#123; console.log(&#x27;匹配到了/home&#x27;) res.end(&#x27;end&#x27;)&#125;如果有相同的path匹配中间件，永远只会调用第一个中间件，除非使用next中间件类型3//path和method匹配中间件app.get(&#x27;/home&#x27;,(req.res,next)=&gt;&#123; &#125;)中间件类型4//注册多个中间件app.get(&#x27;/home&#x27;,(req,res,next)=&gt;&#123;&#125;,(req,res,next)=&gt;&#123;&#125;,(req,res,next)=&gt;&#123;&#125;)//使用express解析req.body很轻松 解析jsonapp.use(express.json())// true是使用qs解析，false那么就是使用node中的queryString进行解析 解析urlencodedapp.use(express.urlencoded(&#123;extended:true&#125;))// 解析formdatanpm install multerconst upload = require(&#x27;multer&#x27;)app.use(multer.any())// 上穿文件 设置上传路径const multer = multer(&#123; dest:&#x27;./uploads/&#x27; // 上传文件保存位置,&#125;)const path = require(&#x27;path&#x27;const storage = muliter.diskStorge(&#123; destintion: (req,res,cb)=&gt;&#123; cb(null,&#x27;./uploads/&#x27;) &#125;//目的地， filename: (req,res,cb)=&gt;&#123; cb(null, Date.now() + path.extname(file.originalname)) &#125;&#125;)upload.single 上传单个文件 upload.array 上传多个文件 可以传递一个key值表示具体处理哪个数据app.post(&#x27;/upload&#x27;,upload.single(&#x27;&#x27;) ,(req,res,next)=&gt;&#123; console.log(req.files) res.end(&#x27;上传成功&#x27;)&#125;)// 默认没有后缀名 中间件用法json解析express内置一些request解析的中间件 ，当客户端发送请求post请求时，会把数据放到req.body中 客户端可以通过json也可以通过form表单的方式传递 123456789101112131415161718192021222324252627282930313233343536373839404142post 发送username和age自己写的// app.use((req, res, next) =&gt; &#123;// if (req.headers[&quot;content-type&quot;] === &#x27;application/json&#x27;) &#123;// req.on(&#x27;data&#x27;, (data) =&gt; &#123;// const info = JSON.parse(data.toString());// req.body = info;// &#125;) // req.on(&#x27;end&#x27;, () =&gt; &#123;// next();// &#125;)// &#125; else &#123;// next();// &#125;// &#125;)使用express// 使用express提供给我们的body解析// body-parser: express3.x 内置express框架// body-parser: express4.x 被分离出去// body-parser类似功能: express4.16.x 内置成函数app.use(express.json()); //传送数据为json格式时 application/json// extended// true: 那么对urlencoded进行解析时, 它使用的是第三方库: qs// false: 那么对urlencoded进行解析时, 它使用的是Node内置模块: querystringapp.use(express.urlencoded(&#123;extended: true&#125;));//传送数据解析application/x-www-form-urlencoded后续可直接通过打印req.body方式获取传送数据app.post(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; console.log(req.body); res.end(&quot;Coderwhy, Welcome Back~&quot;);&#125;);app.post(&#x27;/products&#x27;, (req, res, next) =&gt; &#123; console.log(req.body); res.end(&quot;Upload Product Info Success~&quot;);&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;express初体验服务器启动成功~&quot;);&#125;); formdata解析12345678910111213141516171819202122npm install multerconst express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const app = express();app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;));const upload = multer();app.use(upload.any());app.post(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; console.log(req.body); res.end(&quot;用户登录成功~&quot;)&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;form-data解析服务器启动成功~&quot;)&#125;); formdata上传文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const app = express();app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;));//自定义的文件信息const storage = multer.diskStorage(&#123; destination: (req, file, cb) =&gt; &#123; cb(null, &#x27;./uploads/&#x27;); &#125;, filename: (req, file, cb) =&gt; &#123; cb(null, Date.now() + path.extname(file.originalname)); &#125;&#125;)const upload = multer(&#123; // dest: &#x27;./uploads/&#x27; //文件存储路径 storage //自定义文件存储信息&#125;);app.post(&#x27;/login&#x27;, upload.any(), (req, res, next) =&gt; &#123; console.log(req.body); res.end(&quot;用户登录成功~&quot;)&#125;);上传单个文件app.post(&#x27;/upload&#x27;, upload.single(&#x27;file&#x27;), (req, res, next) =&gt; &#123; console.log(req.files); res.end(&quot;文件上传成功~&quot;);&#125;);上传多个文件app.post(&#x27;/upload&#x27;, upload.array(&#x27;file&#x27;), (req, res, next) =&gt; &#123; console.log(req.files); res.end(&quot;文件上传成功~&quot;);&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;form-data解析服务器启动成功~&quot;)&#125;); 保存日志信息使用express开发的第三方中间件，morgan，需要单独安装 123456789101112131415161718192021const fs = require(&#x27;fs&#x27;);const express = require(&#x27;express&#x27;);const morgan = require(&#x27;morgan&#x27;);const app = express();const writerStream = fs.createWriteStream(&#x27;./logs/access.log&#x27;, &#123; flags: &quot;a+&quot;&#125;)//combined是保存的日志格式，app.use(morgan(&quot;combined&quot;, &#123;stream: writerStream&#125;));app.get(&#x27;/home&#x27;, (req, res, next) =&gt; &#123; res.end(&quot;Hello World&quot;);&#125;)app.listen(8000, () =&gt; &#123; console.log(&quot;express初体验服务器启动成功~&quot;);&#125;); request参数解析 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/products/:id/:name&#x27;, (req, res, next) =&gt; &#123; console.log(req.params); // req.params =&gt; 在数据库中查询真实的商品数据 res.end(&quot;商品的详情数据~&quot;);&#125;)app.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; console.log(req.query); res.end(&quot;用户登录成功~&quot;);&#125;)app.listen(8000, () =&gt; &#123; console.log(&quot;普通中间件服务器启动成功~&quot;);&#125;); response响应结果解析1234567891011121314151617181920212223242526272829303132333435363738const express = require(&#x27;express&#x27;);const router = require(&#x27;./routers/users&#x27;);const app = express();app.get(&#x27;/products/:id/:name&#x27;, (req, res, next) =&gt; &#123; console.log(req.params); // req.params =&gt; 在数据库中查询真实的商品数据 res.end(&quot;商品的详情数据~&quot;);&#125;)app.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; console.log(req.query); // 设置响应吗 res.status(204); // res.type(&quot;application/json&quot;); // res.end(JSON.stringify(&#123;name: &quot;why&quot;, age: 18&#125;)); // res.json(&#123;name: &quot;why&quot;, age: 18&#125;) // 设置内容 res.json([&quot;abc&quot;, &quot;cba&quot;, &quot;abc&quot;]);&#125;);/** * 举个例子: * 请求所有的用户信息: get /users * 请求所有的某个用户信息: get /users/:id * 请求所有的某个用户信息: post /users body &#123;username: passwod:&#125; * 请求所有的某个用户信息: delete /users/:id * 请求所有的某个用户信息: patch /users/:id &#123;nickname: &#125; */app.listen(8000, () =&gt; &#123; console.log(&quot;普通中间件服务器启动成功~&quot;);&#125;); 路由的使用如果将所有代码放在app中，那么app会越来越复杂，可以使用express.Router创建一个路由处理程序，一个路由实例拥有完整的中间件和路由系统，因此也被称为迷你应用程序 1234567891011121314151617181920212223242526272829303132333435363738394041const express = require(&#x27;express&#x27;);const userRouter = require(&#x27;./routers/users&#x27;);const productRouter = require(&#x27;./routers/products&#x27;);const app = express();app.use(&quot;/users&quot;, userRouter);app.use(&quot;/products&quot;, productRouter);app.listen(8000, () =&gt; &#123; console.log(&quot;路由服务器启动成功~&quot;);&#125;);routers/users/** * 举个例子: * 请求所有的用户信息: get /users * 请求所有的某个用户信息: get /users/:id * 请求所有的某个用户信息: post /users body &#123;username: passwod:&#125; * 请求所有的某个用户信息: delete /users/:id * 请求所有的某个用户信息: patch /users/:id &#123;nickname: &#125; */const express = require(&#x27;express&#x27;);const router = express.Router();router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; res.json([&quot;why&quot;, &quot;kobe&quot;, &quot;lilei&quot;]);&#125;);router.get(&#x27;/:id&#x27;, (req, res, next) =&gt; &#123; res.json(`$&#123;req.params.id&#125;用户的信息`);&#125;);router.post(&#x27;/&#x27;, (req, res, next) =&gt; &#123; res.json(&quot;create user success~&quot;);&#125;);module.exports = router; 静态服务器express提供了部署静态资源的方法 12345678910const express = require(&#x27;express&#x27;);const app = express();app.use(express.static(&#x27;./build&#x27;)); //.build中是打包后的文件 npm run buildapp.listen(8000, () =&gt; &#123; console.log(&quot;路由服务器启动成功~&quot;);&#125;); express的错误处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const express = require(&#x27;express&#x27;);const app = express();const USERNAME_DOES_NOT_EXISTS = &quot;USERNAME_DOES_NOT_EXISTS&quot;;const USERNAME_ALREADY_EXISTS = &quot;USERNAME_ALREADY_EXISTS&quot;;app.post(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; // 加入在数据中查询用户名时, 发现不存在 const isLogin = false; if (isLogin) &#123; res.json(&quot;user login success~&quot;); &#125; else &#123; // res.type(400); // res.json(&quot;username does not exists~&quot;) next(new Error(USERNAME_DOES_NOT_EXISTS)); &#125;&#125;)app.post(&#x27;/register&#x27;, (req, res, next) =&gt; &#123; // 加入在数据中查询用户名时, 发现不存在 const isExists = true; if (!isExists) &#123; res.json(&quot;user register success~&quot;); &#125; else &#123; // res.type(400); // res.json(&quot;username already exists~&quot;) next(new Error(USERNAME_ALREADY_EXISTS)); &#125;&#125;);app.use((err, req, res, next) =&gt; &#123; let status = 400; let message = &quot;&quot;; console.log(err.message); switch(err.message) &#123; case USERNAME_DOES_NOT_EXISTS: message = &quot;username does not exists~&quot;; break; case USERNAME_ALREADY_EXISTS: message = &quot;USERNAME_ALREADY_EXISTS~&quot; break; default: message = &quot;NOT FOUND~&quot; &#125; res.status(status); res.json(&#123; errCode: status, errMessage: message &#125;)&#125;)app.listen(8000, () =&gt; &#123; console.log(&quot;路由服务器启动成功~&quot;);&#125;); 更多细节察看expressjs.com.cn 部分原理调用express创建的是什么 ap.listen如何结合原生启动服务器 listen在createApplication中表面上看不出来，实际上在mixin(app。proto，false)中 调用了原生的http创建服务器启动监听 loading…… app.use发生了什么 用户发送网络请求如何执行中间件回调 next为什么会执行下一个中间件 Koakoa自称是node.js的下一代框架，koa是和express同一个团队开发的框架 koa旨在为web应用程序和api提供更小，更丰富和强大的能力 相对于express具有更强大的异步处理能力 koa的核心代码只有一千多行，很清凉 我们可以根据需要考虑安装中间件 123456789101112const Koa = require(&#x27;koa&#x27;);const app = new Koa();//ctx = context 上下文对象 包含request和responseapp.use((ctx, next) =&gt; &#123; ctx.response.body = &quot;Hello World&quot;;&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); 注册中间件koa并没有提供methods，path和连续注册的方式注册中间件 只能通过app.use(()&#x3D;&gt;{}) 123456789101112131415161718192021222324252627const Koa = require(&#x27;koa&#x27;);const app = new Koa();// use注册中间件app.use((ctx, next) =&gt; &#123; if (ctx.request.url === &#x27;/login&#x27;) &#123; if (ctx.request.method === &#x27;GET&#x27;) &#123; console.log(&quot;来到了这里~&quot;); ctx.response.body = &quot;Login Success~&quot;; &#125; &#125; else &#123; ctx.response.body = &quot;other request~&quot;; &#125;&#125;);// 没有提供下面的注册方式// methods方式: app.get()/.post// path方式: app.use(&#x27;/home&#x27;, (ctx, next) =&gt; &#123;&#125;)// 连续注册: app.use((ctx, next) =&gt; &#123;// &#125;, (ctx, next) =&gt; &#123;// &#125;)app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); 路由的使用需要安装第三方库 koa-router 12345678910111213141516171819202122232425262728293031323334const Koa = require(&#x27;koa&#x27;);const userRouter = require(&#x27;./router/user&#x27;);const app = new Koa();app.use((ctx, next) =&gt; &#123; // ctx.response.body = &quot;Hello World&quot;; next();&#125;);app.use(userRouter.routes());app.use(userRouter.allowedMethods()); //如果访问了错误的地址和方式app.listen(8000, () =&gt; &#123; console.log(&quot;koa路由服务器启动成功~&quot;);&#125;);//routersconst Router = require(&#x27;koa-router&#x27;);const router = new Router(&#123;prefix: &quot;/users&quot;&#125;);router.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123; ctx.response.body = &quot;User Lists~&quot;;&#125;);router.put(&#x27;/&#x27;, (ctx, next) =&gt; &#123; ctx.response.body = &quot;put request~&quot;;&#125;);module.exports = router; 参数解析query，params12345678910111213141516171819202122232425const Koa = require(&#x27;koa&#x27;);const app = new Koa();const Router = require(&#x27;koa-router&#x27;);const userRouter = new Router(&#123;prefix: &#x27;/users&#x27;&#125;);userRouter.get(&#x27;/:id&#x27;, (ctx, next) =&gt; &#123; console.log(ctx.request.params); console.log(ctx.request.query);&#125;)// app.use((ctx, next) =&gt; &#123;// console.log(ctx.request.url);// console.log(ctx.request.query);// console.log(ctx.request.params);// ctx.response.body = &quot;Hello World&quot;;// &#125;);app.use(userRouter.routes());app.listen(8000, () =&gt; &#123; console.log(&quot;参数处理服务器启动成功~&quot;);&#125;); 参数解析urlenclded和formdatanpm install koa-bodyparser koa-multer 12345678910111213141516171819202122const Koa = require(&#x27;koa&#x27;);const bodyParser = require(&#x27;koa-bodyparser&#x27;); //json,urlencodedconst multer = require(&#x27;koa-multer&#x27;); //form-dataconst Router = require(&#x27;koa-router&#x27;);const app = new Koa();const upload = multer();app.use(bodyParser());app.use(upload.any());app.use((ctx, next) =&gt; &#123; console.log(ctx.request.body); console.log(ctx.req.body); //multer塞进去的 ctx.response.body = &quot;Hello World&quot;;&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); 文件上传123456789101112131415161718192021222324252627const Koa = require(&#x27;koa&#x27;);const Router = require(&#x27;koa-router&#x27;);const multer = require(&#x27;koa-multer&#x27;);const app = new Koa();const uploadRouter = new Router(&#123;prefix: &#x27;/upload&#x27;&#125;);// const storage = multer.diskStorage(&#123;// destination,// filename,// &#125;)const upload = multer(&#123; dest: &#x27;./uploads/&#x27;&#125;);uploadRouter.post(&#x27;/avatar&#x27;, upload.single(&#x27;avatar&#x27;), (ctx, next) =&gt; &#123; console.log(ctx.req.file); ctx.response.body = &quot;上传头像成功~&quot;;&#125;);app.use(uploadRouter.routes());app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); koa响应内容body将相应主体分为 string Buffer Stream Object&#x2F;Array null 如果response.status未设置，koa自动设置状态为200或者204 &#x2F;&#x2F;有内容200，没内容返回null和204 1234567891011121314151617181920212223242526272829const Koa = require(&#x27;koa&#x27;);const app = new Koa();app.use((ctx, next) =&gt; &#123; // ctx.request.query // ctx.query // 设置内容 // ctx.response.body // ctx.response.body = &quot;Hello world~&quot; // ctx.response.body = &#123; // name: &quot;coderwhy&quot;, // age: 18, // avatar_url: &quot;https://abc.png&quot; // &#125;; // 设置状态码 // ctx.response.status = 400; // ctx.response.body = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;]; // ctx.response.body = &quot;Hello World~&quot;; ctx.status = 404; ctx.body = &quot;Hello Koa~&quot;;&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); 部署静态资源npm Install koa-static 1234567891011const Koa = require(&#x27;koa&#x27;);const staticAssets = require(&#x27;koa-static&#x27;);const app = new Koa();app.use(staticAssets(&#x27;./build&#x27;));app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); 错误处理1234567891011121314151617181920const Koa = require(&#x27;koa&#x27;);const app = new Koa();app.use((ctx, next) =&gt; &#123; const isLogin = false; if (!isLogin) &#123; ctx.app.emit(&#x27;error&#x27;, new Error(&quot;您还没有登录~&quot;), ctx); &#125;&#125;);app.on(&#x27;error&#x27;, (err, ctx) =&gt; &#123; ctx.status = 401; ctx.body = err.message;&#125;)app.listen(8000, () =&gt; &#123; console.log(&quot;koa初体验服务器启动成功~&quot;);&#125;); express和koa的区别express比较完整，koa比较自由简洁只包含核心功能，我们需要自己安装使用 两者核心都是中间件 express同步数据123456789101112131415161718192021222324const express = require(&#x27;express&#x27;);const app = express();const middleware1 = (req, res, next) =&gt; &#123; req.message = &quot;aaa&quot;; next(); res.end(req.message);&#125;const middleware2 = (req, res, next) =&gt; &#123; req.message += &quot;bbb&quot;; next();&#125;const middleware3 = (req, res, next) =&gt; &#123; req.message += &quot;ccc&quot;;&#125;app.use(middleware1, middleware2, middleware3);app.listen(8000, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;) express异步数据express处理异步数据非常麻烦，只能单独抽离函数await 1234567891011121314151617181920212223242526const express = require(&#x27;express&#x27;);const axios = require(&#x27;axios&#x27;);const app = express();const middleware1 = async (req, res, next) =&gt; &#123; req.message = &quot;aaa&quot;; await next(); res.end(req.message);&#125;const middleware2 = async (req, res, next) =&gt; &#123; req.message += &quot;bbb&quot;; await next();&#125;const middleware3 = async (req, res, next) =&gt; &#123; const result = await axios.get(&#x27;http://123.207.32.32:9001/lyric?id=167876&#x27;); req.message += result.data.lrc.lyric;&#125;app.use(middleware1, middleware2, middleware3);app.listen(8000, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;) koa同步数据1234567891011121314151617181920212223242526const Koa = require(&#x27;koa&#x27;);const app = new Koa();const middleware1 = (ctx, next) =&gt; &#123; ctx.message = &quot;aaa&quot;; next(); ctx.body = ctx.message;&#125;const middleware2 = (ctx, next) =&gt; &#123; ctx.message += &quot;bbb&quot;; next();&#125;const middleware3 = (ctx, next) =&gt; &#123; ctx.message += &quot;ccc&quot;;&#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.listen(8000, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;) koa异步数据1234567891011121314151617181920212223242526272829const Koa = require(&#x27;koa&#x27;);const axios = require(&#x27;axios&#x27;);const app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; ctx.message = &quot;aaa&quot;; await next(); next(); ctx.body = ctx.message;&#125;const middleware2 = async (ctx, next) =&gt; &#123; ctx.message += &quot;bbb&quot;; await next();&#125;const middleware3 = async (ctx, next) =&gt; &#123; const result = await axios.get(&#x27;http://123.207.32.32:9001/lyric?id=167876&#x27;); ctx.message += result.data.lrc.lyric;&#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.listen(8000, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;) 洋葱模型…… 学无止境，结束意味着新的开始 loading……","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"Buffer和浏览器的事件循环","slug":"Node5","date":"2022-05-29T16:00:55.000Z","updated":"2022-09-20T08:03:25.350Z","comments":true,"path":"2022/05/30/Node5/","link":"","permalink":"https://222cabbage.github.io/2022/05/30/Node5/","excerpt":"","text":"Buffer和浏览器的事件循环Bufferbuffer与数据的二进制计算机中所有内容，文字音频视频都是二进制来表示的 js很难表示二进制，可以使用node中的buffer，或者库Sharp，对buffer进行处理 buffer相当于一个存储了二进制的数组，数组中的每一项都可以保存八位二进制：00000000 八位二进制数字合在一起称作单元，称为一个字节 1byte &#x3D; 8bit ，1kb &#x3D; 1024byte，1m &#x3D; 1024kb buffer和字符串一般情况下中文字符对应三个字节 12345678910111213//创建方式1：已过期，不推荐const buffer = new Buffer(&#x27;cabbage&#x27;) console.log(buffer) // //创建方式2const buffer = Buffer.from(&#x27;cabbage&#x27;,&#x27;utf-8&#x27;) //默认utf-8console.log(buffer)//解码consoe.log(buffer.toString(&#x27;utf8&#x27;))//解码时需要传递与编码相同的类型const buffer = Buffer.alloc(8) // 创建了一个八位buffer[0] = 88 buffer和文件操作123456fs.readFile(&#x27;./asset/xx.png&#x27;,(err,data)=&gt;&#123; // data是buffer格式 fs.writeFile(&#x27;./asset/yyy.png&#x27;,data,(err,data)=&gt;&#123; &#125;)&#125;) sharp可以在node中使用图片裁剪的插件 123456789const fs = require(&#x27;fs&#x27;);const sharp = require(&#x27;sharp&#x27;);sharp(&#x27;./foo.png&#x27;) .resize(300, 300) .toBuffer() .then(data =&gt; &#123; fs.writeFile(&#x27;./bax.png&#x27;, data, err =&gt; console.log(err)); &#125;) buffer的创建过程创建buffer时，不会频繁申请内存空间，默认先申请一个 8 * 1024个字节大小的空间，也就是8kb 事件循环和异步IO什么是事件循环？浏览器事件循环1：JavaScript是一种单线程的编程语言，同一时间只能做一件事，所有任务都需要排队依次完成，事件循环分为两种,分别是浏览器事件循环和node.js事件循环，JavaScript是一门单线程语言，指主线程只有一个。Event Loop事件循环，其实就是JS引擎管理事件执行的一个流程，具体由运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。事件循环机制告诉了我们JS代码的执行顺序，是指浏览器或Node的一种解决JS单线程运行时不会阻塞的一种机制。 2、执行过程所有同步任务都在主线程上执行，形成一个执行栈（调用栈）；主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中（队列遵循先进先出得原则）一旦主线程的栈中的所有同步任务执行完毕后，调用栈为空时系统就会将队列中的回调函数依次压入调用栈中执行，当调用栈为空时，仍然会不断循环检测任务队列中是否有代码需要执行；3、执行顺序先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。注意：当宏任务和微任务都处于 任务队列（Task Queue） 中时，微任务的优先级大于宏任务，即先将微任务执行完，再执行宏任务； 进程process计算机已经运行的程序 启动一个应用程序，就会默认启动一个进程，也可能是多个 线程thread操作系统能够运行运算调度的最小单位 每一个进程都会启动一个线程来执行程序的代码，这个线程被称为主线程，进程是线程的容器 操作系统是工厂，车间是进程，车间里的工人是线程 多进程多线程开发现代操作系统可以做到多进程多线程，得益于CPU运算速度的提升，快速切换多个进程 js的线程容器是浏览器和node js是单线程的，意味着同一时间只能做一件事，因此后续的线程会被前面的阻塞 宏任务和微任务宏任务队列：ajax，定时器，DOM监听，UI Rendering 微任务队列：Promise.then，Mutation Observer API，queueMicrotask(()&#x3D;&gt;{}) &#x2F;&#x2F;自定义微任务 优先级： 执行栈代码，同步任务优先执行，在执行任何一个宏任务之前，都会查看是否有微任务，执行完微任务，保证微任务队列是空的以后，再执行一个宏任务，执行完后再检查有没有微任务，然后再执行宏任务队列的下一个宏任务 async和await是promise的语法糖，await后面执行的代码相当于(resolvemreject)&#x3D;&gt;{} await的下一句相当于then，放入微任务队列 node事件循环LIBUV专注异步IO的库，为node开发 WORKER THREADS线程池 阻塞IO和非阻塞IO 如果希望对一个文件进行操作，呢么需要通过文件描述符打开这个文件 js实际上不能对文件进行操作，任何程序的文件操作都是通过系统1调用(操作系统的文件系统) 实际上对文件的操作，是一个操作系统的系统调用（IO系统，IO是输入、输出） 操作系统提供了两种调用文件系统的方式：阻塞式调用和非阻塞式调用 阻塞式调用：调用结果返回前，当前线程处于阻塞状态，（阻塞状态CPU是不会分配时间片的），调用线程只有在调用结果以后才会继续执行 非阻塞式调用：调用执行以后，当前线程不会停止执行，会立即返回一个记过然后执行后续代码。只需要过一段时间来检查有没有结果返回，不停判断，轮询，轮询十分消耗性能 采用了非阻塞式的操作 socket通信，文件读写的IO操作 libuv提供了一个线程池，thread pool 线程池会负责所有相关操作，并且通过轮询或者其他方式等待结果 当获取结果以后，就可以将对应回调放到事件循环（某一个事件队列）中 事件循环就可以负责接管后续工作，告知js应用程序执行对应回调函数 阻塞和非阻塞，同步和异步的区别阻塞和被阻塞是针对被调用者来说的 同步和异步是针对调用者来说的 事件循环 无论是文件IO，数据库IO，网咯IO，定时器，子进程，在完成对应操作以后，都会将结果和回调函数放到事件循环(任务队列)中 事件循环会不断的从任务队列中取出对应事件（回调函数）执行 node中一次完整的事件循环Tick分为很多阶段 定时器(Timers)：本阶段已执行定时器回调函数 待定回调（Pending Callback）：对某些系统操作，如TCP错误类型执行回调，比如TCP连接时收到ECONNREFUSED idle，prepare：仅系统内部使用 轮询（Poll）：检索新的IO事件，执行与IO相关的回调 检测：setImmediate（）回调函数在这里执行1 关闭的回调函数：一些关闭的回调函数，如socket.on(‘close’，（）&#x3D;&gt;{}) node的微任务和宏任务微任务：promise.then，process.nextTick，queueMicrotask 宏任务：定时器，IO事件，seiImmediate，close事件 执行一次循环就是一次tick node的事件循环比浏览器事件循环要复杂些 1 setImediata相比于定时器偶尔会早执行，和双方推入任务队列的顺序无关 涉及到了libuv底层的机制 额外知识：发布nom包首先在npmjs.com注册账号 命令行执行npm login 输入账号和密码，密码是不可见的 npm publish Stream&#x2F;流当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读取到我们程序中 而这一连串的字节就是流 流式连续字节的一种表现形式和抽象概念 流式可读可写的 文件读写时可以使用readFile和writeFile方式读写文件，那么为什么需要流呢 直接读写文件的方式，无法控制细节操作 比如从什么位置开始读？读到什么位置，一次性读取多少个字节 读到某个位置后，暂停读取，某个时刻恢复读取等 或者这个文件非常大，视频文件之类，一次性全部读取不合适 所有的流都是eventEmitter的实例 node中有四种基本流类型 读 1234567891011121314151617181920212223242526272829const fs = require(&#x27;fs&#x27;)读const reader = fs.createReadStream(&#x27;./foo.txt&#x27;,&#123; flag encoding fd文件描述符 mode文件权限 start开始读取位置 end结尾位置 highWaterMark每次读多少 ... //很多属性看官网&#125;)//数据读取过程reader.on(&#x27;data&#x27;,(data)=&gt;&#123; console.log(data) reader.pause() //暂停读取 setTimeout(()=&gt;&#123; reader.resume() //恢复读取 &#125;,1000)&#125;)reader.on(&#x27;open&#x27;,()=&gt;&#123; conosle.log(&#x27;文件被打开&#x27;)&#125;)reader.on(&#x27;close&#x27;,()=&gt;&#123; conosle.log(&#x27;文件被关闭&#x27;)&#125;) 写 123456789101112131415161718192021222324const fs = require(&#x27;fs&#x27;)const writer = fs.createWriteStream(&#x27;./bar,txt&#x27;,&#123; flags:&#x27;a&#x27;, start ... //很多属性看官网&#125;)写入writer.write(&#x27;写入的数据&#x27;//可以是buffer，(err)=&gt;&#123; if(err)&#123; console.log(err) return &#125; console.log(&#x27;写入成功&#x27;)&#125;)writer.close() //关闭，但是真实开发很少一般使用writer.end(&#x27;1&#x27;//写入最后东西，然后关闭)写入是可以一直写入writer.writer......writer.on(&#x27;close&#x27;,()=&gt;&#123; console.log(&#x27;文件被关闭&#x27;)&#125;) pipe方法 1234567891011fs.readFile(&#x27;&#x27;,(err,data)=&gt;&#123; fs,writeFile(&#x27;./&#x27;,data,()=&gt;&#123; &#125;)&#125;)stream通过pipe的读写const reader = fs.createReadStream(&#x27;./&#x27;)const writer = fs.createWriteStream(&#x27;./&#x27;)reader.pipe(writer)writer.close() loading……","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"webpack的学习","slug":"webpack1","date":"2022-05-28T15:18:47.000Z","updated":"2022-06-12T15:53:48.089Z","comments":true,"path":"2022/05/28/webpack1/","link":"","permalink":"https://222cabbage.github.io/2022/05/28/webpack1/","excerpt":"","text":"webpack的学习虽然以前接触过webpack，但是一开始webpack学习后考虑到当时很菜的我并没有什么运用的地方 因此一开始就学习的很草率，什么也没有记住，现在重新再学一次 想要使用webpacj，首先得安装webpack和webpackcli 但是不建议安装在全局可以在某个文件夹下单独npm init 建立package.json文件以后再npm安装在该目录下 npm install webpack -S npm install webpack-cli -S 在src文件下需要新建一个index.js作为js文件的入口 被外部的index.html引入 npm run build &amp;&amp; npx webpack 会在目录下生成一个dist文件夹，内部包含一个main.js 包含打包后的代码 webpack内置指令很多，可以通过npx webpack –help查看 自定义文件的打包路径和打包文件名 path需要引入path模块拼接形成绝对路径，否则会报错 因为打包完后的路径是dist&#x2F;main.js，因此需要修改index.html的js文件路径 插件每次手动去index.html修改dist下的路径太麻烦，因此需要插件 想要使用插件需要require引入，然后放入plugins中 HtmlWebpackPluginnpm install -S html-webpack-plugin new实例化 在dist文件夹下单独生成一个引入了js文件的html 如何使用原来的index.html入口 npx webpack ! 冲啊！ 清理dist每次重复生成dist内部文件，需要在每次构建前清除dist文件 再重新生成，需要使用output.clean 搭建开发环境设置mode &#x3D; ‘development’ 设置source map 因为webpack打包源码时很难追踪到错误和警告所处位置 1234567891011121314151617181920const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry:&#x27;./src/index.js&#x27;, output:&#123; filename:&#x27;haoge.js&#x27;, path:path.resolve(__dirname,&#x27;./dist&#x27;), clean:true &#125;, mode:&#x27;development&#x27;, devtool:&#x27;inline-source-map&#x27;, //在开发模式下追踪代码 plugins:[ new HtmlWebpackPlugin(&#123; template:&#x27;./index.html&#x27;, //打包生成的文件模板 filename:&#x27;app.html&#x27;, //打包生成的文件名称 默认是index.html // 资源文件注入模板的位置 inject:&#x27;body&#x27; &#125;) ]&#125; 由于每次都需要重新打包启动浏览器观看 很麻烦 可以使用 watch mode观察模式 1npx webpack --watch 能够自动检测代码变化，不需要重新打包，但是再浏览器中想要查看最新的代码依旧需要刷新 因此需要使用webpack-dev-server 1234567npm install webpack-dev-server -Smodule.exports = &#123; devServer:&#123; static:&#x27;./dist&#x27; //将dist下的文件设置为web服务的目录 &#125;, &#125;npx webpack serve --open 资源模块webpack内置模块asset modules引入其他类型文件 1234asset/resource 发送一个单独的文件并导出URLasset/inline 导出一个资源的data URIasset/source 导出资源源代码asset 在导出一个data URI 和发送一个单独的文件之间自动选择 引入资源匹配 修改src内容引入资源创建dom渲染 注：不能再npx webpack serve –open下打开 必须先npx webpack打包后 再npx webpack serve –open启动 自定义输出文件名 123output:&#123; assetModuleFilename:&#x27;image/[contenthash][ext][query]&#x27;&#125; 会将文件导出带dist下的image目录 默认命名为image&#x2F;[contenthash][ext][query] 也可将某些指定资源打包到特定目录 12345678rules: [&#123; test: /\\.png/, type: &#x27;asset/resource&#x27;, // 优先级高于 assetModuleFilename generator: &#123; filename: &#x27;images/[contenthash][ext][query]&#x27; &#125;&#125;] inline资源行内123456module:&#123; rules[&#123; test:/\\.svg/, type:&#x27;asset/inline&#x27; &#125;]&#125; 会将文件作为URL注入dom的src 自定义webpack的URL生成器webpack自带的inline编译的url是base64，如果想自定义url，可以下载一个自定义函数来编码文件内容 npm install mini-svg-data-uri -D source资源12345678910mocule:&#123; rules:[&#123; test:/\\.txt/, type:&#x27;asset/source&#x27; &#125;]&#125;// 遇到一个以前没接触过的写法dom.style.cssText = `width:100px;height:200px;background:skyblue` // 定义样式dom.textContent = &#x27;cabbage&#x27; ////最后生成一个200px宽高，内容是文本cabbage的盒子 通用资源设置type为asset以后，webpack会自动识别，小于8k被视为inline，反之视为resource 可以在webpack中设置限制的大小 123456789&#123; test:/\\.jpg/, type:&#x27;asset&#x27;, parser:&#123; dataUrlCondition:&#123; maxSize: 4 * 1024 // 限制4kb &#125; &#125; &#125; Loaderl除开资源模块，可以使用loader引入其他类型文件 webpack只能识别js和json，loader能够让其他类型文件转换为有效模块，供应用程序使用 loader具有两个属性，test：匹配对应文件，use：定义应该使用哪种loader 加载CSS12345678910111213141516171819//为了import css文件，需要安装style-loader与css-loadernpm install --save-d style-loader css-loader &#123; test:/\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] //顺序固定，不然可能会抛出错误 &#125; // 也可以支持less，sass等预处理器// npm install less less-loader --save-dev// 匹配less文件 &#123; test:/\\.less$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;] &#125;@color:yellow;.world &#123; color: @color;&#125; 抽离和压缩CSS12345678910111213141516171819202122npm install mini-css-extract-plugin --save-dev// 该插件会将包含css的js文件创建一个css文件，并支持按需加载和sourcemap，必须要webpack5才能运行const miniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)plugins：[ new MiniCssExtractPlugin(&#123; filename:&#x27;styles/[contenthash].css&#x27; &#125;)]&#123; test:/\\.css$/i, use:[miniCssExtractPlugin.loader,&#x27;css-loader&#x27;]&#125;npx webpack //将css文件打包在dist/styles/xxxx.css打开文件后发现样式代码并没有压缩 需要安装css-minimizer-webpack-pluginnpm install css-minimizer-webpack-plugin --sace-dev optimization:&#123; minimizer:[ new CssMinimizerPlugin() ] &#125;, // 有一个地方不能忽视，需要将mode改为production，否则压缩会失败 加载images图像我们可以借助资源模块将图片混入我们的系统，也可以使用css直接引用文件 12345......backImg &#123; background-image: url(&#x27;&#x27;) // style.css 我在玩的时候引入的背景图片大小是400多k，会直接遮罩警告，但是可以关闭，所以丝毫不慌&#125; 加载font使用资源模块 12345&#123; test：/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27;&#125;// 引入阿里巴巴字体图标库...... 加载数据webpack还可以加载xml，json，csv，tsv等文件，需要使用csv-loader和xml-loader 1234567891011npm install --save-dev csv-loader xml-loader&#123; test:/\\.(csv|tsv)$/i, use:[&#x27;csv-loader&#x27;]&#125;,&#123; test:/\\.xml$/i, use:[&#x27;xml-loader&#x27;]&#125;// csv会被转化成数组 xml会被转化为对象 自定义JSON模块parser通过自定义parser替代特定的webpack loader，可以将任何toml，yaml，或者json5作为JSON文件导入 12345678910111213141516171819202122232425npm install toml yamljs json5 --save-dev在webpack.config.js中配置const toml = require(&#x27;toml&#x27;)const yaml = require(&#x27;yamljs&#x27;)const json5 = require(&#x27;json5&#x27;)&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;,&#125;,&#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;,&#125;,&#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;,&#125; babel-loaderjs文件需要编译吗？ webpack可以加载打包js文件，但是无法对js文件做出转换，会保持原样输出，可以使用babel-loader将es6转换成es5 12345678910111213141516171819202122232425262728293031323334353637383940npm install -D babel-loader @babel/core @babel/preset-envbabel-loader : 在webpack里应用 babel 解析ES6的桥梁@babel/core : babel核心模块@babel/preset-env : babel预设，一组 babel 插件的集&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125; &#125; // npx webpack// 按照文档来说应该会报regeneratorRuntime is not defined 但是我没报 挺神奇的// 如果报错了那么就是babel未配置正确# 这个包中包含了regeneratorRuntime，运行时需要npm install --save @babel/runtime# 这个插件会在需要regeneratorRuntime的地方自动require导包，编译时需要npm install --save-dev @babel/plugin-transform-runtime# 更多参考这里https://babeljs.io/docs/en/babel-plugin-transform-runtime// 接着修改一下webpack.config.js的配置&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;], plugins: [ [ &#x27;@babel/plugin-transform-runtime&#x27; ] ] &#125; &#125; &#125; 代码分离代码分离是webpack的特性，可以将不同的代码分离到不同的bundle，可以影响加载时间 常用的代码分离方法： 1：入口起点，手动配置entry分离代码 2：防止重复，使用Entry dependencies 或者 SplitChunksPlugin 去重和分离chunk 3：动态导入，通过模块的内联函数调用来分离代码 1：入口起点12345678910111213// 修改配置文件entry:&#123; index:&#x27;./src/index.js&#x27;, another:&#x27;./src/another-module.js&#x27; &#125;, output:&#123; filename:&#x27;[name].bundle.js&#x27;, path:path.resolve(__dirname,&#x27;./dist&#x27;), clean:true, assetModuleFilename:&#x27;images/[contenthash][ext][query]&#x27; &#125;, // 在 another-bundle.js 和 index.js 中如果都引用了lodash 那么打包的体积就会增大 造成重复问题 2：防止重复配置dependOn，可以在多个chunk共享模块 12345678910111213141516// 设置lodash为共享模块 会在dist下生成shared.bundle.jsentry:&#123; index:&#123; import:&#x27;./src/index.js&#x27;, dependOn:&#x27;shared&#x27; &#125;, another:&#123; import:&#x27;./src/another-module.js&#x27;, dependOn:&#x27;shared&#x27; &#125;, shared: &#x27;lodash&#x27;, // index:&#x27;./src/index.js&#x27;, // another:&#x27;./src/another-module.js&#x27;&#125;,// 但是这种方式需要手动配置共享文件 可以利用SplitChunksPlugin插件将公共依赖模块提取到已有或者是新生成的chunk 3：动态导入当涉及到动态拆分代码时，需要使用es的import或者webpack的遗留功能require.ensure 123// 1:importimport &#x27;./async-module&#x27; // 内部包含js代码// 2:require.ensure 4：懒加载在一开始不加载，在完成了某些操作之后再加载，优化响应速度 123456789const btn = document.createElement(&#x27;button&#x27;)btn.textContent = &#x27;点击执行加法&#x27;btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; import(/* webpackChunkName: &#x27;math&#x27; */ &#x27;./math.js&#x27;).then((&#123;add&#125;)=&gt;&#123; console.log(add(10,30)) &#125;)&#125;)// webpack 魔法注释： webpackChunkName: &#x27;math&#x27; ,告诉webpack打包生成的文件名为 math// npx webpack打包完以后，在浏览器点击这个按钮才会引入并运行math.bundle.js 5：预获取&#x2F;预加载模块webpack4.6增加了对预获取和预加载的支持 使用prefetch和preload 1234567891011121314// prefetch 添加该魔法注释以后 浏览器回在闲置时间自动下载该math.js文件btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; import(/* webpackChunkName: &#x27;math&#x27;, webpackPrefetch: true */ &#x27;./math.js&#x27;).then((&#123;add&#125;)=&gt;&#123; console.log(add(10,30)) &#125;)&#125;)// preloadpreload是当下时刻，prefetch是未来的时刻preload立即下载，prefetch是闲置时下载preload加载方式是并行的，prefetch是主chunk结束后执行import(/* webpackChunkName: &#x27;print&#x27;, webpackPreload: true */ &#x27;./print.js&#x27;).then((&#123;print&#125;)=&gt;&#123; print()&#125;) &#x2F;&#x2F; prefetch 闲置加载 &#x2F;&#x2F; preload 并行加载 是和index.bundle.js一起加载的 缓存输出文件文件名123456// 可以通过修改替换outpur中的filename的substitutions设置，定义输出名称// webpack提供了一个substitution(可替换模板字符串的方式)// 通过括号字符串来模板化文件名，[contenthash] ，substitution会根据资源内容创建出唯一hash，当资源内容变化时，[conetenthash]会自动发生变化output:&#123; filename:&#x27;[name].[contenthash].js&#x27;, &#125;, 缓存第三方库在webpack中比较推荐将lodash等第三方库提取到一个单独的chunk中，利用client的长效缓存机制，减少不做修改的文件的请求 123456789101112131415// 在optimization.splitChunks 添加如下 cacheGroups 参数并构建optimization:&#123; // minimizer:[ // new CssMinimizerPlugin() // ], splitChunks:&#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27;, &#125;, &#125;, &#125; &#125;, 将js文件放置到一个文件夹中123output: &#123; filename: &#x27;scripts/[name].[contenthash].js&#x27;,&#125;, 拆分开发环境和生产环境配置目前只能手动调整mode切换开发环境和生产环境，考虑到很多配置在开发与生产环境不一样，因此需要区分开发和生产环境以便更灵活的打包 公共路径12345678910111213141516171819// 在IE情况下// publicPath 可以用来指定应用程序中所有资源的基础路径// 基于环境配置，如果在开发环境将assets目录下的文件夹托管至CDN，那么如何使用// environment variable(环境变量)// webpack.config.js中import &#123; webpack &#125; from &#x27;webpack&#x27;const ASSET_PATH = process.env.ASSET_PATH || &#x27;/&#x27;output:&#123; filename:&#x27;scripts/[name].[contenthash].js&#x27;, publicPath:ASSET_PATH&#125;,plugins: [ // 这可以帮助我们在代码中安全地使用环境变量 new webpack.DefinePlugin(&#123; &#x27;process.env.ASSET_PATH&#x27;: JSON.stringify(ASSET_PATH), &#125;),],// Automatic publicPathwebpack 会自动根据import.meta.url 、 document.currentScript 、 script.src 或者self.location 变量设置 publicPath。我们所需要做的是将 output.publicPath设为 &#x27;auto&#x27;// 在IE情况下，不支持document.currentScript，这时需要引入polyfill，例如currnetScript Polifill 环境变量想要消除webpack.config.js在开发环境和生产环境之间的差异，需要环境变量environment variable 12345678910// npx webpack --env goal=local --env production --progress// 可以通过该方式给webpack配置环境变量// 通常module.exports 指向一个对象，想要使用env变量，那么就需要将module.exports转换成一个函数module.exports = () =&gt; &#123; return &#123; ...... mode:env.production ? &#x27;production&#x27; : &#x27;development&#x27; ...... &#125;&#125; 拆分配置文件目前不管是开发环境还是生产环境，使用的都是同一个配置文件，我们需要创建新的文件区分 webpack.config.dev.js webpack.config.prod.js 123456// ...文件忽略 在生产环境可以配置如下信息，隐藏webpack性能提示信息performance: &#123; hints:false&#125;,npx webpack serve -c ./config/webpack.config.dev.js // 执行开发环境配置npx webpack serve -c ./config/webpack.config.prod.js // 执行生产环境配置 npm脚本1234567// 每次打包时都要npx xxxxxx// 在package.json中配置命令&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack serve -c ./config/webpack.config.dev.js&quot;, &quot;build&quot;: &quot;webpack -c ./config/webpack.config.prod.js&quot;&#125;// npm run build 完美！ 提取公共配置在webpack.config.dev.js 和 webpack.config.prod.js 中存在大量相同配置webpack.config.common.js 123456// 新建webpack.config.common.js 抽取dev和prod中相同的部分......此处省略一万字//改写webpack.config.dev.js......此处省略一万字//改写webpack.config.prod.js......此处省略一万字 合并配置文件1234567891011121314151617// 在代码拆分完毕后 如何保证合并没有问题呢？利用webpack-merge// npm install webpack-merge// 创建webpack.config.jsconst &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const commonConfig = require(&#x27;./webpack.config.common.js&#x27;)const productionConfig = require(&#x27;./webpack.config.prod.js&#x27;)const developmentConfig = require(&#x27;./webpack.config.dev&#x27;)module.exports = (env) =&gt; &#123; switch(true) &#123; case env.development: return merge(commonConfig, developmentConfig) case env.production: return merge(commonConfig, productionConfig) default: throw new Error(&#x27;No matching configuration was found!&#x27;); &#125;&#125; 内卷无出路，躺平才是真……","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://222cabbage.github.io/categories/Webpack/"}],"tags":[{"name":"Webpack学习","slug":"Webpack学习","permalink":"https://222cabbage.github.io/tags/Webpack%E5%AD%A6%E4%B9%A0/"}]},{"title":"实现自己的脚手架","slug":"Node4","date":"2022-05-28T15:15:09.000Z","updated":"2022-05-29T15:59:52.943Z","comments":true,"path":"2022/05/28/Node4/","link":"","permalink":"https://222cabbage.github.io/2022/05/28/Node4/","excerpt":"","text":"实现自己的脚手架! &#x2F;&#x2F; sha-bang指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env node 固定写法console.log(&#x27;cabbage&#x27;)终端执行npm link 将package下的bin配置的指令与环境变量匹配做链接使用第三方库快速构建命令commandernpm install commanderconst program = require(&#x27;commander&#x27;)program.version(require(&#x27;./package.json&#x27;).version) // 动态获取版本号program.option(&#x27;-c --cabbage&#x27;,&#x27;a cabbage cli，菜的脚手架&#x27;) //设置help指令cabbage --versioncabbage --helpprogram.on(&#x27;--help&#x27;,()=&gt;&#123; //监听命令 console.log(&#x27;使用了--help&#x27;)&#125;)cabbage create demo配置命令后需要执行git clone ，npm install，npm run serve如何让git clone？ 需要第三方库的支持npm install download-git-repo......中间省略一万字 字儿太难打了新知识：EJS模板，新建组件，页面，路由文件，vuex文件都需要一个模板最后实现了一个脚手架，但是存在一些问题，似乎是包的版本太老了......等以后再弄一个完整版的脚手架吧，现在的顶多算bug版的脚手架发布到npm上了，如果感兴趣可以看看，但是不建议下载，有点小问题影响使用","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"包管理工具","slug":"Node3","date":"2022-05-23T05:34:13.000Z","updated":"2022-05-28T15:13:47.866Z","comments":true,"path":"2022/05/23/Node3/","link":"","permalink":"https://222cabbage.github.io/2022/05/23/Node3/","excerpt":"","text":"包管理工具如何将自己封装好的模块化的工具分享给其他人？ github？手动下载引入 npm？yyds npm init 一直回车 或者 npm init -y npm Install packagename –save-d npm install packagename -S &#x2F; -D 12345678910111213141516171819202122// console.log(process)// const path = require(&#x27;path&#x27;)// console.log(__dirname)// path.resolve(__dirname,&#x27;./a.txt&#x27;)// npm install 原理 // 帮助我们执行了什么操作// npm 从5开始支持缓存策略 因为yarn的压力// 判断有无package.lock 检测依赖关系 查找缓存 构建依赖关系 压缩到nodemodules 如果没有缓存则去官网仓库下载到本地建立缓存// npm config get cache 获取缓存路径// 卸载包 npm uninstall packagename --save-dev// 强制重新build npm rebuild// 清除缓存 npm cache clean// yarn 解决早期npm下载慢 依赖等问题// yarn add / remove// cnpm 淘宝镜像china npm// npm install cnpm -g --register=&quot;&quot; // 查看当前npm镜像// npm config get registry// npm config set registry 地址// npx npm5.2之后自带的一个命令","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"基于uniapp和uview1.0的简易表单生成器","slug":"Component1","date":"2022-05-17T16:51:43.000Z","updated":"2022-05-17T16:55:24.158Z","comments":true,"path":"2022/05/18/Component1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/Component1/","excerpt":"","text":"基于uniapp和uview1.0的简易表单生成器在新的项目中，有的表单项相同，那么能不能将表单form-item循环生成出来？只需要传递配置项与规则即可自动生成 说干就干 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221​```//表单Form.vue封装 基于uview1.0的input输入框 可以传递类型为text，textarea或者select下拉框//其他类型需要使用插槽或者其他方式插入 可以绑定form数据&lt;template&gt; &lt;view class=&quot;&quot;&gt; &lt;view class=&quot;formbox&quot;&gt; &lt;u-form :model=&quot;form&quot; ref=&quot;uForm&quot; label-width=&quot;150rpx&quot;&gt; &lt;u-form-item v-for=&quot;(item,index) in formItems&quot; :key=&quot;index&quot; :label=&quot;item.labelName&quot; :prop=&quot;item.prop&quot; :border-bottom=&quot;item.borderBottom&quot; :label-width=&quot;item.labelWidth&quot; :style=&quot;&#123;&#x27;position&#x27; : item.prop === &#x27;des&#x27; ? &#x27;relative&#x27; : &#x27;&#x27; &#125;&quot; &gt; &lt;u-input v-if=&quot;item.showInput&quot; v-model=&quot;form[item.prop]&quot; :placeholder=&quot;item.placeholder&quot; :type=&quot;item.type&quot; :border=&quot;item.border&quot; :height=&quot;item.height&quot; :class=&quot;item.class&quot; :maxlength=&quot;item.maxlength&quot; :custom-style=&quot;item.inputStyle ? item.inputStyle : null&quot; :clearable=&quot;false&quot; @click=&quot;clickChange(item)&quot;/&gt; &lt;view v-if=&quot;item.prop === &#x27;fileList&#x27;&quot; class=&quot;filebox&quot;&gt; &lt;view class=&quot;title&quot;&gt; 请上传附件（&#123;&#123; fileLength &#125;&#125;/5） &lt;/view&gt; &lt;view class=&quot;&quot;&gt; &lt;u-upload ref=&quot;uUpload&quot; :action=&quot;action&quot; :auto-upload=&quot;false&quot; max-count=&quot;5&quot; @on-list-change=&quot;imgChange&quot; &gt;&lt;/u-upload&gt; &lt;/view&gt; &lt;view class=&quot;uploadtip&quot;&gt; &lt;u-icon name=&quot;info-circle&quot; color=&quot;#F7B500&quot; size=&quot;26&quot; style=&quot;margin-right: 12rpx;&quot; &gt;&lt;/u-icon&gt; 附件支持图片和视频,支持jpg/png/mp4格式 &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;countbox&quot; v-if=&quot;item.prop === &#x27;des&#x27;&quot;&gt; &#123;&#123; form.des.length ? form.des.length : 0 &#125;&#125;/300 &lt;/view&gt; &lt;/u-form-item&gt; &lt;/u-form&gt; &lt;u-picker mode=&quot;time&quot; :params=&quot;params&quot; v-model=&quot;showList[&#x27;timeshow&#x27;]&quot; @confirm=&quot;timechange&quot; @cancel=&quot;timecancel&quot;&gt;&lt;/u-picker&gt; &lt;view v-if=&quot;methodsList.length&quot;&gt; &lt;u-action-sheet v-for=&quot;(item,index) in methodsList&quot; :key=&quot;index&quot; :list=&quot;paramsData[item.propList]&quot; v-model=&quot;showList[item.prop + &#x27;show&#x27;]&quot; @click=&quot;selectchange&quot; &gt;&lt;/u-action-sheet&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:&#123; // 传递的下拉框数据 paramsData:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, rules:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, formItems:&#123; type:Array, default:()=&gt;([]) &#125; &#125;, data()&#123; return &#123; // 数据绑定 form:&#123;&#125;, // 控制显示 showList:&#123;&#125;, params: &#123; year: true, month: true, day: true, hour: true, minute: true, second: false &#125;, // 非真实地址 action: &#x27;http://www.example.com/upload&#x27;, fileLength:0, methodsList:[], selectList:&#123;&#125; &#125; &#125;, watch:&#123;&#125;, onReady() &#123; this.formItems.forEach((items)=&gt;&#123; this.$set(this.form,items.prop,&#x27;&#x27;) this.$set(this.showList,items.prop + &#x27;show&#x27; ,false) this.form.fileList = [] if(items.type === &#x27;select&#x27;)&#123; if(items.prop === &#x27;time&#x27;) return const dataStr = items.prop + &#x27;List&#x27; const fnStr = items.prop + &#x27;change&#x27; this.methodsList.push(&#123; prop:items.prop, propList:dataStr &#125;) &#125; &#125;) setTimeout(()=&gt;&#123; this.$refs.uForm.setRules(this.rules); &#125;,500) &#125;, methods:&#123; clickChange(item)&#123; this.selectList = &#123; prop:item.prop, formName:item.prop + &#x27;List&#x27; &#125; this.showList[item.prop + &#x27;show&#x27;] = true &#125;, selectchange(index)&#123; if(this.selectList)&#123; this.form[this.selectList.prop] = this.paramsData[this.selectList.formName][index].text; &#125; &#125;, timechange(obj)&#123; let timestr = Object.values(obj).join(&#x27;-&#x27;) this.form.time = timestr &#125;, timecancel()&#123; this.show2 = false &#125;, // 上传图片变化 imgChange(lists,name)&#123; this.fileLength = lists.length this.form.fileList = lists &#125;, validateForm()&#123; let flag this.$refs.uForm.validate(valid =&gt; &#123; if (valid) &#123; // 上传文件 // his.$refs.uUpload[0].upload() flag = true &#125; else &#123; flag = false &#125; &#125;) return flag &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import &#x27;./index.scss&#x27;&lt;/style&gt;//传入配置项 验证规则 export const rules = &#123; content: [ &#123; required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125; ], ...... fileList:[ &#123; type:&#x27;array&#x27;, required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125; ], &#125;//表单配置 export const formItems = [ ...... &#123; labelName:&#x27; &#x27;, labelWidth:&#x27;0&#x27;, type:&#x27;textarea&#x27;, prop:&#x27;content&#x27;, placeholder:&#x27;默认文字&#x27;, height:&#x27;420&#x27;, class:&#x27;desbox&#x27;, border:false, borderBottom:false, maxlength:&#x27;300&#x27;, showInput:true, inputStyle:&#123; &#x27;background&#x27;: &#x27;#F5F5F5&#x27;, &#x27;border-radius&#x27;:&#x27;8px&#x27;, &#x27;padding&#x27;:&#x27;22rpx 26rpx&#x27; &#125; &#125; ]","categories":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}],"tags":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}]},{"title":"JS运算方法-解决小数点运算精度问题","slug":"tips1","date":"2022-05-17T16:39:07.000Z","updated":"2022-05-17T16:51:21.090Z","comments":true,"path":"2022/05/18/tips1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/tips1/","excerpt":"","text":"解决小数点精度问题的JS方法一开始学JS的时候也遇到过小数点精度运算的问题，但是没怎么注意，后来在实习时公司的一个项目需要做到金额的运算 有的金额涉及到了小数点 后运算出的结果会带有很多位小数点 因此就有了这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106解决小数点计算精度问题/** * method ** * add / subtract / multiply /divide * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */export const floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123; times: 1, num: 0 &#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + &#x27;&#x27; var dotPos = strfi.indexOf(&#x27;.&#x27;) var len = strfi.substr(dotPos + 1).length var times = Math.pow(10, len) var intNum = Number(floatNum.toString().replace(&#x27;.&#x27;, &#x27;&#x27;)) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case &#x27;add&#x27;: if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case &#x27;subtract&#x27;: if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case &#x27;multiply&#x27;: result = (n1 * n2) / (t1 * t2) return result case &#x27;divide&#x27;: result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, &#x27;add&#x27;) &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, &#x27;subtract&#x27;) &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, &#x27;multiply&#x27;) &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, &#x27;divide&#x27;) &#125; // exports 暴露出加减乘除四个方法 其他页面引入解构调用 return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;","categories":[{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"}],"tags":[{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Node内置模块","slug":"Node2","date":"2022-05-15T07:16:27.000Z","updated":"2022-09-19T08:49:35.438Z","comments":true,"path":"2022/05/15/Node2/","link":"","permalink":"https://222cabbage.github.io/2022/05/15/Node2/","excerpt":"","text":"Node内置模块path：路径12345678910111213141516171819const path = require(&#x27;path&#x27;)//获取路径信息const filepath = &#x27;./1/2/3.text&#x27;console.log(path.dirname(filepath))./1/2console.log(path.basename(filepath))3.textconsole.log(path.extname(filepath)).text//join路径拼接const path1 = &#x27;/hello&#x27;const path2 = &#x27;/world&#x27;const filepath = path.join(path1,path2)//resolve拼接const path1 = &#x27;/a&#x27;const path2 = &#x27;/b&#x27;const dirname = path.resolve(path1,path2)resolve与join的区别resolve会帮助查询拼接字符串中有没有最前方的路径拼接符 &#x27;/user&#x27;的斜杠， 如果没有自动识别全部路径 htttp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// ① 导入 http 模块const http = require(&#x27;http&#x27;);// ② 创建 web 服务器实例const server = http.createServer();// ③ 为服务器实例绑定 request 事件，监听客户端的请求server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; console.log(&#x27;Someone visit my server.&#x27;);&#125;);// ④ 启动服务器server.listen(3000, function() &#123; console.log(&#x27;server strat&#x27;);&#125;)const http = require(&#x27;http&#x27;); const server = http.createServer();server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; //req 是请求对象，它包含了与客户端相关的数据或属性 //req.url 客户端请求的地址 const url = req.url; //req.method 请求的方法 const method = req.method; const str = `Your request url is $&#123;url&#125;,and request method is $&#123;method&#125;`; console.log(str);&#125;) server.listen(3000, () =&gt; &#123; console.log(&#x27;server strat&#x27;);&#125;)const http = require(&#x27;http&#x27;) const server = http.createServer();server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; const str = `请求的地址是$&#123;req.url&#125;,请求的方式是$&#123;req.method&#125;`; //解决中文乱码问题：调用res.setHeader()方法，设置Content-Type res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); res.end(str);&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;server strat&#x27;);&#125;)const http = require(&#x27;http&#x27;); const server = http.createServer();server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // ① 获取请求的 url 地址 const url = req.url; // ② 设置默认的响应内容为 404 Not found let content = `&lt;h1&gt;404 Not found!&lt;/h1&gt;`; // ③ 判断用户请求的是否为 / 或 /index.html 首页 // ④ 判断用户请求的是否为 /about.html 关于页面 if (url == &#x27;/&#x27; || url == &#x27;/index.html&#x27;) &#123; content = `&lt;h1&gt;首页&lt;/h1&gt;` &#125; else if (url == &#x27;/about.html&#x27;) &#123; content = `&lt;h1&gt;关于页面&lt;/h1&gt;` &#125; // ⑤ 设置 Content-Type 响应头，防止中文乱码 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); // ⑥ 使用 res.end() 把内容响应给客户端 res.end(content);&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;running at http://127.0.0.1:3000&#x27;);&#125;) fs：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//文件系统const fs = require(&#x27;fs&#x27;)//同步读取const fileData = fs.statSync(path) // 后续代码被阻塞 不会继续执行//异步读取 获取到结果后回调执行fs.stat(filepath,(err,info)=&gt;&#123; if(err)&#123; console.log(err) return false &#125; console.log(info)&#125;)//promise方式 代码不会被阻塞fs.promises.stat(filepath).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;)//文件描述符//返回描述符fs.open(filepath,(err,fd //文件描述符（数字）可以通过这个描述符获取文件信息)=&gt;&#123; if(err)=&gt;&#123; console.log(err) return false &#125; //通过描述符获取文件信息 fs.fstat fs.fstat(fd,(err,info)=&gt;&#123; console.log(info//文件信息) console.log(info.isDirectory()//判断是否是文件夹) &#125;)&#125;)//文件读写const str = &#x27;123&#x27;options有两个选项&#x27;flag:w打开文件写入 默认值w+打开文件进行读写 如果不存在则创建并写入r+打开文件进行1读写，如果不存在则抛出异常r打开文件读取，读取时默认值a打开要写入的文件，将流放在文件末尾，如果不存在则创建文件a+打开文件以进行读写，将流放在末尾，如果不存在则创建文件fs.writeFile(&#x27;/1.txt&#x27;,content,&#123;flag:&#x27;a&#x27;,encoding:&#x27;&#x27;&#125;,(err)=&gt;&#123; if(err)&#123; console.log(err) &#125;&#125;)//文件读取 如果不填写encoding，呢嘛返回bufferfs.readFile(&#x27;&#x27;,&#123;encoding:&#x27;utf-8&#x27;&#125;,(err,data)=&gt;&#123; console.log(data) //buffer二进制在不使用encoding的情况下&#125;)//文件夹操作1：创建文件夹const dirname = &#x27;./why&#x27;if(fs.existsSync(dirname) //检测文件夹是否存在)&#123; fs.mkdir(dirname,err =&gt; &#123; console.log(err) &#125;)&#125;fs.mkdir //盲猜可以弄个脚本自动生成组件文件夹名2：读取文件夹中所有文件const readdir(dirname,(err,files)=&gt;&#123; console.log(files)//获取所有文件&#125;)//递归调用读取文件名const getFiles = (dirname)=&gt;&#123; fs.readdir(firname,&#123;withFileTypes:true&#125;,(err,files)=&gt;&#123; console.log(files) file.forEach(item=&gt;&#123; if(item.isDirectory())&#123; const filepath = path.resolve(dirname,item.name) getFiles(filepath) &#125;else&#123; console.log(item.name) &#125; &#125;) &#125;)&#125;getFiles(dirname)3：文件夹重命名fs.rename(旧名称，新名称，err=&gt;&#123; console.log(err)&#125;)fs.rename(&#x27;./why&#x27;,&#x27;./kobe&#x27;,err=&gt;&#123; console.log(err)&#125;) events：123456789101112131415161718192021222324//发出事件与监听事件const EventEmitter = require(&#x27;event&#x27;)const emitter = new EventEmitter()//监听//emitter.addEventLister //addEventListener是on的简写emitter.on(&#x27;click&#x27;,(args)=&gt;&#123; console.log(&#x27;监听到了click事件&#x27;,args)&#125;)//发出emitter.emit(&#x27;click&#x27;,&quot;hao&quot;)//关闭emitter.off(&#x27;事件名&#x27;)//获取信息获取注册的事件console.log(emitter.eventNames())console.log(emitter.listenerCount(&#x27;click&#x27;)) //获取数量console.log(emitter.listeners(&#x27;click&#x27;))emitter.once // 只监听一次emitter.prependListener //将本次放在最前面emitter.removeAllListeners() //移除所有事件 未完待续……","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构","slug":"algorithm1","date":"2022-05-14T07:04:01.000Z","updated":"2022-09-01T06:15:58.958Z","comments":true,"path":"2022/05/14/algorithm1/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/algorithm1/","excerpt":"","text":"数据结构走起！基础+ 栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script&gt; // 数据结构和算法 // 数据结构：数据对象和相关实例元素的各种联系，可以通过相关的函数来给出 // 在计算机中存储和组织数据的方式 // 常见的数据结构 // 队列 树 堆 栈 数组 链表 图 散列表 // 算法：排序算法 // 是一定的指令集 指令描述不依赖于语言 接收一些输入和输出 在一定步骤后结束 // 解决问题的方法 数据结构离不开算法 // 数组 简书笔记 自由的线性结构 任意位置插入和删除 // 栈结构 受限的线性结构 限制数组修改的随意性 只能在栈底或者栈顶添加 进栈和出栈 后进先出 // 只允许表的一端插入和删除 进栈，入栈和压栈 // 栈的应用 函数相互调用 a调用b b调用c a在栈底 b压上去 c在栈顶 执行完以后c b a顺序出栈 // 递归会出现栈的溢出 无限调用自己 // 栈的面试题 // 栈结构的实现 基于数组实现 基于链表实现 // 栈操作 // push栈顶添加新元素 // pop移除栈顶元素 返回被删除的元素 // peek返回栈顶元素 不做任何操作 // isEmpty如果栈里没有任何元素就返回true // size返回元素个数 // toString将栈结构的内容以字符串形式返回 // 栈实现的相关构造函数封装 function Stack()&#123; this.items = [] // push Stack.prototype.push = function(elment)&#123; this.items.push(elment) &#125; // pop Stack.prototype.pop = function()&#123; return this.items.pop() &#125; // peek Stack.prototype.peek =function()&#123; return this.items[this.items.length - 1] &#125; // isEmpty Stack.prototype.isEmpty = function()&#123; return this.items.length === 0 &#125; // size Stack.prototype.size = function()&#123; return this.items.length &#125; // toString Stack.prototype.toString = function()&#123; var result = &#x27;&#x27; for(var i = 0; i &lt; this.items.length; i++)&#123; result +=this.items[i] + &#x27;&#x27; &#125; return result &#125; &#125; let stack = new Stack() stack.push(&#x27;123&#x27;) stack.push(&#x27;12&#x27;) stack.push(&#x27;30&#x27;) stack.pop() stack.pop() console.log(stack) // 栈的应用 十进制转二进制 计算机识别语言是二进制 function getTwo(number)&#123; var stack = new Stack() while(number &gt; 0)&#123; stack.push(number % 2) number = Math.floor(number / 2) &#125; var bind = &#x27;&#x27; while(!stack.isEmpty())&#123; bind += stack.pop() &#125; return bind &#125; console.log(getTwo(100)) console.log(getTwo(200)) console.log(getTwo(1000)) &lt;/script&gt; 队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;script type=&quot;text/javascript&quot;&gt; // 队列结构 受限的线性结构 先进先出 只允许在表的前端进行删除操作 在表的后端进行插入操作 // 类似排队上wc 上完之后走，下一个进来 打印机先打印先出来 // 鲜橙队列 在开发中 为了让任务可以并行处理 通常会开启多个线程 但是会占用过多资源 // 队列的实现 基于数组实现 基于链表实现 链表性能更好 // 队列常见操作 // enqueue(element)向队列尾部添加一个或者多个新的项 // dequeue()移除队列的第一:即排在队列最前面的项 并返回被移除的元素 // front()返回队列第一个元素 队列不作任何变动 // isEmpty()队列为空返回true 反之返回false // size()返回队列包含元素个数 与length相似 // toString()将队列内容转换为字符串形式 function Duilie()&#123; this.items = [] // 插入 this.enqueue = function(element)&#123; this.items.push(element) &#125; // 移除第一个 this.dequeue = function ()&#123; return this.items.shift() &#125; // 返回队列第一个元素 this.front = function()&#123; return this.items[0] &#125; // 判断数组是否为空 this.isEmpty = function()&#123; return this.items.length == 0 &#125; // 返回数组长度 this.size = function()&#123; return this.items.length &#125; // 将队列数据转化为字符串 this.toString = function ()&#123; var newarr = [] for(var i = 0; i &lt; this.items.length; i++)&#123; newarr.push(this.items[i] + &#x27;&#x27;) &#125; return newarr &#125; &#125; let duilie = new Duilie() duilie.enqueue(10) duilie.enqueue(21) duilie.enqueue(31) console.log(duilie.dequeue()) console.log(duilie.front()) console.log(duilie.isEmpty()) console.log(duilie.size()) console.log(duilie.toString()) console.log(duilie.items) console.log(&#x27;--------&#x27;) // 击鼓传花 一群人玩游戏 某个人数到某个数字就淘汰，接着循环数 最后留下的那个人的索引值 function winner(list,num)&#123; var que = new Duilie() for(var i = 0; i &lt;list.length; i++)&#123; que.enqueue(list[i]) &#125; while(que.size() &gt; 1)&#123; for(var i = 0; i &lt; num - 1; i++)&#123; que.enqueue(que.dequeue()) &#125; que.dequeue() &#125; console.log(que.size()) var endname = que.front() return list.indexOf(endname) &#125; winner([&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;],3) console.log(&#x27;----------&#x27;) &lt;/script&gt; 优先级队列12345678910111213141516171819202122232425262728293031323334353637&lt;script type=&quot;text/javascript&quot;&gt; function Youxian()&#123; function Neibu(element,youxianji)&#123; this.element = element this.youxianji = youxianji &#125; this.items = [] this.enqueqe = function(element,youxianji)&#123; var neibu = new Neibu(element,youxianji) // 判断队列是否为空 if(this.items.length == 0)&#123; this.items.push(neibu) &#125; else &#123; // 判断有没有插入 var added = false for(var i = 0; i &lt; this.items.length; i++)&#123; if(neibu.youxianji &lt; this.items[i].youxianji)&#123; this.items.splice(i,0,neibu) added = true break &#125; &#125; if(!added)&#123; this.items.push(neibu) &#125; &#125; &#125; &#125; let youxian = new Youxian() youxian.enqueqe(&#x27;a&#x27;,10) youxian.enqueqe(&#x27;b&#x27;,200) youxian.enqueqe(&#x27;c&#x27;,66) youxian.enqueqe(&#x27;d&#x27;,100) for(var i = 0; i &lt; youxian.items.length; i++)&#123; console.log(youxian.items[i]) &#125; &lt;/script&gt; 链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;script type=&quot;text/javascript&quot;&gt; // 链表和数组一样 具有存储数据的功能 但是实现的机制不一样 // 数组的创建需要申请一段连续的内存空间 当数组不能满足容量需求时 需要扩容 申请更大空间复制内容 // 在数组开头和中间插入数据的成本很高 需要进行大量元素的位移 // 链表的元素在内存中不必是连续的存储 // 链表的每个元素由一个存储元素的本身的节点和一个指向下一个元素的引用(有些语言称为指针或者连接)组成 // 与数组对比 优点 // 内存空间不必是连续的 可以充分利用计算机内存 实现灵活的内存动态管理 // 链表不必再创建时就确定大小 大小可以无限延伸 // 链表再插入和删除时 时间复杂度可以达到O(1)。相对数组效率高很多 // 聊链表缺点 // 链表访问任何一个元素时 需要从头开始访问 无法跳过访问 数组可以通过下标索引的方式访问 // 一个一个访问直到找到相应的元素 // 封装单向链表结构 function Lianbiao()&#123; function Node(data)&#123; this.data = data this.next = null &#125; // 链表头部是空 this.head = null // 记录链表长度 this.length = 0 // 链表的常见操作 // append(element)向列表尾部添加一个新的项 this.append = function (element)&#123; var newnode = new Node(element) if(this.length == 0)&#123; // 判断第一个节点 this.head = newnode &#125;else&#123; // 判断最后一个节点 var current = this.head while(current.next)&#123; current = current.next &#125; current.next = newnode &#125; this.length += 1 &#125; // insert(position,element)向链表的特定位置插入项 this.insert = function (position,element)&#123; // 负数和边界判断 if(position &lt; 0 || position &gt; this.length) return false var newnode = new Node(element) // 判断插入位置是否是第一个 if(position == 0)&#123; newnode.next = this.head this.head = newnode &#125;else&#123; // position大于0 var index = 0 var current = this.head var previous = null while(index++ &lt; position)&#123; previous = current current = current.next &#125; newnode.next = current previous.next = newnode &#125; this.length += 1 return true &#125; // get(position)获取对应位置元素 this.get = function (position)&#123; if(position &lt; 0 || position &gt;= this.length) return null // 获取对应data数据 var current = this.head var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; return current.data &#125; // indexOf(element)返回元素在列表中的索引 如果列表中没有该元素则返回-1 this.indexOf = function(element)&#123; var current = this.head var index = 0 while(current)&#123; if(current.data == element)&#123; return index &#125; current = current.next index +=1 &#125; return -1 &#125; // update(position,newdata)修改某个位置的元素 this.update = function(position,newdata)&#123; if(position &lt; 0 || position &gt;= this.length) return false // 查找正确节点 var current = this.head var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; current.data = newdata return true &#125; // removeAt(position)从列表的特定位置移除一项 this.removeAt = function(position)&#123; // 越界判断 if(position &lt; 0 || position &gt;= this.length) return null var current = this.head if(position == 0)&#123; this.head = this.head.next &#125;else&#123; var index = 0 var previous = null while(index++ &lt; position)&#123; previous = current current = current.next &#125; previous.next = current.next &#125; this.length -= 1 return current.data &#125; // remove(element)从列表中移除一项 this.remove = function(element)&#123; var position = this.indexOf(element) return this.removeAt(position) &#125; // isEmpty()如果链表中不包含任何元素返回true 链表长度&gt;0返回false this.isEmpty = function()&#123; return this.length == 0 &#125; // size()返回链表包含的元素个数 this.size = function()&#123; return this.length &#125; // toString() this.toString = function()&#123; var current = this.head var liststring = &#x27;&#x27; while(current)&#123; liststring += current.data + &#x27; &#x27; // 防止死循环 current = current.next &#125; return liststring &#125; &#125; let lianbiao = new Lianbiao() lianbiao.append(1) lianbiao.append(2) lianbiao.append(3) lianbiao.insert(1,&#x27;111&#x27;) lianbiao.insert(2,&#x27;222&#x27;) console.log(lianbiao.get(1)) console.log(lianbiao.get(2)) console.log(lianbiao.indexOf(&#x27;111&#x27;)) console.log(lianbiao.indexOf(&#x27;222&#x27;)) console.log(lianbiao.update(1,&#x27;333&#x27;)) console.log(lianbiao.removeAt(1)) console.log(lianbiao.remove(&#x27;222&#x27;)) console.log(lianbiao.isEmpty()) console.log(lianbiao.size()) console.log(lianbiao) &lt;/script&gt; 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;script type=&quot;text/javascript&quot;&gt; // 单向链表 // 只能从头遍历到尾或者丛尾遍历到头 过程是单向的 实现原理是上一个链表中有一个指向下一个的引用 // 缺点 轻松到达下一个节点 但是无法快速返回上一个节点 // 双向链表 // 即可从头遍历到尾 也可从尾遍历到头， 一个节点既有向前连接的引用，也有向后链接的引用 // 缺点：插入删除某个节点时 需要处理四个引用 实现麻烦 占用内存空间更大些 但是使用起来方便 function Shuangxiang()&#123; // 头和尾都是null this.head = null this.tail = null this.length = 0 function Node(data)&#123; this.prev = null this.data = data this.next = null &#125; // append(element)列表尾部追加 this.append = function(data)&#123; var node = new Node(data) if(this.length == 0)&#123; this.head = node this.tail = node &#125;else&#123; // 尾部追加 // 倒数第二项 node.prev = this.tail this.tail.next = node this.tail = node &#125; this.length += 1 &#125; // insert(position,element)特定位置插入 this.insert = function(position,data)&#123; if(position &lt; 0 || position &gt; this.length) return false var node = new Node(data) if(this.length == 0)&#123; this.head = node this.tail = node &#125;else&#123; // 判断position是否为0 插入开头 if(position == 0)&#123; this.head.prev = node node.next = this.head this.head = node // 插入结尾 &#125; else if (position == this.length)&#123; node.prev = this.tail this.tail.next = node this.tail = node &#125; else &#123; // 插入中间 var current = this.head var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; // 修改指针 node.next = current node.prev = current.prev current.prev.next = node current.prev = node &#125; this.length += 1 return true &#125; &#125; // get(position)获取对应位置元素 this.get = function(position)&#123; if(position &lt; 0 || position &gt; this.length)return null // this.length / 2 &gt; position 从头遍历 // this.length / 2 &lt; position 从后向前遍历 var current = this.head var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; return current.data &#125; // indexOf(element)返回对应元素索引 this.indexOf = function(element)&#123; var current = this.head var index = 0 while(current)&#123; if(current.data == element)&#123; return index &#125; current = current.next index += 1 &#125; return -1 &#125; // update(position,element)修改某个位置的元素 this.update = function(position,element)&#123; if(position &lt; 0 || position &gt; this.length) return false // this.length / 2 &gt; position 从头遍历 // this.length / 2 &lt; position 从后向前遍历 var current = this.head var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; // 修改信息 current.data = element return true &#125; // remove(element)移除某个元素 this.remove = function(element)&#123; var index = this.indexOf(element) return this.removeAt(index) &#125; // removeAt(position)移除某个位置元素 this.removeAt = function(position)&#123; if(position &lt; 0 || position &gt;= this.length) return null var current = this.head if(this.length == 0)&#123; this.head = null this.tail = null &#125;else&#123; // 判断是否删除的是第一个 if(position == 0)&#123; this.head.next.prev = null this.head = this.head.next &#125;else if(position == this.length - 1)&#123; current = this.tail this.tail.prev.next = null this.tail = this.tail.prev &#125;else&#123; var index = 0 while(index++ &lt; position)&#123; current = current.next &#125; current.prev.next = current.next current.next.prev = current.prev &#125; &#125; this.length -= 1 return current.data &#125; // isEmpty()是否为空 this.isEmpty = function()&#123; return this.length == 0 &#125; // size()返回链表元素个数 this.size = function ()&#123; return this.length &#125; // toString() this.toString = function()&#123; return this.forwardString() &#125; // forwardString()正向遍历的节点字符串形式 this.forwardString = function()&#123; var current = this.head var resultString = &#x27;&#x27; while(current)&#123; resultString += current.data + &#x27; &#x27; current = current.next &#125; return resultString &#125; // backwordString()反向遍历的节点字符串形式 this.backwordString = function()&#123; var current = this.tail var resultString = &#x27;&#x27; while(current)&#123; resultString += current.data + &#x27; &#x27; current = current.prev &#125; return resultString &#125; // 获取链表第一个head this.gethead = function ()&#123; return this.head &#125; // 获取链表最后一个tail this.gettail = function ()&#123; return this.tail &#125; &#125; let shuangxiang = new Shuangxiang() shuangxiang.append(&#x27;1&#x27;) shuangxiang.append(&#x27;2&#x27;) shuangxiang.append(&#x27;3&#x27;) shuangxiang.insert(3,&#x27;111&#x27;) shuangxiang.insert(4,&#x27;221&#x27;) console.log(shuangxiang.forwardString()) console.log(shuangxiang.backwordString()) console.log(shuangxiang.toString()) console.log(shuangxiang.get(2)) console.log(shuangxiang.get(3)) console.log(shuangxiang.indexOf(&#x27;101&#x27;)) console.log(shuangxiang.indexOf(&#x27;1&#x27;)) console.log(shuangxiang.indexOf(&#x27;3&#x27;)) console.log(&#x27;------&#x27;) console.log(shuangxiang.update(1,&#x27;1010&#x27;)) // alert(shuangxiang) console.log(shuangxiang.removeAt(1)) console.log(shuangxiang.removeAt(0)) console.log(shuangxiang.remove(&#x27;221&#x27;)) console.log(shuangxiang.toString()) console.log(shuangxiang) &lt;/script&gt; 集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;script type=&quot;text/javascript&quot;&gt; // 集合 集合最常见的方式是哈希表 由无序的不能重复的元素构成 // 一种特殊的数组 里面的元素没有顺序 不能重复 不能通过下标值访问 相同的对象只会存在一份 // ea6的set已实现 此处自己封装 function Set()&#123; // 属性 this.items = &#123;&#125; // 操作 // add(value)添加新的项 this.add = function(value)&#123; if(this.has(value)) return false this.items[value] = value return true &#125; // remove(value)移除一个项 this.remove = function(value)&#123; if(!this.has(value))return false delete this.items[value] return true &#125; // has(value)包含值返回tru 反之返回false this.has = function(value)&#123; return this.items.hasOwnProperty(value) &#125; // clear()清空 this.clear = function()&#123; this.items = &#123;&#125; &#125; // size()类似数组length this.size = function()&#123; return Object.keys(this.items).length &#125; // values()返回包含所有值的数组 this.values = function()&#123; return Object.keys(this.items) &#125; // 集合间操作 // 并集 返回包含两个集合中所有元素的新集合 this.union = function(otherset)&#123; // this.items已经是一个集合了 联合otherset集合 var unionset = new Set() var values = this.values() for(var i = 0; i &lt; values.length; i++)&#123; unionset.add(values[i]) &#125; values = otherset.values() for(var i = 0; i &lt; values.length; i++)&#123; unionset.add(values[i]) &#125; return unionset &#125; // 交集 返回包含两个集合中所有共有元素的集合 this.intersection = function(otherset)&#123; var intersection = new Set() var values = this.values() for(var i = 0; i &lt; values.length; i++)&#123; var item = values[i] if(otherset.has(item))&#123; intersection.add(item) &#125; &#125; return intersection &#125; // 差集 返回一个包含所有存在于第一个集合且不存在于第二个集合的新元素 this.difference = function(otherset)&#123; var difference = new Set() var values = this.values() for(var i = 0; i &lt; values.length; i++)&#123; var item = values[i] if(!otherset.has(item))&#123; difference.add(item) &#125; &#125; return difference &#125; // 子集 验证一个给定集合是否是另一个集合的子集 this.subset = function(otherset)&#123; var subset = new Set() var values = this.values() for(var i = 0; i &lt; values.length; i++)&#123; var item = values[i] if(!otherset.has(item))&#123; return false &#125; &#125; return true &#125; &#125; let set = new Set() set.add(&#x27;1&#x27;) set.add(&#x27;2&#x27;) console.log(set.has(&#x27;1&#x27;)) // set.clear() set.remove(&#x27;1&#x27;) console.log(set.remove(&#x27;3&#x27;)) console.log(set.values()) console.log(set.size()) console.log(&#x27;--------&#x27;) set.add(&#x27;hao&#x27;) set.add(&#x27;ge&#x27;) console.log(set.values()) // 并集 var set2 = new Set() set2.add(&#x27;111&#x27;) set2.add(&#x27;222&#x27;) console.log(set2.items) var uniset = set.union(set2) console.log(uniset.values()) // 交集 var inter = new Set() inter.add(&#x27;1&#x27;) inter.add(&#x27;2&#x27;) inter.add(&#x27;3&#x27;) var inter2 = new Set() inter2.add(&#x27;1&#x27;) inter2.add(&#x27;2&#x27;) console.log(inter.values()) console.log(inter.intersection(inter2).values()) // 差集 var differ = new Set() differ.add(&#x27;9&#x27;) differ.add(&#x27;10&#x27;) console.log(inter2.values()) console.log(inter2.difference(differ).values()) // 子集 console.log(set.subset(differ)) console.log(set.subset(set)) &lt;/script&gt; 字典12345&lt;script type=&quot;text/javascript&quot;&gt; // 字典 : js默认有数组 es6添加的集合和字典 // 键值对的对应关系 通过key取出value key不可以重复 value可以重复 &lt;/script&gt; 哈希表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313// 哈希表 js中并没有哈希表 但是更够实现 理论知识多 代码少// 基于数组实现 快速插入删除查找 哈希表的速度比树更快 基本可以瞬间查找到元素// 相对于树来说编码容易些// 数组进行插入操作时 效率比较低// 查找时：如果基于下标查找效率高 如果基于内容查找效率很低// 数组进行删除操作 效率低 各种位移操作// 数组进行修改和查找差不多// 哈希表相对于数组的不足// 数据没有顺序 不能以一种固定的从小到大或者从大到小的顺序遍历元素// key值不允许重复 不能使用相同的key保存不同的值// 哈希表结构是数组 特别的地方是对下标值的变换 称为哈希函数// 通过哈希函数可以获取到HashCode// 公司员工存储// 数组结构存储一个个员工信息 下标效率较高 定义员工编号查找// 链表结构 插入和删除效率比较高 从头到尾查找效率低// 联系人和电话存储// 存储单词// 将字符串转换为下标值方案 字母文字转数字// 字符编码 ASCII编码 a是97 b是98，，，122是z GBXXXX GBK GB18030十万中文文字// 单独设置本地区域独特文字的编码一旦上了国际就不行 因此Unicode万国码出来了utf-8 utf-32 // 设计自己的编码 方便理解 // 方案1:吧单词每个字符的编码求和 cats是3+1+20+19=43 那么43就作为cats单词的下标存在于数组中// 名称key不会重复 但是编码值相加下标值可能会重复 后来的数据必然会覆盖 下标值存储很多值不合理 // 方案2:幂的连乘 7654 = 7*10的3次方 + 6*10的2次方 + 5*10的1次方 + 4// 基本可以保持数据的唯一性 不会和别的单词重复 // cats = 3 * 26(自己编码的26个字符)的3次幂 + 1 * 26的2次幂 + 20 * 27 + 17 = 60337// 但是如果是zzzzzzzz的话那么下标值就是70000000000.。 创建大的下标值的数组没有意义// 会存在很多下标值是空的位置 虽然保证了数字的唯一性 但是对空间造成了很大的浪费性 // 改进方案2 hash化 哈希化 把幂的连乘方案中得到的巨大的整数范围压缩到可接受的范围内// 0-70000000000压缩到0-100000 使用取余操作符 也会存在一定的重复性 后续解决// 哈希化 将大数字压缩成规定范围下标值// 哈希函数 将字母文字单词转换为大数字的函数// 哈希表 将最终得到的数字插入数组 整体结构的封装称之为哈希表 // 什么事冲突 下标值相同 已存在 即使概率小 也要考虑解决方案 // 常见两种解决方式// 1：链地址法 / 拉链法// 2：开放地址法// 1链地址法// 将相同下标值的元素存放在链表（或者数组）中，每个数组单元存储的不再是单个数据 而是一个链表// 如果插入前端 使用链表 插入后端使用数组 // 2:开放地址法 寻找空白的单元格添加重复的数据// 探索空白位置有三种方法 查找空位厕所 找坑填坑// 线性检测法 如果单元格存在数据 index + 1依次向后查找 删除元素后 不能将下表设置为null // 会影响之后查询的其他操作 所以通常删除一个数据后 会进行特殊处理（将下标值设置为-1）// 线性检测有问题 // 聚集 一连串的相同下标值向后查找填充后续多个单元单元就是聚集 影响hash表的性能 查询/删除/插入 // 二次检测法 优化的是探测的步长 x + 1 x + 3相隔多个步数探测 一次性探测较远距离 避免聚集影响 // 问题：也会存在累加步数到达相同位置的元素 还是会影响效率 因此要设置每个人的步长都不一样// 再哈希法 // 为了消除线性检测和二次检测中步长的问题// 需要一种方法产生一种依赖关键字的探测序列 而不是每个关键字都一样 不同的关键字即使映射到// 相同的数组下标 也可以使用不同的探测序列 // 把关键字用另外一个函数再做一个哈希化 用这次哈希化的结果作为步长 对于指定的关键字// 步长在整个探测中是不变的 不过不同的关键字使用不同的时长// 特点// 和第一个哈希函数不相同 不能输出为0 否则将没有步长 每次探测都是原地踏步 算法就进入死循环 // 计算机专家已经设计出了工作很好的哈希函数// stepSize = constant - （key % constant）// 其中constant是质数 且小于数组的容量// 例如stepSize = 5 - （key % 5）满足需求 那么结果不可能为0// 哈希化的效率// 哈希化执行插入和搜索效率是非常高的 如果没有冲突效率更高 如果存在冲突 那么查询事件就依赖后来的探测长度// 平均探测长度以及平均存取时间 取决于装填因子 随着装填因子变大 探测长度也越长// 随着装填因子变大 效率下降 在不同开发地址法方案中比链地址法更严重// 装填因子 表示当前哈希表中已经包含的数据项和整个哈希表长度的比值// 装填因子 = 总数据项 / 哈希表长度// 开放地址法的最大装填因子是1 必须找到空白单元格才能放入 后续效率也会变低// 链地址法的装填因子可以大于1 因为拉链法可以无线延伸下去 但是后续效率会变低// 优秀的哈希函数// 哈希表的优点在于速度 提高速度的一个方法就是让哈希函数中尽量少有乘法和除法因为他们性能低// 快速获取hashCode值 无论是链地址法还是开放地址法 当多个元素映射到同一个位置都会影响效率 // 所以 优秀的哈希函数尽量会把元素映射到不同的位置 让元素在哈希表中均匀的分布// 3*2的10次方 + 3*2的9次方 + 3*2的8次方 + 3*2的7次方 。。。 效率低下// 优化：霍纳法则（秦九韶算法）// 大O表示法从O(N的2次方)变成了O(N)// 大O表示法：（N的2次方 + n） / 2 随着数据增加查找数据的时间的变化趋势// 在需要使用常量的地方尽量使用质数 // 质数使用的位置// 哈希表的长度 N次幂的底数// 设计哈希函数// 1：将字符转换为比较大的数字hashCode// 2：将大的数字压缩到数组范围内function hashFunc(str,size)&#123; // 1:定义hashCode变量 var hashCode = 0 // 2:霍纳算法计算hashCode值 for(var i = 0;i &lt; str.length;i++)&#123; // 获取该字符unicode // str.charCodeAt(i) hashCode = 37 * hashCode + str.charCodeAt(i)&#125;// 取余操作var index = hashCode % sizeconsole.log(&#x27;index&#x27;,index)&#125;hashFunc(&#x27;cats&#x27;,7)hashFunc(&#x27;catss&#x27;,7)hashFunc(&#x27;catsss612&#x27;,7)// 采用链地址法实现hash表格function hashTable()&#123;// 属性this.storage = [] //存放相关元素this.count = 0 //表示已经存在多长的数据this.limit = 7 //标记数组中一共可以存多少数据// 装填因子loadFactor 如果超过0.75就需要对数组进行扩容 小于0.25还需要变小压缩// 方法// 哈希函数hashTable.prototype.hashFunc = function (str,size)&#123;// 1:定义hashCode变量var hashCode = 0// 2:霍纳算法计算hashCode值for(var i = 0;i &lt; str.length;i++)&#123;// 获取该字符unicode// str.charCodeAt(i)hashCode = 37 * hashCode + str.charCodeAt(i)&#125;// 取余操作var index = hashCode % sizereturn index&#125;// 插入修改hashTable.prototype.put = function(key,value)&#123;// 1：根据key获取索引值 将数据插入对应位置var index = this.hashFunc(key,this.limit)// 2：根据索引值取出桶 判断桶是否存在 不存在就创造桶，放在该位置var bucket = this.storage[index]if(bucket == null)&#123;bucket = []this.storage[index] = bucket&#125;// 3：一定有桶以后判断是修改还是添加操作 如果有值了那么就修改值 如果没有执行添加操作// 修改操作for(var i = 0; i &lt; bucket.length; i++)&#123;// 从数组中线性查找var tuple = bucket[i]//tuple是桶中的每一个数组if(tuple[0] == key)&#123;tuple[1] = valuereturn&#125;&#125;// 新增操作bucket.push([key,value])this.count += 1// 判断是否需要扩容操作if(this.count &gt; this.limit * 0.75)&#123;// 判断扩容完成是否是质数var newSize = this.limit * 2var newZhishu = this.getZhishu(newSize)this.resize(newSize)&#125;&#125;// 查找获取hashTable.prototype.get = function(key)&#123;// 1：根据key获取索引值var index = this.hashFunc(key,this.limit)// 2：根据index获取对应桶bucket 判断bucket是否为空var bucket = this.storage[index]if(bucket == null)&#123;return null&#125;// 循环遍历桶中每一个数值的key是否和传入的key相同for(var i = 0; i &lt; bucket.length; i++)&#123;var tuple = bucket[i]if(tuple[0] == key)&#123;// 找到对应key返回valuereturn tuple[1]&#125;&#125;// 还没找到return null&#125;// 删除操作hashTable.prototype.remove = function(key)&#123;// 1：根据key获取索引值var index = this.hashFunc(key,this.limit)// 2：根据index获取对应桶bucket 判断bucket是否为空var bucket = this.storage[index]// 不存在直接返回nullif(bucket == null)&#123;return null&#125;// 3：循环遍历桶中每一个数值的key是否和传入的key相同for(var i = 0; i &lt; bucket.length; i++)&#123;var tuple = bucket[i]if(tuple[0] == key)&#123;// 找到对应key删除tuple.splice(i,1)this.count--return tuple[1]// 如果storage过长 内部数据太少 那么就需要缩小容量 此处应该不会执行 放置位置有错误if(this.limt &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25)&#123;// 缩小为质数var newSize = Math.floor(this.limit / 2)var newZhishu = this.getZhishu(newSize)this.resize(newSize)&#125;&#125;&#125;// 依然没有找到return null&#125;// 其他操作// 是否为空hashTable.prototype.isEmpty = function()&#123;return this.count == 0&#125;// 获取hash表中元素的个数hashTable.prototype.size = function()&#123;return this.count&#125;// 哈希表扩容思想// 因为使用的是链地址法 填充因子可以大于1 所以这个hash表可以无线填充新数据// 但是随着数据量的增多 每一个index对应的bucket就会越来越长 也就会造成效率的降低 // 所以要在适当的时候对数组进行扩容 比如扩容两倍// 但是这种情况下 所有的数据项一定要同时进行修改 重新调用hash函数获取不同位置 虽然耗时 但是如果扩容这是必须的// 填充因子&gt;0.75时扩充// 实现扩容 取出所有桶和元素 插入新的storage中通过put插入// 容量质数 容量最好是质数 虽然链地址法中没有开放地址法长度是质数重要 但是还是有好处的// 如何判断一个数是质数？（面试题）质数特点：也称为素数 质数表示大于1的自然数中 只能被1和自己整除// function isZhishu(num)&#123;// 这样的写法效率低// for(var i = 2; i &lt; num; i++)&#123;// if(num % i == 0)&#123;// return false 不是质数// &#125;// &#125;// return true 是质数// 更高效的方式 不需要从2判断到num-1 判断开平方根 面试选这个// var temp = parseInt(Math.sqrt(num))//求平方根// for(var i = 2; i &lt;= temp; i++)&#123;// if(num % i == 0)&#123;// return false// &#125;// &#125;// return true// &#125;// 扩容操作 还需实现扩容大小limit恒为质数hashTable.prototype.resize = function(newlimit)&#123;// 1:保存旧storagelet oldstorage = this.storage// 2:重置所有属性this.count = 0this.limit = newlimit// 3:遍历oldStorage中所有的bucketfor(var i = 0; i &lt; oldstorage.length; i++)&#123;// 3.1:取出所有桶var bucket = oldstorage[i]if(bucket == null)&#123;continue&#125;// 3.2buckey有数据重新插入for(var j = 0; j &lt; bucket.length; j++)&#123;var tuple = bucket[j]// 4:插入新的storagethis.put(tuple[0],tuple[1])&#125;&#125;&#125;// 判断是否是质数hashTable.prototype.isZhishu = function()&#123;var temp = parseInt(Math.sqrt(num))//求平方根for(var i = 2; i &lt;= temp; i++)&#123;if(num % i == 0)&#123;return false&#125;&#125;return true&#125;// 获取质数方法hashTable.prototype.getZhishu = function(num)&#123;// 判断num是否是质数 如果不是向后查找while(!this.isZhishu(num))&#123;num++&#125;return num&#125;&#125;let table = new hashTable()// 最后的形式 [[[key,value],[key,value],[key,value]],[[key,value],[key,value]],[]]// 测试hash表table.put(&#x27;abc&#x27;,&#x27;321&#x27;)table.put(&#x27;nba&#x27;,&#x27;521&#x27;)table.put(&#x27;mba&#x27;,&#x27;1&#x27;)table.put(&#x27;aaa&#x27;,&#x27;13&#x27;)table.put(&#x27;bba&#x27;,&#x27;12&#x27;)console.log(&#x27;获取&#x27;,table.get(&#x27;abc&#x27;))console.log(&#x27;删除&#x27;,table.remove(&#x27;bba&#x27;))console.log(&#x27;为空&#x27;,table.isEmpty())console.log(&#x27;size长度&#x27;,table.size())console.log(table) 树123456789101112131415161718192021222324252627282930313233343536// 树的优点 // 数组的优点缺点 // 优点：下标值访问效率高 缺点：需要先对数组进行排序生成有序数组 才能提高查找效率 在插入和删除时会有大量位移操作效率低 // 链表的优点和缺点 // 优点：链表的插入和删除效率都很高 // 缺点：查找效率很低 需要从头开始依次访问链表中的每个数据项 直到找到 即使插入删除效率高 删除和插入还是要从头遍历 // 哈希表优点和缺点 // 优点：插入删除查询效率高 缺点：空间利用率不高 底层使用数组 并且某些单元没有被利用 元素时无序的不能按照固定顺序遍历访问 // 不能快速找到hash表中最大值或者是最小值 // 树结构 // 效率一般没有哈希表高 弥补了一些结构的缺点 模拟某些场景树结构会更加方便 因为树结构非线性 一对多比如文件的目录结构 // 每个结构都有各自适合的应用场景 // 树结构相关概念 术语 // 树：由n(n&gt;=0)个节点构成的有限集合 // 当n=0时称为空树 n&gt;0的非空树具有一下性质 // 树中有一个称为根(Root)的特殊节点 用r表示 // 其余节点可分为m(m&gt;0)个互不相交的有限集合T1，T2，T3，，，，，TM 其中每个集合本身又是一棵树 称为原来树的子数 子树SubTree // 术语 // 1：节点的度（Degree）：节点的子树个数 // 2：树的度：树的所有节点中最大的度数 // 3：叶节点（Leaf）度为0的节点（也成为了子节点）没有子节点的节点 // 4：父节点（Parent）有子树的节点是其子树的根节点的父节点 // 5：子节点（Child）若A节点是B节点的父节点 则称B节点是A节点的子节点 子节点也称为孩子节点 // 6：兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点 // 7：路径和路径长度：从节点n1到nk的路径为一个节点序列n1，n2，，，，nk，ni是ni+1的父节点，路径所包含边的个数为路径的长度 // 8：节点的层次（Level）：规定根节点在1层，其他任一节点的层数是其父节点的层数+1 // 9：树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度 // 树的表示方式 // 儿子兄弟表示法 // 二叉树：如果每个节点最多只有两个节点 这样的树就称为二叉树 所有的树都可以表示成二叉树的形式 二叉树可以为空 可以没有节点 // 若不为空 则它是由根节点和左子树TL和右子树TR的两个不想交的二叉树组成 // Element // left | right 二叉树123456789101112131415161718192021222324252627// 二叉树 // 二叉树形态 // 一个二叉树第i层的最大节点数为2的(i-1)次方 i&gt;=1 // 深度为k的二叉树有最大节点总数为 2的(K-1)次方 k&gt;=1 // 对任何非空二叉树T，若n0表示叶节点的个数 n2是度为2的非叶节点个数 那么两者满足关系n0 = n2 + 1 // 完美二叉树 也称为满二叉树 除了最下层的叶节点外 每层节点都有2个子节点 就构成了满二叉树 // 完全二叉树 除了最后一层外 其他各层的节点数都达到最大个数 // 且最后一层从左向右的叶节点持续存在 只缺右侧若干节点 // 完美二叉树是特殊的完全二叉树 // 二叉树的存储 常见方式是数组和链表 // 使用数组 完全二叉树 从上到下 从左到右顺序存储 // 非完全二叉树需要转换成完全二叉树才能按照上面方式存储 但是会造成很大的空间浪费 // 二叉树常见方式是链表 // 每个节点封装成一个Node，Node中包存储的数据，左节点的引用，右节点的引用 // left | data | right // 二叉搜索树(BST，Binary Search Tree) | 二叉排序树 | 二叉查找树 // 在二叉树基础上加了一些限制 // 二叉搜索树是一颗二叉树 可以为空 // 如果不为空需要满足以下性质 // 1：非空左子树的所有键值小于其根节点的键值 // 2：非空右子树的所有键值大于其根节点的键值 // 3：左右子树本身也都是二叉搜索树 // 特点：较小值保存在左节点 较大值保存在右节点 查找效率非常高 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279&lt;script type=&quot;text/javascript&quot;&gt; // 二叉搜索树实现 // 封装保存每一个节点的类Node 该类包含三个属性 节点对应的key 指向的左子树 右子树 // 该函数只需要保存根节点即可 其他节点都可通过根节点找到 function BinarySearchTree()&#123; // 根节点 this.root = null // 内部节点类 function Node(key)&#123; this.key = key this.left = null this.right = null &#125; // 插入新的键 BinarySearchTree.prototype.insert = function (key)&#123; // 1根据key创建节点 var newNode = new Node(key) // 2判断根节点是否有值 如果没有值就将该node作为根节点 如果有值就个根节点对比大小 if(this.root == null)&#123; // 如果没有值就将该node作为根节点 this.root = newNode &#125;else&#123; // 比较大小 // 取出根节点的右节点和该newNode比较 this.insertNode(this.root,newNode) &#125; &#125; // 内部方法，自己调用 node是比较的对象 newnode是插入的对象 BinarySearchTree.prototype.insertNode = function(node,newNode)&#123; if(newNode.key &lt; node.key)&#123; // 向左查找 if(node.left == null)&#123; // 左节点为空 node.left = newNode &#125;else&#123; // 左节点不为空 继续比较 this.insertNode(node.left,newNode) &#125; &#125;else&#123; // 向右查找 if(node.right == null)&#123; // 左节点为空 node.right = newNode &#125;else&#123; // 左节点不为空 继续比较 this.insertNode(node.right,newNode) &#125; &#125; &#125; // 查找一个键 搜索特定key 如果存在返回true 不存在返回false BinarySearchTree.prototype.search = function (key)&#123; // 获取根节点 var node = this.root while(node != null)&#123; if(key &lt; node.key)&#123; node = node.left &#125;else if(key &gt; node.key)&#123; node = node.right &#125;else&#123; return true &#125; &#125; return false &#125; // 遍历方式 针对所有树(每个树都能转换成二叉树) 不止二叉搜索树 // 访问每一个节点做出操作 先/中/后还有层序遍历但是很少 // 先序遍历是先遍历根节点 再遍历左子树 右子树 // 后序遍历是先遍历右子树 再遍历左子树 根节点 // 中序遍历是先遍历左子树 再遍历根节点 再遍历右子树 // 通过中序遍历方式遍历所有节点 BinarySearchTree.prototype.inOrderTraverse = function (handler)&#123; this.inOrderTraverseNode(this.root,handler) &#125; // 封装的内部中序遍历递归方法 BinarySearchTree.prototype.inOrderTraverseNode = function (node,handler)&#123; if(node != null)&#123; // 处理经过节点的左子节点 this.inOrderTraverseNode(node.left,handler) // 处理经过的节点 handler(node.key) // 处理经过节点的右子节点 this.inOrderTraverseNode(node.right,handler) &#125; &#125; // 通过先序遍历方式遍历所有节点 先访问根节点 再遍历左子树 再遍历右子树 BinarySearchTree.prototype.preTraverse = function (handler)&#123; this.preTraverseNode(this.root,handler) &#125; // 封装的内部先序遍历递归方法 BinarySearchTree.prototype.preTraverseNode = function (node,handler)&#123; if(node != null)&#123; // 处理经过的节点 handler(node.key) // 处理经过节点的左子节点 this.preTraverseNode(node.left,handler) // 处理经过节点的右子节点 this.preTraverseNode(node.right,handler) &#125; &#125; // 通过后序遍历方式遍历所有节点 先访问根节点 再遍历右子树 再遍历左子树 BinarySearchTree.prototype.postTraverse = function (handler)&#123; this.postTraverseNode(this.root,handler) &#125; // 封装的内部后序遍历递归方法 BinarySearchTree.prototype.postTraverseNode = function (node,handler)&#123; if(node != null)&#123; // 处理经过节点的左子节点 this.preTraverseNode(node.left,handler) // 处理经过节点的右子节点 this.preTraverseNode(node.right,handler) // 处理经过的节点 handler(node.key) &#125; &#125; // 返回树中最小的值/键 BinarySearchTree.prototype.min = function ()&#123; var node = this.root while(node != null &amp;&amp; node.left != null)&#123; node = node.left &#125; return node.key &#125; // 返回树中最大的值/键 BinarySearchTree.prototype.max = function ()&#123; var node = this.root while(node != null &amp;&amp; node.right != null)&#123; node = node.right &#125; return node.key &#125; // 从树中移除某个键 // 需要考虑仨种情况 // 该节点是叶节点 没有子节点 比较简单 节点left和right都为空 设置父元素的left或者right为null // 还要考虑该节点是否是根节点 如果只有单独的根 直接删除即可 // 该节点有一个子节点 // 直接让父级跨级指向下一个 // 给节点有两个子节点 BinarySearchTree.prototype.remove = function (key)&#123; // 先查找到节点 如果没找到不需要删除 找到要删除的节点 粉三种情况 // 寻找节点 // 1:定义变量保存信息 var current = this.root var parent = null // 是否是current的左子节点 var isleft = true // 开始寻找节点 while(current.key != key)&#123; parent = current // 叶节点 if(key &lt; current.key)&#123; isleft = true current = current.left &#125;else&#123; isleft = false current = current.right &#125; // 还有一种情况 已经找到了最后一层但是依旧没找到==key if(current == null) return false &#125; // 2:根据对应情况删除节点 根据几种情况删除 // 找到了current.key = key 还有种可能没有找到 // 2.1删除的节点是叶子节点 考虑根节点 if(current.left == null &amp;&amp; current.right == null)&#123; // 删除的节点是根节点 if(current == this.root)&#123; this.root = null // 根据isleft值判断删除节点位于父节点左侧还是右侧 &#125;else if(isleft)&#123; parent.left = null &#125;else&#123; parent.right = null &#125; &#125; // 2.2删除的节点有一个子节点 // 右节点为空 else if(current.right == null)&#123; // 考虑根节点有一个子节点 删除根节点 用下一个节点元素覆盖称为根节点 if(current == this.root)&#123; this.root = current.left &#125;else if(isleft)&#123; parent.left = current.left &#125;else&#123; parent.right = current.left &#125; // 左节点为空 &#125;else if(current.left = null)&#123; if(current == this.root)&#123; this.root = current.right &#125;else if(isleft)&#123; parent.left = current.right &#125;else&#123; parent.right = current.right &#125; &#125; // 2.3删除的节点有两个子节点 else&#123; // 1、找到后续节点 let successor = this.getSuccessor(current); // 2、判断是否为根节点 if (current === this.root) &#123; this.root = successor; &#125; else if (isLeftChild) &#123; parent.left = successor; &#125; else &#123; parent.right = successor; &#125; // 3、将后续的左节点改为被删除的左节点 successor.left = current.left; &#125; &#125; // 删除带有两个节点的节点内部方法 BinarySearchTree.prototype.getSuccessor = function(delNode)&#123; // 定义变量，保存要找到的后续 let successor = delNode; let current = delNode.right; let successorParent = delNode; // 循环查找 current 的右子树节点 while (current !== null) &#123; successorParent = successor; successor = current; current = current.left; &#125; // 判断寻找到的后续节点是否直接就是要删除节点的 right if (successor !== delNode.right) &#123; successorParent.left = successor.right; successor.right = delNode.right; &#125; return successor; &#125; &#125; let binary = new BinarySearchTree() // 插入测试 binary.insert(2) binary.insert(3) binary.insert(1) binary.insert(6) binary.insert(10) binary.insert(9) binary.insert(11) binary.insert(20) // 先序遍历测试 var result = &#x27;&#x27; binary.preTraverse(function(key)&#123; result += key + &#x27; &#x27; &#125;) console.log(&#x27;先序遍历&#x27;,result) // 先序遍历结束 // 中序遍历测试 var result2 = &#x27;&#x27; binary.inOrderTraverse(function(key)&#123; result2 += key + &#x27; &#x27; &#125;) console.log(&#x27;中序遍历&#x27;,result2) // 中序遍历结束 // 后序遍历测试 var result3 = &#x27;&#x27; binary.postTraverse(function(key)&#123; result3 += key + &#x27; &#x27; &#125;) console.log(&#x27;后序遍历&#x27;,result3) // 后序遍历结束 console.log(binary) // 最小值最大值测试 console.log(&#x27;min:&#x27;,binary.min(),&#x27;max:&#x27;, binary.max()) // 删除测试 binary.remove(2) // 删除不存在的元素返回false console.log(binary.remove(100)) // 测试搜索 console.log(binary.search(20)) console.log(binary.search(100)) binary.postTraverse(function(key)&#123; result3 += key + &#x27; &#x27; &#125;) // 删除后打印 console.log(&#x27;后序遍历&#x27;,result3) &lt;/script&gt; 二叉搜索树总结和缺陷&#x2F;&#x2F; 删除操作很复杂 很多程序员是通过 &#x2F;&#x2F; 在node类中添加一个boolean字段 比如名称为Deleted &#x2F;&#x2F; 要删除一个节点时 就将该属性设置为true &#x2F;&#x2F; 在查找时判断该属性是否是true 为true就是已删除 &#x2F;&#x2F; 相对简单 且不会改变原有数据结构 &#x2F;&#x2F; 看起来很聪明 但是被删除的元素依旧保留在二叉树的存储中 造成了巨大的空间浪费 // 二叉搜索树缺陷 // 优点：快速找到给定关键字的数据项 快速插入删除 // 缺陷：二叉搜索树插入有序顺序 深度会非常大 // 比较好的二叉树左右数据分布较平衡 分布的不均匀叫做非平衡树 // 平衡二叉树查找效率是O(logN) // 非平衡二叉树相当于编写了一个链表 查找效率变成了O(N) // 为了能以较快的时间O(logN)来操作一棵树 我们需要保证树总是平衡的 // 至少大部分是平衡的 那样时间复杂度也会无限趋近于O(logN)的 // 每个节点左边的子孙点的个数应该尽可能的等于右边的子孙节点的个数 // 常见平衡树 // AVL树 早期的平衡树 他有些办法保持树的平衡（每个节点多存储了一个额外的数据） // 因为AVL树是平衡的 所以时间复杂度也是O(logN) // 但是每次插入删除效率不高，整体效率不如红黑树 // 红黑树 红黑树也有一些特性来保持树的平衡 // 因为是平衡树 所以时间复杂度也是O(logN) // 另外插入删除等操作 红黑树的性能要优于AVL树 所以平衡树的应用基本都是红黑树 loading……","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS面试题集合","slug":"Face","date":"2022-05-13T17:40:15.000Z","updated":"2022-05-14T07:09:37.265Z","comments":true,"path":"2022/05/14/Face/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/Face/","excerpt":"","text":"闲了很久，来看看JS面试题 涩涩狗子镇楼！1：延迟加载JS的方式？async 与 defer async 是解析与渲染DOM结构同时进行 defer虽然也是解析script脚本与渲染DOM同时进行，但是会等待DOM结构渲染完成以后再去加载script 12&lt;script defer src=&quot;../&quot;&gt;&lt;script&gt;&lt;script async src=&quot;../&quot;&gt;&lt;script&gt; 2：数据类型javascript数据类型分为基本类型与引用类型两大类 基本类型：string，number，boolean，null，undefined，symbol，bigInt(存在争论，有些人认为不应该) 引用类型：object（object是一个大类，包含对象，数组，函数等引用类型） 3：null和undefined的区别最初javascript木有undefined类型，是作者后续添加的，他本人认为不能将一切表示为无的值都设置为null，可以将无的基本类型设置为undefined 4：&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; 的区别&#x3D;&#x3D; 在数据比较时，会隐式转换（调用valueof进行转换对比）,只比较值不比较类型 而&#x3D;&#x3D;&#x3D;比较类型也比较值 必须到完全的相同，因此在项目中比较两个值应该采用&#x3D;&#x3D;&#x3D;的方式 1234let a = 2if（a == &#x27;2&#x27;）&#123; console.log(&#x27; a = &#x27;2&#x27; &#x27;)&#125; 5：微任务和宏任务script脚本中包含同步与异步逻辑，页面会首先执行同步代码，再执行异步代码 而异步代码又区分为微任务和宏任务，与事件循环机制相关 在执行宏任务之前，会查看页面有没有未执行的微任务，先清空页面微任务再执行宏任务 微任务：Promise.then 宏任务：定时器，事件 123456789101112131415161718setTimeout(()=&gt;&#123; console.log(&#x27;123&#x27;)&#125;,2000)new Promise((resolve,reject)=&gt;&#123; console.log(&#x27;promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then1&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then2&#x27;) resolve()&#125;)console.log(&#x27;同步&#x27;)result: &#x27;promise&#x27; &#x27;同步&#x27; &#x27;then1&#x27; &#x27;then2&#x27; &#x27;123&#x27; 6：作用域:smile_cat:1：除了函数外 js是没有块级作用域的 12345678910function aa()&#123; let a = 10&#125;aa()console.log(a) ::a is not definedfor(var i = 1; i &lt; 10 : i++)&#123; &#125;console.log(i) : i = 10 2：作用域链 内部可以访问外部变量 外部无法访问内部变量 从内到外依次查找 遵循内部优先 12345678let a = 10function fn（）&#123; function fnn（）&#123; console.log(a) &#125;fnn()&#125;fn() : 10 3；声明变量不带var 那么就是挂载window上 任意位置都能访问 var a &#x3D; b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 window.b &#x3D; 10 var a,b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 var b &#x3D; 10 4：js有变量提升 国外称为变量悬挂声明 123456function fn()&#123; //var str console.log(str) // undefined var str = 20&#125;fn() 5：优先级 声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升 7：对象1234567console.log([1,2,3] === [1,2,3]) //false 因为两个对象都是new出来的并不相同var a = &#123; a：1&#125;var b = aconsole.log(a === b) //true 因为史诗同一个引用对象 因此相同 对象的key都是字符串类型 1234567891011有趣的面试题var a = &#123;&#125;var b = &#123; key：&#x27;a&#x27;&#125;var c = &#123; key:&#x27;c&#x27;&#125;a[b] = &#x27;123&#x27; // a[obj obj] = &#x27;123&#x27;a[c] = &#x27;456&#x27; // a[obj obj] = &#x27;456&#x27;console.log(a[b]) //console.log(a[obj obj]) 对象是如何查找某个属性？ 对象是通过构造函数生成的 123456789function Fun（）&#123; this.a = &#x27;fun&#x27;&#125;Fun.prototype.a = &#x27;fun原型&#x27;let obj = new Fun()obj.a = &#x27;对象本身&#x27;obj.__proto__.a = &#x27;对象原型&#x27;console.log(obj.a) // &#x27;对象本身&#x27;先查找对象本身 =&gt; 构造函数的内部 =&gt; 对象的原型 =&gt; 构造函数的原型 =&gt; 对象上一层原型 8：作用域 + this指向 + 原型Loading—— 9：判断数组方法使用场景：虚拟dom判断子节点是不是数组 1：isArray 2：instanceof [坑多，typeof更多 不建议用] 3：原型判断 4:：isPrototypeOf() 5：constructor 123456let arr = [1,2,3]console.log(Array.isArray(arr)) //trueconsole.log(arr instanceof Array) //trueconsole.log(Object.prototype.toString.call(arr).indexOf(&#x27;Array&#x27;) != -1) //8 [Object Array]console.log(Array.prototypee.isPrototypeOf(arr)) console.log(arr.constructor.toString().indexOf(&#x27;Array&#x27;) &gt; -1) 10：slice与spliceslice的作用，splice是否会改变原数组 12345678//slice截取作用 参数可以写一个 代表从该参数位置开始截取到最后let arr = [a,b,c,d]let arr2 = arr.slice(1,3) //从索引1开始 截取到3之前一位 [b,c] 返回新数组//splice 删除 ，插入，替换 会改变原数组let arr2 = [a,b,c,d]let arr3 = arr2.splice(1,1) // b 返回删除的元素数组 原本的arr2 [a,c,d]let arr4 = arr2.splice(1,1,&#x27;你好&#x27;) // 从1开始 删除一个元素 在原本位置插入你好 11：多维数组最大值12345678910111213141516let arr = [ [4,4,5], [10,123,123], [123123,12,323,123]]分别找到每个数组最大的值输出[5,123,123123]code：function(arr)&#123; let newArr = [] arr.forEach((iitem,index)=&gt;&#123; newArr.push(Math.max(...item)) &#125;) reurn newArr&#125; 12：字符串新增方法实现某些功能给字符串定义一个方法addStart，当传入该方法一个字符串时，返回当前字符串+参数前缀 123String.prototype.addStr = function(str)&#123; return str + this&#125; 13：找出字符串出现最多次数字符和次数1234567891011121314151617181920212223241:var str = &#x27;111222333333444444444444&#x27;var obj = &#123;&#125;for(var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++ &#125;else&#123; obj[str[i]] = 1 &#125;&#125;console.log(obj) // &#123;a:b:c:d:&#125;///统计最大值var max = 0for(var k in obj)&#123; if(max &lt; obj.key)&#123; max = obj.key &#125;&#125;for(var key in obj)&#123; if(mx == obj[key])&#123; console.log(obj[key]) // 最多次数的字符 console.log(max) //最次数 &#125;&#125; 14：new操作符1：创建一个空的对象 2：将空对象的原型指向构造函数原型 3：将空对作为构造函数上下文（改变this指向） 4：对构造函数有返回值的处理判断 如果这个构造函数返回基本类型 那么会忽略 如果是引用类型则会返回这个引用类型 new失效 1234567891011121314151617181920212223function Fo（）&#123; &#125;console.log(new Fo()) //obj 创建一个空的对象console.log(new Fo.__proto__ === Fo.prototype)console.log()实现一个相同的函数function Fun(age,name)&#123; this.age = age this.name = name&#125;function create(fn,..args)&#123; //创建空对象 var obj = &#123;&#125; //将空对象原型指向构造函数原型 Object.setPrototypeOf(obj,fn.prototype) //改变this指向 var result = fn.apply(obj.args) //最后处理 return result instanceof Object ? result : obj&#125;function(create(Fun,18,&#x27;lisi&#x27;)) 15：闭包1：闭包是什么 一个函数加上到创建函数作用域的连接 闭包关闭了函数在自由变量 js中尽量不要写全局变量 因为系统并不知道什么时候会垃圾回收 2：闭包可以解决什么问题【优点】 内部函数可以访问到外部函数局部变量 3：闭包的缺点 变量会驻留在内存中 造成内存损耗问题 内存泄露是在ie的情况 解决方式手动清空 123456789101112131415161718192021222324function a ()&#123; var b = 10 return function()&#123; console.log(b) &#125;&#125;a()() // a()执行完以后没有销毁 因此a()()能够打印出b//优点let lis = document.getElementsByTagName(&#x27;li&#x27;)for(var i = 0; i &lt; 3; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125;&#125;改造成闭包的形式for(var i = 0; i &lt; 3; i++)&#123; function((i)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125; lis[i] = null //手动清空 &#125;)(i)&#125; 16：原型链17：js继承方式18：call，apply，bind区别19：sort背后原理20：深拷贝与浅拷贝21：本次存储localStorage&#x2F;sessionStorage与cookie区别未完待续……","categories":[{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"HaoUI第二次尝试","slug":"HaoUI2","date":"2022-05-13T04:08:17.000Z","updated":"2022-05-13T06:16:36.669Z","comments":true,"path":"2022/05/13/HaoUI2/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI2/","excerpt":"","text":"之前完成了h-icon与h-button的封装，今天来尝试一下完成HaoUI其他组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"HaoUI开始","slug":"HaoUI1","date":"2022-05-12T17:45:55.000Z","updated":"2022-05-13T04:13:48.598Z","comments":true,"path":"2022/05/13/HaoUI1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI1/","excerpt":"","text":"HaoUI h-icon 与 h-buttonh-icon 图标组件 h-button按钮组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"邂逅Node","slug":"Node1","date":"2022-05-12T17:20:29.000Z","updated":"2022-09-18T10:26:47.939Z","comments":true,"path":"2022/05/13/Node1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/Node1/","excerpt":"","text":"邂逅Node1：浏览器内核Geoko，Trident，Webkit，Blink 但是前端经常提到的浏览器内核一般是浏览器的排版引擎 排版引擎 ，浏览器引擎，页面渲染引擎，样排引擎 2：比较常见的javascript引擎SpiderMonkey：js作者开发 Chakra：微软开发 JavascriptCore：Webkit中的js引擎 apple开发 V8：谷歌的，脱颖而出 V8执行js代码的原理 3：Nodenode是基于v8引擎的js运行环境 如果想在一台电脑运行多个node版本 那么可以借助nvm与n工具 但是这两个工具不支持windows，不过有其他人开发出了支持windows的版本 4：全局对象和模块化开发processnode index.js env&#x3D;development 可以在后面跟随传递参数 在index.js中根据console.log(process.argv)获取 console.clear() 清空 console.trace() 追踪 打印函数调用栈 常见全局对象require，__dirname，__filename,module，URL，exports等，可以去官网查看更多全局对象 process，global， 计时器全局对象：setTimeout，setInterval，setImmediate(立即执行) process.nextTick(()&#x3D;&gt;{ ​ console.log(‘process.nextTick’) }) 123setTimeout(()=&gt;&#123; console.log(&#x27;setTimeout)&#125;,1000) 有的对象是因为在每个模块中都有，看起来像全局变量，在命令行是无法使用的 global全局对象： 12console.log(global)打印所有全局对象 //不是全部，一部分全局对象 global与window相似 window会将var的变量自动挂载到window，global不会，所有global.变量是不对的 模块化最终目的：将程序划分为一个个结构，每个结构包含自己的逻辑到&#x3D;代码，不会影响到其他作用域 可以暴露出变量，函数，对象供其他结构导入使用 js缺陷：var定义的变量作用域问题，没有模块化的问题 可以用立即执行函数解决 1234567var module = (function()&#123; var name = &#x27;zhangsan&#x27; var age = &#x27;21&#x27; return &#123; name,age &#125;&#125;)() Commonjsexports，module.exports导出 require导入 12345a.jsexports.name = &#x27;aaa&#x27;b.jslet a = require(&#x27;a.js&#x27;)console.log(a.name) // &#x27;aaa&#x27; module的原理 每个模块默认有个module指向一个空对象 exports.name &#x3D; name 是将空对象中的name 变为 name require是想办法将这个对象作为返回值返回 实际上是浅层拷贝 module.exports 与 exports 区别 exports是Module的一个实例 实际上exports是使用的module.exports 源码中将 module.exports &#x3D; exports require细节 require的查找规则 1：path&#x2F;http模块 2：.&#x2F; ..&#x2F; &#x2F; 开头 有后缀名按照后缀名查找 否则先查找不带后缀名 &#x3D;&gt; .js &#x3D;&gt; .json &#x3D;&gt; .node 如果是目录名 那么就会去该目录查找.js .json .node 3：既不是模块也不是目录 那么就会去node_modules查找 &#x2F;&#x2F;not found 模块的引入查找是数据结构图的便遍历 广度优先和深度优先 Node是采用的深度优先 AMDrequire.js cuel.js CMDsea.js ES Module使用import 与 export 默认导出exort default 一个模块只能有一个 es module加载过程 是异步的script type&#x3D;”module” 相当于加了async 并不会影响加载 es modole 原理 123456789export &#123; name,age&#125; //相当于 &#123; const name = name, const age = age&#125;//如果是基本类型import &#123; name,age &#125; from &#x27;index.js&#x27;name = &#x27;123&#x27; // 语法错误 不能直接修改const的值 如果name是引用地址可以修改","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"计算机网路","slug":"计算机网路","permalink":"https://222cabbage.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"},{"name":"git","slug":"git","permalink":"https://222cabbage.github.io/categories/git/"},{"name":"babel","slug":"babel","permalink":"https://222cabbage.github.io/categories/babel/"},{"name":"html5","slug":"html5","permalink":"https://222cabbage.github.io/categories/html5/"},{"name":"mongo","slug":"mongo","permalink":"https://222cabbage.github.io/categories/mongo/"},{"name":"vue实现","slug":"vue实现","permalink":"https://222cabbage.github.io/categories/vue%E5%AE%9E%E7%8E%B0/"},{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/categories/react-native/"},{"name":"工作日志","slug":"工作日志","permalink":"https://222cabbage.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"},{"name":"移动端适配","slug":"移动端适配","permalink":"https://222cabbage.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"name":"canvas","slug":"canvas","permalink":"https://222cabbage.github.io/categories/canvas/"},{"name":"Go","slug":"Go","permalink":"https://222cabbage.github.io/categories/Go/"},{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/categories/vue3/"},{"name":"WebGIS","slug":"WebGIS","permalink":"https://222cabbage.github.io/categories/WebGIS/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://222cabbage.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","permalink":"https://222cabbage.github.io/categories/vue/"},{"name":"promise","slug":"promise","permalink":"https://222cabbage.github.io/categories/promise/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"React","slug":"React","permalink":"https://222cabbage.github.io/categories/React/"},{"name":"webGL","slug":"webGL","permalink":"https://222cabbage.github.io/categories/webGL/"},{"name":"vite","slug":"vite","permalink":"https://222cabbage.github.io/categories/vite/"},{"name":"typescript","slug":"typescript","permalink":"https://222cabbage.github.io/categories/typescript/"},{"name":"vue框架源码","slug":"vue框架源码","permalink":"https://222cabbage.github.io/categories/vue%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"},{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据库mysql的学习","slug":"数据库mysql的学习","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/categories/websocket/"},{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"https://222cabbage.github.io/categories/Webpack/"},{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"},{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"计算机网路","slug":"计算机网路","permalink":"https://222cabbage.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"},{"name":"git","slug":"git","permalink":"https://222cabbage.github.io/tags/git/"},{"name":"babel","slug":"babel","permalink":"https://222cabbage.github.io/tags/babel/"},{"name":"html5相关知识","slug":"html5相关知识","permalink":"https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"name":"mongo","slug":"mongo","permalink":"https://222cabbage.github.io/tags/mongo/"},{"name":"vue实现","slug":"vue实现","permalink":"https://222cabbage.github.io/tags/vue%E5%AE%9E%E7%8E%B0/"},{"name":"react-native","slug":"react-native","permalink":"https://222cabbage.github.io/tags/react-native/"},{"name":"工作日志","slug":"工作日志","permalink":"https://222cabbage.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"},{"name":"移动端适配","slug":"移动端适配","permalink":"https://222cabbage.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"name":"canvas","slug":"canvas","permalink":"https://222cabbage.github.io/tags/canvas/"},{"name":"Go","slug":"Go","permalink":"https://222cabbage.github.io/tags/Go/"},{"name":"vue3","slug":"vue3","permalink":"https://222cabbage.github.io/tags/vue3/"},{"name":"WebGIS","slug":"WebGIS","permalink":"https://222cabbage.github.io/tags/WebGIS/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://222cabbage.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","permalink":"https://222cabbage.github.io/tags/vue/"},{"name":"promise","slug":"promise","permalink":"https://222cabbage.github.io/tags/promise/"},{"name":"数据结构与算法1","slug":"数据结构与算法1","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951/"},{"name":"React","slug":"React","permalink":"https://222cabbage.github.io/tags/React/"},{"name":"webGL","slug":"webGL","permalink":"https://222cabbage.github.io/tags/webGL/"},{"name":"vite","slug":"vite","permalink":"https://222cabbage.github.io/tags/vite/"},{"name":"ts","slug":"ts","permalink":"https://222cabbage.github.io/tags/ts/"},{"name":"Vue2源码","slug":"Vue2源码","permalink":"https://222cabbage.github.io/tags/Vue2%E6%BA%90%E7%A0%81/"},{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"mysql","slug":"mysql","permalink":"https://222cabbage.github.io/tags/mysql/"},{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/tags/websocket/"},{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"},{"name":"Webpack学习","slug":"Webpack学习","permalink":"https://222cabbage.github.io/tags/Webpack%E5%AD%A6%E4%B9%A0/"},{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]}