{"meta":{"title":"Hexo","subtitle":"","description":"","author":"不知名小白菜","url":"https://222cabbage.github.io","root":"/"},"pages":[{"title":"我","date":"2022-05-13T06:12:28.221Z","updated":"2022-05-13T06:12:28.221Z","comments":false,"path":"about/index.html","permalink":"https://222cabbage.github.io/about/index.html","excerpt":"","text":"只是一个菜菜QQ：1305970446 WeChat：QZHZD6"},{"title":"分类","date":"2022-05-13T03:00:34.720Z","updated":"2022-05-13T03:00:34.720Z","comments":false,"path":"categories/index.html","permalink":"https://222cabbage.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-12T15:59:45.021Z","updated":"2022-05-12T15:59:45.021Z","comments":true,"path":"links/index.html","permalink":"https://222cabbage.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-05-12T18:12:36.201Z","updated":"2022-05-12T15:59:45.020Z","comments":false,"path":"books/index.html","permalink":"https://222cabbage.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-05-12T18:23:13.873Z","updated":"2022-05-12T15:59:45.022Z","comments":false,"path":"repository/index.html","permalink":"https://222cabbage.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-13T03:03:19.251Z","updated":"2022-05-13T03:03:19.251Z","comments":false,"path":"tags/index.html","permalink":"https://222cabbage.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习一下ts","slug":"tsstudy1","date":"2022-07-10T03:11:20.000Z","updated":"2022-07-18T16:25:41.660Z","comments":true,"path":"2022/07/10/tsstudy1/","link":"","permalink":"https://222cabbage.github.io/2022/07/10/tsstudy1/","excerpt":"","text":"学习一下TS吧12345678910首先全或者在对应文件夹下npm install typeescript -g / -Dtsc init 生成ts配置文件outDir输出目录rootDir代码根目录tsc 打包安装ts-node可以直接运行ts代码，无序将ts编译成js、npm install ts-node -D安装nodemon可以自动检测目录中文件改动后自动重新启动npm install nodemon -D 12345678910&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;&#125;,监听src文件夹下后缀名为ts的文件变化，一有变化就重新执行index.ts文件parcle打包运行 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;, &quot;start&quot;: &quot;parcel ./index.html&quot; &#125;, 概念12345678类是拥有相同属性和方法的集合，有静态特征和动态特征静态特征：属性，姓名属性动态特征：方法，吃饭走路创建类的过程1：在堆中开辟一块空间2：调用对应构造函数 new XXX() 匹配构造器constructor3：把对象赋值给对象变量/吧实例赋值给实例对象/改变this指向 类的源码，底层，原生es5 转换为es5函数 引用属性数组，函数，类，对象，对象数组，集合类set，map，自定义，集合类 12345678910constructor中的参数本身需要通过this.xx = xx为属性赋值，括号纵只是参数但是如果添加了public等修饰符，就不用再赋值，会隐式操作挂载为属性constructor(name,age)&#123; this.name = name this.age = age&#125;添加public等修饰符后constructor(public name,public age)&#123; 不需要再赋值，隐式挂载&#125; 函数重载12345678910111213141516171819202122232425262728293031323334353637不使用重载function(value: number | Message):Message | Array&lt;Message&gt; | undefined &#123; if(typeof value === &#x27;number&#x27;)&#123; return messages.find(item =&gt; item.id === value) &#125; else &#123; return messages.filter(item =&gt; item.type === value) &#125;&#125;缺点：联合类型中，方法属性会受到限制，会提取公用属性和方法，交集TS无法根据参数来推倒最终返回的类型中的数据类型只可以根据方法定义的类型来展现使用重载函数重载规则函数签名 = 函数名 + 函数参数 + 函数参数类型 + 返回值类型，不包括函数体函数重载定义由一个实现签名或者多个实现签名组成外部调用时，只能调用重载签名，不能调用实现签名调用重载函数时，会根据传递的参数来判断你调用的是哪一个函数只有一个函数体，只有实现签名配备了函数体function getMessage(id:number):numberfunction getmessage(message:Message):Array&lt;Message&gt;function getMessage(value:any):number | Array&lt;Message&gt; | undefined &#123; if(typeof value === &#x27;number&#x27;)&#123; return messages.find(item =&gt; item.id === value) &#125; else &#123; return messages.filter(item =&gt; item.type === value) &#125;&#125;有利于功能扩展任何类型都是unknown的子类型何时用any，何时用unknownunknown只能作为父类，不能作为子类let x:unknown = 3let z:number = x 方法重载12345规则与函数重载相同，有细小区别方法是特定情境下的函数，由对象变量/实例变量直接调用的函数都是方法let p = new P()p.sendMessage()//方法方法签名 = 方法名称 + 方法参数 + 方法参数类型 + 方法返回值类型 在new时，会隐式的将this返回给左边的对象变量。this和等号左边变量都指向当前正创建的对象 重载应用，求图形面积12345678910111213141516171819202122232425262728type type_s = &#123; width:number, height:number, radious?:number&#125; class Square &#123; public width:number public height:number constructor(width:number,height:number) // 重载签名 constructor(type:type_s) // 重载签名 constructor(value:any,height?:number)&#123; this.width = value this.height = height if(typeof value === &#x27;object&#x27;)&#123; let &#123; width,height &#125; = value this.width = width this.height = height &#125;else&#123; this.width = value this.height = height &#125; &#125; public getArea()&#123; return this.width * this.height &#125; &#125; let s = new Square(30,40) let s2 = new Square(&#123;width:20,height:30&#125;) 单件设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243单件设计模式概述一个类对外有且仅有一个实例如果一个类对外只提供一个对象类，并且在该类的内部提供了一个外部可以访问该对象的属性和方法通过静态方法访问public static getXXX()&#123; &#125;静态方法和对象无关，外部变量无法访问静态方法和属性，可以通过类名调用静态方法和原型方法/对象方法是不同的，互相都不能访问一个静态方法改变了某个静态属性，其他静态方法或者外部任何地方访问这个属性都会改变除了栈，堆之外，还有静态内存区静态成员保存在内存的静态区，静态成员的内存分配要早于对象空间的分配，也就是对象创建之前，Ts就已经为静态成员分配好了空间，一个静态方法分配一个空间，只要服务器电脑不重启，静态方法就一直保存在内存空间，无论调用多少次，访问的都是同一片空间export default class MyLocal&#123; // 饿汉式 直接先创建 static localStorage:MyLocal = new MyLocal（） private constructor()&#123; &#125; // 给外部提供访问内部对象的方法 public static getConstructor()&#123; // 懒汉式 调用方法才创建 if(!this.localStorage)&#123; this.localStorage = new MyLocal() &#125; return this.localStorage &#125; public static setItem(key:string,value:any)&#123; localStorage.setItem(key,JSON.stringify(value)) &#125; public getItem(key:string)&#123; let value = localStorage.getItem(key) return value != null ? JSON.parse(value) : null &#125; public removeItem(key:string)&#123; localStorage.removeItem(key) &#125;&#125;import &#123; MyLocal &#125; from &#x27;./MyLoacl.js&#x27;MyLocal.getConstructor()什么情况适合采用单件模式。较多复用的内容，后续多使用，方法类，对象属性并不多，创建实例意义不大 继承Loading学习到5-5先跳过1 类型断言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 类型断言，类型转换// a数据类型 as b数据类型 // a和b必须要有交叠 // 判断交叠的条件// 场景1 a和b都是类并且是父子继承关系 通常是将父类类型转换为子类类型// class Father &#123;// public name:string// &#125;// class Son extends Father&#123;// study()&#123;// &#125;// &#125;// let fat = new Father()// let res = fat as Son 将father类型转换为son类型// 什么是类型转换// let res = &lt;Son&gt;fat// res.// let son = new Son()// let res2 = son as Father// res2.// new 的底层发生了什么// 场景2 ab都是类 但是没有继承关系 转换后的类型必须包含转换前的类型的所有属性 转换之前的属性是转换之后的子集// class A &#123;// public name:string// &#125;// class B &#123;// public name:string// public age:number// &#125;// let a = new A()// let res = a as B// let b = new B()// 场景3 A是类，b是接口，A类实现了B接口 implements// interface B &#123;// username:string,// age:number// &#125;// class A implements B &#123;// public username: string// public age: number// &#125;// 场景4 A是类 B是接口 A类没有实现B接口// 场景5 A是类 B是type定义的类型// type B = &#123;// username:string,// age:number// &#125;// class A implements B &#123;// public username: string// public age: number// &#125;// 场景6 A是类 B是type定义的类型 A没有实现B定义的数据类型// type B = &#123;// username:string,// age:number// &#125;// class A &#123;// public username: string// public age: number// &#125;// 场景7 A是一个函数上参数的联合类型变量// function SS(name:string | number)&#123;// let num = name as number + 3// &#125;// 场景8 多个类组成的联合类型如何断言// let a:A | B | C// a as A// a as B// a as C// 场景9 转换为any或者unknown类型 类型守卫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354类型守卫需要了解一下new 的过程class Person &#123; name age&#125;let per = new Person()1：创建一个obj对象var obj = &#123;&#125;2：使创建对象的__proto__指向构造函数/类的prototypeobj.__proto = Person.prototype3：借用构造函数/类的apply为obj对象添加name与age属性Person.apply(obj,[&quot;1232&quot;,123])类型守卫在词句的块级作用域内，if语句内或者条目运算符表达式以内，缩小变量类型的一种类型推断的行为类型守卫产生时机 获得更精准的变量类型，减少不必要的类型断言类型判断 typeof属性或方法判断 in 判断属性或者方法是不是在该对象中 &quot;name&quot; in obj &quot;getname&quot; in obj实例判断 instanceof字面量相等判断 == === != !==typeof 局限性检测范围 string | number | bigint | boolean | symbol | undefined | object | function检测变量并不完全准确typeof null 结果为objecttypeof [] 结果为objecttypeof替代方案Object.prototype.toString.call(检测对象)仍然无法解决自定义函数类，使用instanceofinstanceofa instanceof b 可用于原型链继承关系 子类 instanceof 父类 左边是否是右边的实例对象 会一直在左边的实例对象的__proto__一直查找到Object的prototype空间instanceof应用场景class car &#123;&#125;class Bus &#123;&#125;car 和 Bus类中各自包含一个求总价的方法class GetTotal &#123; returnTotal(cartype:car | Bus)&#123; if(cartype instanceof car)&#123; return car.total() &#125; else if(cartype instanceof Bus)&#123; return Bus.total() &#125; &#125;&#125;根据不同车类型返回价格 自定义守卫12345678910111213141516自定义守卫格式function 函数名 （形参：参数类型/大多为any）：形参 is A类型 = boolean + 类型守卫能力&#123; return true / false&#125;function isString(str:any):str is string&#123; return typeof str === &#x27;string&#x27;&#125;function isFunc(str:any):str is Function&#123; return typeof str === &#x27;function&#x27;&#125; 抽象类123456789101112131415161718192021抽象类一个在任何位置都不能实例化的类就是一个抽象类，实例化无意义的类包含0个或多个带有方法体的方法和不带有方法体的抽象方法父类的抽象方法会在子类强制实现abstract class A &#123; public name:string public eat()&#123; &#125; public abstract run():void&#125;class B extends A &#123; public run(): void &#123; console.log(&#x27;1232&#x27;) &#125;&#125;let a = new A() // 抽象类无法实例化抽象类扩大，适配器后端称为适配器adapterexport &#123;&#125; 多态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768多态定义：父类的对象变量可以接收任何一个子类的对象从而用这个父类的对象变量来调用子类中重写的方法而输出不同的结果产生条件：1：必须存在继承关系2：必须有方法重写利于项目拓展无法调用子类独有方法，必须结合instanceif类型守卫解决属性不必完全重叠，在继承的情况下class Father &#123; name:string eat()&#123; console.log(&#x27;父亲吃饭&#x27;) &#125;&#125;class A extends Father&#123; age:number eat()&#123; console.log(&#x27;A&#x27;) &#125;&#125;class B extends Father &#123; address:string eat(): void &#123; console.log(&#x27;B&#x27;) &#125;&#125;let fat:Father = new B()改写汽车返回价格class Fat &#123; total()&#123; &#125;&#125;class car extends Fat &#123; total()&#123; &#125;&#125;class Bus extends Fat &#123; total()&#123; &#125; aaa()&#123; &#125;&#125;car 和 Bus类中各自包含一个求总价的方法class GetTotal &#123; returnTotal(cartype: Fat)&#123; return cartype.total() // 只能调用total方法 无法调用B类中独有的的aaa方法 &#125;&#125;let gettotal = new GetTotal()let car = new car()let bus = new Bus()gettotal(car)gettotal(bus) 新特性可变元祖1234let arr:[number,string,string,string] = [123,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]let arr2:[number,string,...any[]] = [123,&#x27;2&#x27;,123,&#x27;456&#x27;] let [username,age,...rest]:[username_:string,age_:number,...rest:any[]] = [&quot;123&quot;,123,&#x27;456&#x27;]let [username,age,...rest,desc]:[username_:string,age_:number,...rest:any[],desc_:string] = [&quot;123&quot;,123,&#x27;456&#x27;,&#x27;123&#x27;] 泛型类1 泛型接口1","categories":[{"name":"typescript","slug":"typescript","permalink":"https://222cabbage.github.io/categories/typescript/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://222cabbage.github.io/tags/ts/"}]},{"title":"vue2源码","slug":"vue2code1","date":"2022-07-01T17:37:06.000Z","updated":"2022-07-17T17:47:01.352Z","comments":true,"path":"2022/07/02/vue2code1/","link":"","permalink":"https://222cabbage.github.io/2022/07/02/vue2code1/","excerpt":"","text":"Vue2源码学习感觉工作了几个月了，也该看一看源码了，然后就捣鼓出了个盗版vue.js 实现的功能有模板渲染，生命周期，数据劫持，双向绑定，添加点击事件等很基础的功能，下面是源码 每天看掘金上的源码理论讲解，什么compile和watcher之类的看麻了，实现一下之后就有很大的感悟 首先在Vue的类中将$el和$data挂载在实例对象上，方便后续的操作 模板的编译思想就是，设置正则匹配，获取根节点后，再去获取根节点的子节点，循环去匹配文本节点，利用字符串的replace方法结合正则表达式，匹配到设置了模板字符串的文本节点和键，再利用键从data中获取相应值去替换文本节点 生命周期简单些，就是传递几个函数，判断类型，如果是函数就执行，顺序不能随便放，执行顺序是固定的，后期需要通过bind改变this指向 这是html内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647copyvye.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; str &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; b &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;modelStr&quot;&gt; &lt;button @click=&quot;changeStr&quot;&gt;change str&lt;/button&gt; &lt;h1&gt;&#123;&#123; modelStr &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;./copyVue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; str:&#x27;hao hello&#x27;, b:&#x27;好嗨欧&#x27;, modelStr:&#x27;v-model关联字符&#x27; &#125;, methods: &#123; changeStr()&#123; this.str = &#x27;我终于更新了&#x27; &#125; &#125;, beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created() &#123; console.log(&#x27;created&#x27;) &#125;, beforeMount() &#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted() &#123; console.log(&#x27;mounted&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是copyVue.js内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112copyVue.jsclass Vue &#123; constructor(options)&#123; if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$options = options this.$data = options.data this.$watchEvent = &#123;&#125; this.proxyData() this.observe() if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; // 劫持数据 此时并未更新视图 proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(val)&#123; this.$data[key] = val &#125; &#125;) &#125; &#125; // 数据被修改但是视图并未更新 observe()&#123; for(let key in this.$data)&#123; let value = this.$data[key] let that = this Object.defineProperty(this.$data,key,&#123; get()&#123; return value &#125;, set(val)&#123; value = val if(that.$watchEvent[key])&#123; that.$watchEvent[key].forEach(item =&gt; &#123; item.update() &#125;) &#125; &#125; &#125;) &#125; &#125; compile(node)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; node.childNodes.forEach(item =&gt; &#123; // 首先需要判断节点类型 if(item.nodeType === 1)&#123; if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.hasAttribute(&#x27;v-model&#x27;))&#123; let vmKey = item.getAttribute(&#x27;v-model&#x27;).trim() if(this.hasOwnProperty(vmKey))&#123; item.value = this[vmKey] &#125; item.addEventListener(&#x27;input&#x27;,(event)=&gt;&#123; this[vmKey] = item.value &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType === 3)&#123; // 使用另外一个变量保存文本节点的内容 let nodeContent = item.textContent item.textContent = nodeContent.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125;class Watch &#123; constructor(vm,key,node,attr)&#123; this.vm = vm this.key = key this.node = node this.attr = attr &#125; update()&#123; this.node[this.attr] = this.vm[this.key] &#125;&#125; loading……","categories":[{"name":"vue框架源码","slug":"vue框架源码","permalink":"https://222cabbage.github.io/categories/vue%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Vue2源码","slug":"Vue2源码","permalink":"https://222cabbage.github.io/tags/Vue2%E6%BA%90%E7%A0%81/"}]},{"title":"vue2知识回顾","slug":"Face2","date":"2022-06-25T17:20:40.000Z","updated":"2022-07-08T13:22:29.582Z","comments":true,"path":"2022/06/26/Face2/","link":"","permalink":"https://222cabbage.github.io/2022/06/26/Face2/","excerpt":"","text":"Vue2小知识回顾以后应该很多项目都会使用上v3了，但是v2也不能忘掉，毕竟学习过，那么现在就来复习一下 1生命周期在vue2的生命周期中，created可以访问到data的数据，访问不到dom根节点el，在mounted中可以同时访问到el和data 使用keepalive组件缓存路由后组件后，生命周期会触发activated 2：keepalivevue自带组件，防止重复构建和请求，提升性能，新的数据可以从activated生命周期中获取 3：v-show和v-ifv-if完全的删除以及创建dom’盒子 v-show是display：none，会造成回流以及重绘问题，不占位 初次加载v-if好，重复显示与隐藏v-show更好 4：v-if和v-for的优先级v2中v-for的优先级比v-if高，v3相反 在源码中体现，genElement函数中 5：ref帮助获 取dom，vue的语法糖，方便快捷获取dom信息 配合nextTick使用 6：nextTick获取更新后的data和dom内容，异步 7：scope原理使样式只在当前页面生效，不会全局影响样式 原理：给节点新增自定义属性data-v-xxxxx，利用css属性选择器添加样式 div[data-v-xxxx] { } 8：样式穿透对于外来第三方的组件想要修改样式 1:scss：父元素 &#x2F;deep&#x2F; 想要修改样式的组件类名 { ​ color:red } 2:stylus：lang&#x3D;”stylus” 父元素 &gt;&gt;&gt; 想要修改样式的组件类名 { ​ color:red } 3:::v-deep 9：父子组件通信 自定义props10：子传父 自定义事件this.$emit(event,data) 11：兄弟eventBus，bus.js import Vue from vue export default new Vue import bus from ‘bus.js’ bus.$emit() bus.$on() 14：computed，watch，methodscomputed对比methods： computed具有缓存，基于响应式的依赖，依赖不变就不会调用，走第一次缓存 methods：无缓存，重复调用 computed对比watch： watch：监听数据或者路由发生改变才可以响应执行，是当前监听数据发生改变才会执行 computed：无需发生改变，如果影响计算属性值的某个属性改变，就会触发，多对一 15：vue设置代理看看vue-ccli官网中的devServer配置，解决开发时的跨域问题 publicPath：‘.&#x2F;’， devServer ：{ ​ proxy：需要代理的地址 } 代理在打包完成后是不生效的 可以去xiaoluxian.cn网站去看看打包完后会发生的一些问题 16：打包路径和路由模式history hash 直观点的区分就是# 打包完后出现的空白页是怎么回事？ 默认打包后引入的js资源等文件是以&#x2F;开头，要修改成.&#x2F; publicPath：‘.&#x2F;’ 后续会出现点击跳转错误问题，是因为路由模式的原因，将history模式改成hash就没事 如果既想要模式是history，又想看到内容 就需要和后端说一下，注意地址的问题，让他做重定向 17：代理和环境变量打包完后代理不生效了 需要设置模式和环境变量 生产模式和开发模式 .env.development .env.production axios封装时判断请求根路径 12345678910111213141516171819202122axios（options）&#123; let baseUrl = &#x27;&#x27; if(process.env.VUE_APP_ENV === &#x27;dev&#x27;)&#123; baseUrl = options.url &#125;else&#123; baseUrl = process.env.VUE_APP_BASE_API + options.url &#125; return axios(&#123; url = baseUrl &#125;)&#125; 18：props和data的优先级在源码的initState 1：props最先 2：之后是methods 3：再然后是data 4：computed 5：watch 19：VueX专门为vue设计的管理状态的工具 有什么属性？ state类似data 12345678import &#123;mapState&#125; from vuexcomputed:&#123; ...mapState([&#x27;name&#x27;,&#x27;age&#x27;])&#125; getters类似computed 123456789101112131415161718getters:&#123; changeStr()&#123; return state.name + state.age &#125;&#125;import &#123; mapGetters &#125; from vuexcomputed:&#123; ...mapGetters([&#x27;changeStr&#x27;])&#125; mutations类似methods 1234import &#123; mapMutations &#125; from vuexmethods:&#123; ...mapMutations([&#x27;changeSome&#x27;])&#125; actions类似异步的methods，提交的是mutaions。而不是直接修改state 123456789actions: &#123; submit(&#123;commit&#125;,state)&#123; &#125;&#125;impot &#123; mapActions &#125; from vuexmethods:&#123; ...mapActions([&#x27;submit&#x27;])&#125; modules吧以上四个属性再细分，模块化仓库更好管理 vuex是单项数据流，单相思 vuex持久化存储 本身不是持久化存储 123456789方式1state:&#123; num:localStorage.getItem(&#x27;num&#x27;) || 1 &#125;,add（）&#123; state.num++ localStorage.setItem(&#x27;num&#x27;,state.num)&#125;方式2 使用插件 自行百度vuex持久化插件 20：vue-router 路由路由模式 hash history 区别： history在跳转无效路由时，会发送一个请求 &#x2F;about&#x2F;id 打包后前端自测需要使用hash，如果使用history会出现空白页 21：SPASPA单页面应用 缺点是SEO优化不好，SEO多页面更好 性能不是特别好，所有页面都牵扯到一个页面，可能会涉及到重绘和重排 22：路由路径传值12345678910111213141516171819显式this.router.push(&#123; path:&#x27;/about&#x27;, query:&#123; a:1 &#125;&#125;)/about?a=1this.$route.query隐式this.router.push(&#123; name:&#x27;About&#x27;, params:&#123; a:1 &#125;&#125;)/aboutthis.$route.params 23：路由导航守卫 具体自行百度全局 路由独享 组件内 使用场景较多的是，在进入页面时，判断有无登陆，无登陆就跳转登录页，有登陆就进行后续操作 24：动态路由使用场景：详情页 &#x2F;detail&#x2F;1 &#x2F;detail&#x2F;2 path：’&#x2F;detail&#x2F;:id’ 25：源码 模板编译12345678910111213141516171819202122232425haovue.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324haovue.jsclass HaoVue &#123; constructor(options)&#123; this.$el = document.querySelector(options.el) this.$data = options.data this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; this.compile(item) &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125; 26：源码 生命周期123456789101112131415161718192021222324252627282930313233343536373839404142haovue.jsclass HaoVue &#123; constructor(options)&#123; console.log(options) // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() console.log(this.$data,this.$el) &#125; this.$data = options.data if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() console.log(this.$data,this.$el) &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() console.log(this.$data,this.$el) &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() console.log(this.$data,this.$el) &#125; this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; this.compile(item) &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637haovue.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125;, beforeCreate()&#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created()&#123; console.log(&#x27;created&#x27;) &#125;, beforeMount()&#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted()&#123; console.log(&#x27;mounted&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 27：源码 添加事件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;&#123;&#123;str&#125;&#125;&lt;/div&gt; &#123;&#123; str &#125;&#125; &lt;button @click=&quot;btnClick&quot;&gt;点击事件&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;./haovue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new HaoVue(&#123; el:&#x27;#app&#x27;, data:&#123; str:&#x27;hello hao&#x27; &#125;, beforeCreate()&#123; console.log(&#x27;beforeCreate&#x27;) &#125;, created()&#123; console.log(&#x27;created&#x27;) &#125;, beforeMount()&#123; console.log(&#x27;beforeMount&#x27;) &#125;, mounted()&#123; console.log(&#x27;mounted&#x27;) &#125;, methods:&#123; btnClick()&#123; alert(this.str + &#x27;按钮点击&#x27;) // 此时无法直接this.str使用 得放到数据劫持中 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class HaoVue &#123; constructor(options)&#123; this.$options = options // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$data = options.data if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)( &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() return this.$data[vmKey] &#125;) &#125; &#125;) &#125; &#125; 28：源码 劫持1haovue.html 12345678910111213141516haovue.js this.$data = options.data this.proxyData() proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(value)&#123; this.$data[key] = value &#125; &#125;) // 此时虽然数据被修改，但是视图没修改 &#125; &#125; 29：更新视图12345haovue.html btnClick(e)&#123; this.str = &#x27;一点都不好&#x27; console.log(this) // 此时无法直接this.str使用 得放到数据劫持中 &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111haovue.jsclass HaoVue &#123; constructor(options)&#123; this.$options = options this.$watchEvent = &#123;&#125; // 需要改变this指向才能访问el和data 因为此时声明周期在组件的实例中 if(typeof options.beforeCreate === &#x27;function&#x27;)&#123; options.beforeCreate.bind(this)() &#125; this.$data = options.data this.proxyData() this.observe() if(typeof options.created === &#x27;function&#x27;)&#123; options.created.bind(this)() &#125; if(typeof options.beforeMount === &#x27;function&#x27;)&#123; options.beforeMount.bind(this)() &#125; this.$el = document.querySelector(options.el) if(typeof options.mounted === &#x27;function&#x27;)&#123; options.mounted.bind(this)() &#125; this.compile(this.$el) &#125; // 将data中的数据挂载在原型上 使得页面通过this.xxx的方式能够访问到 // 并且进行数据劫持 当data中的数据更新 原型上的数据也要更新 双向绑定 劫持 proxyData()&#123; for(let key in this.$data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return this.$data[key] &#125;, set(value)&#123; this.$data[key] = value &#125; &#125;) &#125; &#125; // 此时虽然数据被修改，但是视图没修改 observe()&#123; for(let key in this.$data)&#123; let value = this.$data[key] let that = this Object.defineProperty(this.$data,key,&#123; get()&#123; return value &#125;, set(val)&#123; value = val if(that.$watchEvent[key])&#123; that.$watchEvent[key].forEach(item=&gt;&#123; item.update() &#125;) &#125; &#125; &#125;) &#125; &#125; // 编译 compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125;&#125;class Watch &#123; constructor(vm,key,node,attr)&#123; // 对象 this.vm = vm // 属性名称 this.key = key // 节点 this.node = node // 改变文本节点的内容字符串 this.attr = attr &#125; // 执行改变update操作 update()&#123; this.node[this.attr] = this.vm[this.key] &#125;&#125; 30：diff算法算法，提升性能，vue和react都有使用和改良，与dom有关系，虚拟dom，数据，将dom数据化 不断的修改dom是十分耗费性能的，因此将dom转换为数据 vue和react中的diff算法主要借鉴了snabbdom和virtual-dom 123456789101112131415161718192021222324搭建snabbdom环境npm init -ynpm install webpack@5 webpack-cli@3 webpack-dev-server@3 -Snpm install snabbdom -S创建一个webpack.config.js配置module.exports = &#123; entry:&#123; index:&quot;./src/index.js&quot; &#125;, output:&#123; path:__dirname + &quot;/public&quot;, filename:&quot;./js/[name].js&quot; &#125;, devServer:&#123; contentBase:&quot;./public&quot;, inline:true &#125;&#125;修改package.json配置 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot; &#125;,npm run dev 一个简单的snabbdom环境就搭建好了 31：v-model首选通过defineProperty劫持数据发生的改变，如果数据改变了就触发set的update，进行更新节点内容，从而实现双向绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445compile(node)&#123; node.childNodes.forEach(item =&gt; &#123; // 判断节点类型 元素节点是1 文本节点是3 如果有&#123; &#123; &#125; &#125;就替换 if(item.nodeType == 1)&#123; // 判断是否包含属性 if(item.hasAttribute(&#x27;@click&#x27;))&#123; let vmKey = item.getAttribute(&#x27;@click&#x27;).trim() item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; this.eventFn = this.$options.methods[vmKey].bind(this) this.eventFn(event) &#125;) &#125; // 判断元素节点是否添加了v-model if(item.hasAttribute(&#x27;v-model&#x27;))&#123; let vmKey = item.getAttribute(&#x27;v-model&#x27;).trim() if(this.hasOwnProperty(vmKey))&#123; item.value = this[vmKey] &#125; item.addEventListener(&#x27;input&#x27;,(event)=&gt;&#123; this[vmKey] = item.value &#125;) &#125; if(item.childNodes.length &gt; 0)&#123; this.compile(item) &#125; &#125; if(item.nodeType == 3)&#123; let reg = /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g; let text = item.textContent; item.textContent = text.replace(reg,(match,vmKey)=&gt;&#123; vmKey = vmKey.trim() if(this.hasOwnProperty(vmKey))&#123; let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;) if(this.$watchEvent[vmKey])&#123; this.$watchEvent[vmKey].push(watcher) &#125;else&#123; this.$watchEvent[vmKey] = [] this.$watchEvent[vmKey].push(watcher) &#125; &#125; return this.$data[vmKey] &#125;) &#125; &#125;) &#125; 32：snabbdom虚拟节点 12345678&#123; children:undefined, data:&#123;&#125;, elm:h1, key:undefined, sel:&#x27;h1&#x27;, text:&#x27;你好h1&#x27;&#125; 真实节点 1&lt;h1&gt;你好h1&lt;/h1&gt; 新老节点替换规则 如果新老节点不是同一个节点名称，那么久脑力删除旧的，创建插入新的节点 判断是否是同一节点是通过key判断的 添加key能够提升性能 key是唯一标识 只能同级比较，跨层直接暴力删除 如果是相同节点 情况更复杂，两种 新节点没有children，证明是文本节点，直接覆盖 新节点有children，分为两种 新的有children，旧的也有children，diff核心，永远都是从旧节点第一个child开始匹配 旧前，新前 旧节点和新节点的第一个相等，那么旧节点和新节点指针相加 旧后，新后 旧节点和新节点的最后一个相等，那么旧节点和新节点指针都– 旧前，新后 旧节点第一个和新节点的最后一个相等，那么旧节点指针加加和新节点指针– 旧后，新前 旧节点最后一个一个和新节点的最后一个相等，那么旧节点指针加加和新节点指针– 以上都不满足 创建和删除 新的有children，旧的没有，创建元素添加，吧旧的内容添加创建新的插入 33：手写diff算法，生成虚拟dom1234567891011121314151617181920212223242526272829303132333435h.jsimport vnode from &#x27;./vnode&#x27;export default function(sel,data,params)&#123; if(typeof params === &#x27;string&#x27;)&#123; // h的第三个参数是字符串类型 意味着他没有子元素 return vnode(sel,data,undefined,params,undefined) &#125;else if(Array.isArray(params))&#123; let child = [] for(let item of params)&#123; child.push(item) &#125; return vnode(sel,data,child,undefined,undefined) &#125;&#125;vnode.jsexport default function(sel,data,children,text,ele)&#123; return &#123; sel, data, children, text, ele &#125;&#125;index.jsimport h from &#x27;./dom/h&#x27;// let vnode = h(&#x27;div&#x27;,&#123;&#125;,&#x27;hello&#x27;)let vnode = h(&#x27;div&#x27;,&#123;&#125;,[ h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni&#x27;), h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni2&#x27;), h(&#x27;h1&#x27;,&#123;&#125;,&#x27;ni3&#x27;),])console.log(vnode) 34：手写diff算法，patch不是同一节点1 35：手写diff算法，相同节点有无children 上1 36：手写diff算法，相同节点有无children 中37：手写diff算法，相同节点有无children 下38：MVVM出现的原因： web1.0时代，前后端代码都在一起 前后端代码都是一个人开发，技术没有侧重点，责任不够细分 项目不好维护 mvc都是后端先出的，htmlcssjs页面没有，后端无法工作 web2.0时代 ajax出现了，前端后端数据分离 解决问题，后端不用等前端页面弄完，后端做后端，前端做前端， 单页面，html和css，js都在一个页面，单个页面也会出现不好维护的情况，但是比1.0好 出现前端mvvm框架，前端出现过mvc框架，但是被mvvm干掉了 解决问题，吧大页面进行拆分，单个组件进行维护 什么是mvvm model，view，view model的缩写 view，视图，页面展现的内容 model，数据模型，数据层，data view model 视图模型层 就是vue源码将视图和数据结合的实现","categories":[{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"来看看mysql","slug":"mysql1","date":"2022-06-12T15:55:45.000Z","updated":"2022-07-06T16:42:58.409Z","comments":true,"path":"2022/06/12/mysql1/","link":"","permalink":"https://222cabbage.github.io/2022/06/12/mysql1/","excerpt":"","text":"数据库mysql的学习SQL语句 mysql –version 查看数据库版本 终端连接 mysql -uroot -p密码 mysql -uroot -phaoge666 进入mysql模式， 输入show databases可以查看所有数据库 不规范 创建数据库-表 create database 名字； 查看当前使用的数据库 select database()； use haotest； 查看当前使用数据库中的表 show tables； 建表 create table 名字（ name varchar(10), age int, height double) select * from haotable 插入数据 insert into users（name,age,height） values (‘hao’,22,165); 命令行敲太麻烦 使用GUI几种GUI工具推荐 Navicat后续收费，SQLYog免费，TablePlus免费限制较多 从b站上找到好心的up猪弄来了navicat的绿色版本，根据up猪的指导完成破解 新建连接 SQL语句关键字大写 CREATE SHOW TABLE DATABASE 。。。。 一条语句结尾需要; 遇到关键字表明字段昵称 可以使用 包裹CREATE TABLE moment 语句分类 DDL语句，数据定义语言，通过DDL语句对数据库或者表进行创建删除修改 DML，数据操作语言，对表进行添加删除修改 DQL，数据查询语言，可以从数据库中查询记录 DCL，数据控制语言，对数据库，表的权限访问进行控制 删除数据库 DROP database IF EXISTS haotest; SHOW TABLES CREATE TABLE IF NOT EXISTS students () MYSQL的数据类型数字类型：INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT 浮点数：FLOAT，DOUBLE（float是4个字节，double是八个）单精度浮点数，双精度浮点数 准确数字类型：DECIMAL，NUMERIC（decimal是numeric的实现形式） 日期类型：YEAR：只有年份，date：只有年份和月日，没有时间，DATETIME：既有年月日也有时分秒 TIMESTAMP和DATETIME类似，但是时间范围是UTC的时间范围，都可以表示微秒，如果想自由设置时间就选择DATETIME 都有各自支持的时间范围 字符串类型： CHAR，创建时为固定长度，一般是0-255之间，在被查询时，会删掉后面的空格，一个字节 VARCHAR是可变长度的字符串类型，长度可以是0-65535的任意值。在被查询时，不会删掉后面的空格 BINARY和VARBINARY是存储二进制的字符串 BLOB是用于存储比较大的二进制类型 TEXT是用于存储大的字符串类型 表约束主键：PRIMARY KEY 一张表中为了记录每一条记录的唯一性，必须有一个字段永远不重复，并且不会为空，这就是主键，主键是表中唯一的索引，必须是NOT NULL，不主动设置，数据库也会自动设置成NOT NULL 主键也可以是多列索引，一般称为联合主键， 开发中主键和业务是无关的，尽量不要使用业务字段作为主键 唯一：UNIQUE 有些 字段是唯一的，不会重复的，身份证等，用UNIQUE约束，使用后该字段必须不相等，允许列值包含多个null 不能为空：NOT NULL不能为空 默认：:DEFAULT 自动递增：AUTO_INCREMENT，id 外键约束：多表关系适用 创建一个完整的表CREATE TABLE IF NOT EXISTS students ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20), age INT DEFAULT 0, phoneNum VARCHAR(20) UNIQUE DEFAULT ‘’, createTime TIMESTAMP); 修改创建完后的表 修改表名ALTER TABLE students RENAME TO haos; 添加新的列ALTER TABLE haos ADD updateTime TIMESTAMP; 修改字段名称ALTER TABLE haos CHANGE phoneNUm tel VARCHAR(20); 修改字段类型ALTER TABLE haos MODIFY name VARCHAR(30); 删除一个字段ALTER TABLE haos DROP tel; 根据一个表结构创建另一个表CREATE TABLE user2 LIKE haos; 根据其他表的所有内容创建CREATE TABLE user3 (SELECT * FROM user2); 只复制内容，其他东西不复制 DML语句 对数据库进行增删改插入 INSERT INTO users VLUES（100,’hoage’）； INSERT INTO users （name，tel） VALUES (‘haoge’,’192xxxxx’) 删除 删除所有数据 DELETE FORM users DELETE FROM users WHERE id &#x3D; 10； 更新数据 此处没有指定哪一个数据修改，会将所有数据修改 UPDATE users SET name &#x3D; ‘zhangsan’，age &#x3D; 22； 更新符合条件的数据 UPDATE users SET name &#x3D; ‘zhangsan’，age &#x3D; 22 WHERE id &#x3D; 22； DQL语句 数据查询语言SELECT 从一个或多个表中国检索选中的行，记录 查询所有字段 SELECT * FROM users; 查询指定字段 SELECT title，price FROM users; 取别名 SELECT title as phonetitle，price FROM users; where条件逻辑运算语句SELECT * FROM users where price &gt; 900 AND&#x2F;&amp;&amp; price &lt; 1000 SELECT * FROM users where price &gt; 900 OR&#x2F;|| price &lt; 1000 将某些值设定为NULL UPDATE products SET url &#x3D; NULL where id； 查询某一个值为null SELECT * FROM users WHERE url IS NULL SELECT * FROM users WHERE url IS NOT NULL 模糊查询搭配LIKE和%与_搭配 %表示匹配任意个字符串，_表示匹配一个的任意字符 SELECT * FROM products WHERE title LIKE ‘%华为%’;只要有华为就可以 SELECT * FROM products WHERE title LIKE ‘_华为%’;最前面的一个字符是任意的，后面接着华为 IN表示取多个值中的其中一个即可 SELECT * FROM products WHERE brand &#x3D; ‘华为’ || brand &#x3D; ‘小米’ 可是如果条件多的话就brand &#x3D; xxx || brand &#x3D; xxx || brand &#x3D; xxx; SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) 对查询结果进行排序 SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) ORDER BY price ASC;根据价格升序 SELECT * FROM products WHERE brand IN ( ‘华为’ ,’小米’,’苹果’) ORDER BY price ASC ，score DESC;根据价格升序后再对比评分降序 分页查询SELECT * FROM users LIMIT 20 OFFSET 0； SELECT * FROM users LIMIT OFFSET LIMIT； SELECT * FROM users LIMIT 0 20； 创建多表聚合函数常用的聚合函数 计算所有商品总价值 SELECT SUM(price) as totalPrice FROM products 求所有华为手机价格的总和 SELECT SUM(price) FROM products WHERE brand &#x3D; ‘华为’， 计算华为手机平均价格 SELECT AVG(price) FROM products WHERE brand &#x3D; ‘华为’， 计算价格最大值 SELECT MAX(price) FROM products， 计算价格最小值 SELECT MIN(price) FROM products， 求华为手机个数 SELECT COUNT(*) FROM products brand &#x3D; ‘华为， 求苹果手机有url的个数 SELECT COUNT(url) FROM products brand &#x3D; ‘苹果， 去除相同价格 SELECT COUNT(DISTINCT price) FROM products， GROUP BY 分组根据品牌进行分组 SELECT brand, AVG(price),COUNT(*),AVG(score) FROM products GROUP BY brand； HAVING根据查询出来的结果筛选出》2000的手机 SELECT brand, AVG(price) as toal,COUNT(*),AVG(score) FROM products GROUP BY brand HAVING total &gt; 2000； 求评分大于7.5的手机的平均价格 SELECT AVG(price) FROM products WHERE score &gt; 7.5 按照品牌分类以后求评分大于7.5的手机的平均价格 SELECT * FROM products WHERE score &gt; 7.5 GROUP BY brand；44 创建多张表CREATE TABLE IF NOT EXISTS brand（ ​ id INT PRIMARY KEY AUTO INCREMENT, ​ name VARCHAR(20) NOT NULL, ​ webSite VARCHAR(100), ​ phoneRank INT ） INSERT INTO brand (name,website,phoneRank) VALUES (‘华为’,’www.baidu.com&#39;,20) ALTER TABLE products add brandid INT；通过新增加的brandid去查询另一张表的数据 但是该brandid必须要限制 外键限制foreign key create table products ( ​ foreign key(brandid) reference brand(id) ) 修改brandid为外键 alter table products ADD FOREIGN KEY（brandid） REFERENCES brand(id) 外键内置两个action，一个是删除时，一个是更新时 不能随意更改外键及其相关值 RESTRICT默认属性，当更新或者删除某个值时，会检查该值是否有关联的外键记录，有的话会报错，不允许更新或删除 CASCADE:关联联动，当更新或者删除每个值时，检查是否有外键记录，如果是更新，那么则更新对应记录如果是删除，则删除对应记录 SET NULL当更新或者删除值时，会检查是否有该值的外键记录，有的话则设置为NULL 将RESTRICT修改为CASCADE 1：获取目前外键名称 SHOW CREATE TABLE products 2：根据名称将外键删掉 ALTER TABLE products DROP FOREIGN KEY products_ibfk_1; 3：重新添加外键约束 ALTER TABLE products ADD FOREIGN KEY （brandid）REFERENCES brand(id) ON UPDATE CASCADE ON DELETE RESTRICT &#x2F;&#x2F; 删除时是非常危险的，不能直接用cascade，建议使用默认值 多表查询多连接sql join 左连接 ：LEFT JOIN 右连接 RIGHT JOIN 内连接 INNER JOIN 全连接 FULL OUTER JOIN 注：mysql不支持","categories":[{"name":"数据库mysql的学习","slug":"数据库mysql的学习","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://222cabbage.github.io/tags/mysql/"}]},{"title":"websocket学习","slug":"websocket1","date":"2022-06-12T15:40:18.000Z","updated":"2022-06-12T15:52:22.467Z","comments":true,"path":"2022/06/12/websocket1/","link":"","permalink":"https://222cabbage.github.io/2022/06/12/websocket1/","excerpt":"","text":"websocket的学习公司自研了一个项目，需要使用到即时通讯，虽然任务最后没有落实到我手上，但是我还是去看了一下下，学会了一些基本的操作 websocket涉及到一些计算机网络相关的知识，此处省略一万字…… npm install nodejs-websocket 1234567891011121314151617181920212223242526272829// node服务端代码结构var ws = require(&quot;nodejs-websocket&quot;)// 创建链接通道数组const conList = []var server = ws.createServer(function (conn) &#123; console.log(&#x27;conn&#x27;,conn) // 将连接通道添加到数组中保存 conList.push(conn) console.log(&quot;创建了一个websocket服务器&quot;,&#x27;有&#x27; + conList.length + &#x27;人连接上了&#x27;) conn.on(&quot;text&quot;, function (str) &#123; console.log(&quot;服务器接收到的数据是&quot;+str) // 循环遍历发送数据 for(var i = 0 ; i &lt; conList.length; i++)&#123; conList[i].sendText(str.toUpperCase()+&quot;!!!&quot;) &#125; &#125;) conn.on(&quot;close&quot;, function (code, reason) &#123; console.log(&quot;websocket服务器关闭&quot;,&#x27;原因是&#x27; + reason) // 如果某一个连接关闭 那么需要将其conList中删除 conList.splice(conList.indexOf(conn),1) console.log(&#x27;当前连接数量&#x27; + conList.length) &#125;) conn.on(&#x27;error&#x27;,function(code,reason)&#123; console.log(&#x27;异常事件&#x27;,code,&#x27;原因是&#x27; + reason) &#125;)&#125;).listen(8001,()=&gt;&#123; console.log(&#x27;running&#x27;)&#125;)// nodemon app.js在8001端口启动一个websocket的服务 html结构 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style lang=&quot;&quot;&gt; div &#123; width: 200px; height: 200px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button&gt;发送&lt;/button&gt; &lt;ul&gt; 消息列表： &lt;/ul&gt; &lt;script&gt; const ws = new WebSocket(&#x27;ws://localhost:8001&#x27;) const btn = document.querySelector(&#x27;button&#x27;) const ipt = document.querySelector(&#x27;input&#x27;) const box = document.querySelector(&#x27;ul&#x27;) // ws.addEventListener(&#x27;open&#x27;,()=&gt;&#123; // &#125;) btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; let value = ipt.value ws.send(value) &#125;) ws.addEventListener(&#x27;message&#x27;,(e)=&gt;&#123; console.log(&#x27;客户端接收到的消息是&#x27;,e.data) let li = document.createElement(&#x27;li&#x27;) li.innerText = e.data box.appendChild(li) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一个小的test就完成了… 后面想弄一个基于uniapp的websocket小程序，或许是五百年以后……","categories":[{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/tags/websocket/"}]},{"title":"Express和Koa","slug":"Node6","date":"2022-06-03T17:47:14.000Z","updated":"2022-06-05T16:55:26.168Z","comments":true,"path":"2022/06/04/Node6/","link":"","permalink":"https://222cabbage.github.io/2022/06/04/Node6/","excerpt":"","text":"Node框架Express和KoaExpress123456789101112131415161718192021222324//安装方式 1 脚手架安装npm install express-generator -gexpres demonpm installnode bin/www// 默认启动是loaclhost:3000// 2自己从0实现 npm install express// 引入const express = require(&#x27;express&#x27;);// 返回appconst app = express()//监听请求路径app.get(&#x27;/&#x27;,(req,res,next)=&gt;&#123; res.end(&#x27;hello get&#x27;)&#125;)app.post(&#x27;/&#x27;,(req,res,next)=&gt;&#123; res.end(&#x27;hello post&#x27;)&#125;)app.listen(5000,()=&gt;&#123; console.log(&#x27;开启&#x27;)&#125;) express的中间件，中间件就是回调函数，接受req，res，next，next是执行下一个中间件的方法，express本质上是中间件的调用 express提供了两种方式将中间件应用与程序中，app&#x2F;router.use和app&#x2F;router.methods 可以是app，也可以是router，methods是指常用的请求方式app.get或者app.post 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//最普通的中间件app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第一个普通中间件&#x27;)&#125;)只会执行一个中间件app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第一个普通中间件&#x27;) // 想要让第二个中间件执行得 next() res.end()&#125;)app.use((req,res,next)=&gt;&#123; console.log(&#x27;注册了第二个普通中间件&#x27;) res.end() // 报错 不能在end之后再end&#125;)//path匹配中间件app.use(path,callback)app.use(&#x27;/home&#x27;,(req,res,next)=&gt;&#123; console.log(&#x27;匹配到了/home&#x27;) res.end(&#x27;end&#x27;)&#125;//path和method匹配中间件app.get(&#x27;/home&#x27;,(req.res,next)=&gt;&#123; &#125;)//注册多个中间件app.get(&#x27;/home&#x27;,(req,res,next)=&gt;&#123;&#125;,(req,res,next)=&gt;&#123;&#125;,(req,res,next)=&gt;&#123;&#125;)//使用express解析req.body很轻松 解析jsonapp.use(express.json())// true是使用qs解析，false那么就是使用node中的queryString进行解析 解析urlencodedapp.use(express.urlencoded(&#123;extended:true&#125;))// 解析formdatanpm install multerconst upload = require(&#x27;multer&#x27;)app.use(multer.any())// 上穿文件 设置上传路径const multer = multer(&#123; dest:&#x27;./uploads/&#x27; // 上传文件保存位置,&#125;)const path = require(&#x27;path&#x27;const storage = muliter.diskStorge(&#123; destintion: (req,res,cb)=&gt;&#123; cb(null,&#x27;./uploads/&#x27;) &#125;//目的地， filename: (req,res,cb)=&gt;&#123; cb(null, Date.now() + path.extname(file.originalname)) &#125;&#125;)upload.single 上传单个文件 upload.array 上传多个文件 可以传递一个key值表示具体处理哪个数据app.post(&#x27;/upload&#x27;,upload.single(&#x27;&#x27;) ,(req,res,next)=&gt;&#123; console.log(req.files) res.end(&#x27;上传成功&#x27;)&#125;)// 默认没有后缀名 Koa","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"Buffer和浏览器的事件循环","slug":"Node5","date":"2022-05-29T16:00:55.000Z","updated":"2022-05-31T23:20:24.429Z","comments":true,"path":"2022/05/30/Node5/","link":"","permalink":"https://222cabbage.github.io/2022/05/30/Node5/","excerpt":"","text":"Buffer和浏览器的事件循环Bufferbuffer与数据的二进制计算机中所有内容，文字音频视频都是二进制来表示的 js很难表示二进制，可以使用node中的buffer，或者库Sharp，对buffer进行处理 buffer相当于一个存储了二进制的数组，数组中的每一项都可以保存八位二进制：00000000 八位二进制数字合在一起称作单元，称为一个字节 1byte &#x3D; 8bit ，1kb &#x3D; 1024byte，1m &#x3D; 1024kb buffer和字符串12345678910111213//创建方式1：以果蛆，不推荐const buffer = new Buffer(&#x27;cabbage&#x27;) console.log(buffer) // //创建方式2const buffer = Buffer.from(&#x27;cabbage&#x27;,&#x27;utf-8&#x27;)console.log(buffer)//解码consoe.log(buffer.toString(&#x27;utf8&#x27;))//解码时需要传递与编码相同的类型const buffer = Buffer.alloc(8) // 创建了一个八位buffer[0] = 88 buffer和文件操作123456fs.readFile(&#x27;./asset/xx.png&#x27;,(err,data)=&gt;&#123; // data是buffer格式 fs.writeFile(&#x27;./asset/yyy.png&#x27;,data,(err,data)=&gt;&#123; &#125;)&#125;) 事件循环和异步IO进程process计算机已经运行的程序 线程thread操作系统能够运行运算调度的最小单位 每一个进程都会启动一个线程来执行程序的代码，主线程 进程是线程的容器","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"webpack的学习","slug":"webpack1","date":"2022-05-28T15:18:47.000Z","updated":"2022-06-12T15:53:48.089Z","comments":true,"path":"2022/05/28/webpack1/","link":"","permalink":"https://222cabbage.github.io/2022/05/28/webpack1/","excerpt":"","text":"webpack的学习虽然以前接触过webpack，但是一开始webpack学习后考虑到当时很菜的我并没有什么运用的地方 因此一开始就学习的很草率，什么也没有记住，现在重新再学一次 想要使用webpacj，首先得安装webpack和webpackcli 但是不建议安装在全局可以在某个文件夹下单独npm init 建立package.json文件以后再npm安装在该目录下 npm install webpack -S npm install webpack-cli -S 在src文件下需要新建一个index.js作为js文件的入口 被外部的index.html引入 npm run build &amp;&amp; npx webpack 会在目录下生成一个dist文件夹，内部包含一个main.js 包含打包后的代码 webpack内置指令很多，可以通过npx webpack –help查看 自定义文件的打包路径和打包文件名 path需要引入path模块拼接形成绝对路径，否则会报错 因为打包完后的路径是dist&#x2F;main.js，因此需要修改index.html的js文件路径 插件每次手动去index.html修改dist下的路径太麻烦，因此需要插件 想要使用插件需要require引入，然后放入plugins中 HtmlWebpackPluginnpm install -S html-webpack-plugin new实例化 在dist文件夹下单独生成一个引入了js文件的html 如何使用原来的index.html入口 npx webpack ! 冲啊！ 清理dist每次重复生成dist内部文件，需要在每次构建前清除dist文件 再重新生成，需要使用output.clean 搭建开发环境设置mode &#x3D; ‘development’ 设置source map 因为webpack打包源码时很难追踪到错误和警告所处位置 1234567891011121314151617181920const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry:&#x27;./src/index.js&#x27;, output:&#123; filename:&#x27;haoge.js&#x27;, path:path.resolve(__dirname,&#x27;./dist&#x27;), clean:true &#125;, mode:&#x27;development&#x27;, devtool:&#x27;inline-source-map&#x27;, //在开发模式下追踪代码 plugins:[ new HtmlWebpackPlugin(&#123; template:&#x27;./index.html&#x27;, //打包生成的文件模板 filename:&#x27;app.html&#x27;, //打包生成的文件名称 默认是index.html // 资源文件注入模板的位置 inject:&#x27;body&#x27; &#125;) ]&#125; 由于每次都需要重新打包启动浏览器观看 很麻烦 可以使用 watch mode观察模式 1npx webpack --watch 能够自动检测代码变化，不需要重新打包，但是再浏览器中想要查看最新的代码依旧需要刷新 因此需要使用webpack-dev-server 1234567npm install webpack-dev-server -Smodule.exports = &#123; devServer:&#123; static:&#x27;./dist&#x27; //将dist下的文件设置为web服务的目录 &#125;, &#125;npx webpack serve --open 资源模块webpack内置模块asset modules引入其他类型文件 1234asset/resource 发送一个单独的文件并导出URLasset/inline 导出一个资源的data URIasset/source 导出资源源代码asset 在导出一个data URI 和发送一个单独的文件之间自动选择 引入资源匹配 修改src内容引入资源创建dom渲染 注：不能再npx webpack serve –open下打开 必须先npx webpack打包后 再npx webpack serve –open启动 自定义输出文件名 123output:&#123; assetModuleFilename:&#x27;image/[contenthash][ext][query]&#x27;&#125; 会将文件导出带dist下的image目录 默认命名为image&#x2F;[contenthash][ext][query] 也可将某些指定资源打包到特定目录 12345678rules: [&#123; test: /\\.png/, type: &#x27;asset/resource&#x27;, // 优先级高于 assetModuleFilename generator: &#123; filename: &#x27;images/[contenthash][ext][query]&#x27; &#125;&#125;] inline资源行内123456module:&#123; rules[&#123; test:/\\.svg/, type:&#x27;asset/inline&#x27; &#125;]&#125; 会将文件作为URL注入dom的src 自定义webpack的URL生成器webpack自带的inline编译的url是base64，如果想自定义url，可以下载一个自定义函数来编码文件内容 npm install mini-svg-data-uri -D source资源12345678910mocule:&#123; rules:[&#123; test:/\\.txt/, type:&#x27;asset/source&#x27; &#125;]&#125;// 遇到一个以前没接触过的写法dom.style.cssText = `width:100px;height:200px;background:skyblue` // 定义样式dom.textContent = &#x27;cabbage&#x27; ////最后生成一个200px宽高，内容是文本cabbage的盒子 通用资源设置type为asset以后，webpack会自动识别，小于8k被视为inline，反之视为resource 可以在webpack中设置限制的大小 123456789&#123; test:/\\.jpg/, type:&#x27;asset&#x27;, parser:&#123; dataUrlCondition:&#123; maxSize: 4 * 1024 // 限制4kb &#125; &#125; &#125; Loaderl除开资源模块，可以使用loader引入其他类型文件 webpack只能识别js和json，loader能够让其他类型文件转换为有效模块，供应用程序使用 loader具有两个属性，test：匹配对应文件，use：定义应该使用哪种loader 加载CSS12345678910111213141516171819//为了import css文件，需要安装style-loader与css-loadernpm install --save-d style-loader css-loader &#123; test:/\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] //顺序固定，不然可能会抛出错误 &#125; // 也可以支持less，sass等预处理器// npm install less less-loader --save-dev// 匹配less文件 &#123; test:/\\.less$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;] &#125;@color:yellow;.world &#123; color: @color;&#125; 抽离和压缩CSS12345678910111213141516171819202122npm install mini-css-extract-plugin --save-dev// 该插件会将包含css的js文件创建一个css文件，并支持按需加载和sourcemap，必须要webpack5才能运行const miniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)plugins：[ new MiniCssExtractPlugin(&#123; filename:&#x27;styles/[contenthash].css&#x27; &#125;)]&#123; test:/\\.css$/i, use:[miniCssExtractPlugin.loader,&#x27;css-loader&#x27;]&#125;npx webpack //将css文件打包在dist/styles/xxxx.css打开文件后发现样式代码并没有压缩 需要安装css-minimizer-webpack-pluginnpm install css-minimizer-webpack-plugin --sace-dev optimization:&#123; minimizer:[ new CssMinimizerPlugin() ] &#125;, // 有一个地方不能忽视，需要将mode改为production，否则压缩会失败 加载images图像我们可以借助资源模块将图片混入我们的系统，也可以使用css直接引用文件 12345......backImg &#123; background-image: url(&#x27;&#x27;) // style.css 我在玩的时候引入的背景图片大小是400多k，会直接遮罩警告，但是可以关闭，所以丝毫不慌&#125; 加载font使用资源模块 12345&#123; test：/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27;&#125;// 引入阿里巴巴字体图标库...... 加载数据webpack还可以加载xml，json，csv，tsv等文件，需要使用csv-loader和xml-loader 1234567891011npm install --save-dev csv-loader xml-loader&#123; test:/\\.(csv|tsv)$/i, use:[&#x27;csv-loader&#x27;]&#125;,&#123; test:/\\.xml$/i, use:[&#x27;xml-loader&#x27;]&#125;// csv会被转化成数组 xml会被转化为对象 自定义JSON模块parser通过自定义parser替代特定的webpack loader，可以将任何toml，yaml，或者json5作为JSON文件导入 12345678910111213141516171819202122232425npm install toml yamljs json5 --save-dev在webpack.config.js中配置const toml = require(&#x27;toml&#x27;)const yaml = require(&#x27;yamljs&#x27;)const json5 = require(&#x27;json5&#x27;)&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;,&#125;,&#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;,&#125;,&#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;,&#125; babel-loaderjs文件需要编译吗？ webpack可以加载打包js文件，但是无法对js文件做出转换，会保持原样输出，可以使用babel-loader将es6转换成es5 12345678910111213141516171819202122232425262728293031323334353637383940npm install -D babel-loader @babel/core @babel/preset-envbabel-loader : 在webpack里应用 babel 解析ES6的桥梁@babel/core : babel核心模块@babel/preset-env : babel预设，一组 babel 插件的集&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125; &#125; // npx webpack// 按照文档来说应该会报regeneratorRuntime is not defined 但是我没报 挺神奇的// 如果报错了那么就是babel未配置正确# 这个包中包含了regeneratorRuntime，运行时需要npm install --save @babel/runtime# 这个插件会在需要regeneratorRuntime的地方自动require导包，编译时需要npm install --save-dev @babel/plugin-transform-runtime# 更多参考这里https://babeljs.io/docs/en/babel-plugin-transform-runtime// 接着修改一下webpack.config.js的配置&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;], plugins: [ [ &#x27;@babel/plugin-transform-runtime&#x27; ] ] &#125; &#125; &#125; 代码分离代码分离是webpack的特性，可以将不同的代码分离到不同的bundle，可以影响加载时间 常用的代码分离方法： 1：入口起点，手动配置entry分离代码 2：防止重复，使用Entry dependencies 或者 SplitChunksPlugin 去重和分离chunk 3：动态导入，通过模块的内联函数调用来分离代码 1：入口起点12345678910111213// 修改配置文件entry:&#123; index:&#x27;./src/index.js&#x27;, another:&#x27;./src/another-module.js&#x27; &#125;, output:&#123; filename:&#x27;[name].bundle.js&#x27;, path:path.resolve(__dirname,&#x27;./dist&#x27;), clean:true, assetModuleFilename:&#x27;images/[contenthash][ext][query]&#x27; &#125;, // 在 another-bundle.js 和 index.js 中如果都引用了lodash 那么打包的体积就会增大 造成重复问题 2：防止重复配置dependOn，可以在多个chunk共享模块 12345678910111213141516// 设置lodash为共享模块 会在dist下生成shared.bundle.jsentry:&#123; index:&#123; import:&#x27;./src/index.js&#x27;, dependOn:&#x27;shared&#x27; &#125;, another:&#123; import:&#x27;./src/another-module.js&#x27;, dependOn:&#x27;shared&#x27; &#125;, shared: &#x27;lodash&#x27;, // index:&#x27;./src/index.js&#x27;, // another:&#x27;./src/another-module.js&#x27;&#125;,// 但是这种方式需要手动配置共享文件 可以利用SplitChunksPlugin插件将公共依赖模块提取到已有或者是新生成的chunk 3：动态导入当涉及到动态拆分代码时，需要使用es的import或者webpack的遗留功能require.ensure 123// 1:importimport &#x27;./async-module&#x27; // 内部包含js代码// 2:require.ensure 4：懒加载在一开始不加载，在完成了某些操作之后再加载，优化响应速度 123456789const btn = document.createElement(&#x27;button&#x27;)btn.textContent = &#x27;点击执行加法&#x27;btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; import(/* webpackChunkName: &#x27;math&#x27; */ &#x27;./math.js&#x27;).then((&#123;add&#125;)=&gt;&#123; console.log(add(10,30)) &#125;)&#125;)// webpack 魔法注释： webpackChunkName: &#x27;math&#x27; ,告诉webpack打包生成的文件名为 math// npx webpack打包完以后，在浏览器点击这个按钮才会引入并运行math.bundle.js 5：预获取&#x2F;预加载模块webpack4.6增加了对预获取和预加载的支持 使用prefetch和preload 1234567891011121314// prefetch 添加该魔法注释以后 浏览器回在闲置时间自动下载该math.js文件btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; import(/* webpackChunkName: &#x27;math&#x27;, webpackPrefetch: true */ &#x27;./math.js&#x27;).then((&#123;add&#125;)=&gt;&#123; console.log(add(10,30)) &#125;)&#125;)// preloadpreload是当下时刻，prefetch是未来的时刻preload立即下载，prefetch是闲置时下载preload加载方式是并行的，prefetch是主chunk结束后执行import(/* webpackChunkName: &#x27;print&#x27;, webpackPreload: true */ &#x27;./print.js&#x27;).then((&#123;print&#125;)=&gt;&#123; print()&#125;) &#x2F;&#x2F; prefetch 闲置加载 &#x2F;&#x2F; preload 并行加载 是和index.bundle.js一起加载的 缓存输出文件文件名123456// 可以通过修改替换outpur中的filename的substitutions设置，定义输出名称// webpack提供了一个substitution(可替换模板字符串的方式)// 通过括号字符串来模板化文件名，[contenthash] ，substitution会根据资源内容创建出唯一hash，当资源内容变化时，[conetenthash]会自动发生变化output:&#123; filename:&#x27;[name].[contenthash].js&#x27;, &#125;, 缓存第三方库在webpack中比较推荐将lodash等第三方库提取到一个单独的chunk中，利用client的长效缓存机制，减少不做修改的文件的请求 123456789101112131415// 在optimization.splitChunks 添加如下 cacheGroups 参数并构建optimization:&#123; // minimizer:[ // new CssMinimizerPlugin() // ], splitChunks:&#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27;, &#125;, &#125;, &#125; &#125;, 将js文件放置到一个文件夹中123output: &#123; filename: &#x27;scripts/[name].[contenthash].js&#x27;,&#125;, 拆分开发环境和生产环境配置目前只能手动调整mode切换开发环境和生产环境，考虑到很多配置在开发与生产环境不一样，因此需要区分开发和生产环境以便更灵活的打包 公共路径12345678910111213141516171819// 在IE情况下// publicPath 可以用来指定应用程序中所有资源的基础路径// 基于环境配置，如果在开发环境将assets目录下的文件夹托管至CDN，那么如何使用// environment variable(环境变量)// webpack.config.js中import &#123; webpack &#125; from &#x27;webpack&#x27;const ASSET_PATH = process.env.ASSET_PATH || &#x27;/&#x27;output:&#123; filename:&#x27;scripts/[name].[contenthash].js&#x27;, publicPath:ASSET_PATH&#125;,plugins: [ // 这可以帮助我们在代码中安全地使用环境变量 new webpack.DefinePlugin(&#123; &#x27;process.env.ASSET_PATH&#x27;: JSON.stringify(ASSET_PATH), &#125;),],// Automatic publicPathwebpack 会自动根据import.meta.url 、 document.currentScript 、 script.src 或者self.location 变量设置 publicPath。我们所需要做的是将 output.publicPath设为 &#x27;auto&#x27;// 在IE情况下，不支持document.currentScript，这时需要引入polyfill，例如currnetScript Polifill 环境变量想要消除webpack.config.js在开发环境和生产环境之间的差异，需要环境变量environment variable 12345678910// npx webpack --env goal=local --env production --progress// 可以通过该方式给webpack配置环境变量// 通常module.exports 指向一个对象，想要使用env变量，那么就需要将module.exports转换成一个函数module.exports = () =&gt; &#123; return &#123; ...... mode:env.production ? &#x27;production&#x27; : &#x27;development&#x27; ...... &#125;&#125; 拆分配置文件目前不管是开发环境还是生产环境，使用的都是同一个配置文件，我们需要创建新的文件区分 webpack.config.dev.js webpack.config.prod.js 123456// ...文件忽略 在生产环境可以配置如下信息，隐藏webpack性能提示信息performance: &#123; hints:false&#125;,npx webpack serve -c ./config/webpack.config.dev.js // 执行开发环境配置npx webpack serve -c ./config/webpack.config.prod.js // 执行生产环境配置 npm脚本1234567// 每次打包时都要npx xxxxxx// 在package.json中配置命令&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack serve -c ./config/webpack.config.dev.js&quot;, &quot;build&quot;: &quot;webpack -c ./config/webpack.config.prod.js&quot;&#125;// npm run build 完美！ 提取公共配置在webpack.config.dev.js 和 webpack.config.prod.js 中存在大量相同配置webpack.config.common.js 123456// 新建webpack.config.common.js 抽取dev和prod中相同的部分......此处省略一万字//改写webpack.config.dev.js......此处省略一万字//改写webpack.config.prod.js......此处省略一万字 合并配置文件1234567891011121314151617// 在代码拆分完毕后 如何保证合并没有问题呢？利用webpack-merge// npm install webpack-merge// 创建webpack.config.jsconst &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const commonConfig = require(&#x27;./webpack.config.common.js&#x27;)const productionConfig = require(&#x27;./webpack.config.prod.js&#x27;)const developmentConfig = require(&#x27;./webpack.config.dev&#x27;)module.exports = (env) =&gt; &#123; switch(true) &#123; case env.development: return merge(commonConfig, developmentConfig) case env.production: return merge(commonConfig, productionConfig) default: throw new Error(&#x27;No matching configuration was found!&#x27;); &#125;&#125; 内卷无出路，躺平才是真……","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://222cabbage.github.io/categories/Webpack/"}],"tags":[{"name":"Webpack学习","slug":"Webpack学习","permalink":"https://222cabbage.github.io/tags/Webpack%E5%AD%A6%E4%B9%A0/"}]},{"title":"实现自己的脚手架","slug":"Node4","date":"2022-05-28T15:15:09.000Z","updated":"2022-05-29T15:59:52.943Z","comments":true,"path":"2022/05/28/Node4/","link":"","permalink":"https://222cabbage.github.io/2022/05/28/Node4/","excerpt":"","text":"实现自己的脚手架! &#x2F;&#x2F; sha-bang指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env node 固定写法console.log(&#x27;cabbage&#x27;)终端执行npm link 将package下的bin配置的指令与环境变量匹配做链接使用第三方库快速构建命令commandernpm install commanderconst program = require(&#x27;commander&#x27;)program.version(require(&#x27;./package.json&#x27;).version) // 动态获取版本号program.option(&#x27;-c --cabbage&#x27;,&#x27;a cabbage cli，菜的脚手架&#x27;) //设置help指令cabbage --versioncabbage --helpprogram.on(&#x27;--help&#x27;,()=&gt;&#123; //监听命令 console.log(&#x27;使用了--help&#x27;)&#125;)cabbage create demo配置命令后需要执行git clone ，npm install，npm run serve如何让git clone？ 需要第三方库的支持npm install download-git-repo......中间省略一万字 字儿太难打了新知识：EJS模板，新建组件，页面，路由文件，vuex文件都需要一个模板最后实现了一个脚手架，但是存在一些问题，似乎是包的版本太老了......等以后再弄一个完整版的脚手架吧，现在的顶多算bug版的脚手架发布到npm上了，如果感兴趣可以看看，但是不建议下载，有点小问题影响使用","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"包管理工具","slug":"Node3","date":"2022-05-23T05:34:13.000Z","updated":"2022-05-28T15:13:47.866Z","comments":true,"path":"2022/05/23/Node3/","link":"","permalink":"https://222cabbage.github.io/2022/05/23/Node3/","excerpt":"","text":"包管理工具如何将自己封装好的模块化的工具分享给其他人？ github？手动下载引入 npm？yyds npm init 一直回车 或者 npm init -y npm Install packagename –save-d npm install packagename -S &#x2F; -D 12345678910111213141516171819202122// console.log(process)// const path = require(&#x27;path&#x27;)// console.log(__dirname)// path.resolve(__dirname,&#x27;./a.txt&#x27;)// npm install 原理 // 帮助我们执行了什么操作// npm 从5开始支持缓存策略 因为yarn的压力// 判断有无package.lock 检测依赖关系 查找缓存 构建依赖关系 压缩到nodemodules 如果没有缓存则去官网仓库下载到本地建立缓存// npm config get cache 获取缓存路径// 卸载包 npm uninstall packagename --save-dev// 强制重新build npm rebuild// 清除缓存 npm cache clean// yarn 解决早期npm下载慢 依赖等问题// yarn add / remove// cnpm 淘宝镜像china npm// npm install cnpm -g --register=&quot;&quot; // 查看当前npm镜像// npm config get registry// npm config set registry 地址// npx npm5.2之后自带的一个命令","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"基于uniapp和uview1.0的简易表单生成器","slug":"Component1","date":"2022-05-17T16:51:43.000Z","updated":"2022-05-17T16:55:24.158Z","comments":true,"path":"2022/05/18/Component1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/Component1/","excerpt":"","text":"基于uniapp和uview1.0的简易表单生成器在新的项目中，有的表单项相同，那么能不能将表单form-item循环生成出来？只需要传递配置项与规则即可自动生成 说干就干 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221​```//表单Form.vue封装 基于uview1.0的input输入框 可以传递类型为text，textarea或者select下拉框//其他类型需要使用插槽或者其他方式插入 可以绑定form数据&lt;template&gt; &lt;view class=&quot;&quot;&gt; &lt;view class=&quot;formbox&quot;&gt; &lt;u-form :model=&quot;form&quot; ref=&quot;uForm&quot; label-width=&quot;150rpx&quot;&gt; &lt;u-form-item v-for=&quot;(item,index) in formItems&quot; :key=&quot;index&quot; :label=&quot;item.labelName&quot; :prop=&quot;item.prop&quot; :border-bottom=&quot;item.borderBottom&quot; :label-width=&quot;item.labelWidth&quot; :style=&quot;&#123;&#x27;position&#x27; : item.prop === &#x27;des&#x27; ? &#x27;relative&#x27; : &#x27;&#x27; &#125;&quot; &gt; &lt;u-input v-if=&quot;item.showInput&quot; v-model=&quot;form[item.prop]&quot; :placeholder=&quot;item.placeholder&quot; :type=&quot;item.type&quot; :border=&quot;item.border&quot; :height=&quot;item.height&quot; :class=&quot;item.class&quot; :maxlength=&quot;item.maxlength&quot; :custom-style=&quot;item.inputStyle ? item.inputStyle : null&quot; :clearable=&quot;false&quot; @click=&quot;clickChange(item)&quot;/&gt; &lt;view v-if=&quot;item.prop === &#x27;fileList&#x27;&quot; class=&quot;filebox&quot;&gt; &lt;view class=&quot;title&quot;&gt; 请上传附件（&#123;&#123; fileLength &#125;&#125;/5） &lt;/view&gt; &lt;view class=&quot;&quot;&gt; &lt;u-upload ref=&quot;uUpload&quot; :action=&quot;action&quot; :auto-upload=&quot;false&quot; max-count=&quot;5&quot; @on-list-change=&quot;imgChange&quot; &gt;&lt;/u-upload&gt; &lt;/view&gt; &lt;view class=&quot;uploadtip&quot;&gt; &lt;u-icon name=&quot;info-circle&quot; color=&quot;#F7B500&quot; size=&quot;26&quot; style=&quot;margin-right: 12rpx;&quot; &gt;&lt;/u-icon&gt; 附件支持图片和视频,支持jpg/png/mp4格式 &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;countbox&quot; v-if=&quot;item.prop === &#x27;des&#x27;&quot;&gt; &#123;&#123; form.des.length ? form.des.length : 0 &#125;&#125;/300 &lt;/view&gt; &lt;/u-form-item&gt; &lt;/u-form&gt; &lt;u-picker mode=&quot;time&quot; :params=&quot;params&quot; v-model=&quot;showList[&#x27;timeshow&#x27;]&quot; @confirm=&quot;timechange&quot; @cancel=&quot;timecancel&quot;&gt;&lt;/u-picker&gt; &lt;view v-if=&quot;methodsList.length&quot;&gt; &lt;u-action-sheet v-for=&quot;(item,index) in methodsList&quot; :key=&quot;index&quot; :list=&quot;paramsData[item.propList]&quot; v-model=&quot;showList[item.prop + &#x27;show&#x27;]&quot; @click=&quot;selectchange&quot; &gt;&lt;/u-action-sheet&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:&#123; // 传递的下拉框数据 paramsData:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, rules:&#123; type:Object, default:()=&gt;(&#123;&#125;) &#125;, formItems:&#123; type:Array, default:()=&gt;([]) &#125; &#125;, data()&#123; return &#123; // 数据绑定 form:&#123;&#125;, // 控制显示 showList:&#123;&#125;, params: &#123; year: true, month: true, day: true, hour: true, minute: true, second: false &#125;, // 非真实地址 action: &#x27;http://www.example.com/upload&#x27;, fileLength:0, methodsList:[], selectList:&#123;&#125; &#125; &#125;, watch:&#123;&#125;, onReady() &#123; this.formItems.forEach((items)=&gt;&#123; this.$set(this.form,items.prop,&#x27;&#x27;) this.$set(this.showList,items.prop + &#x27;show&#x27; ,false) this.form.fileList = [] if(items.type === &#x27;select&#x27;)&#123; if(items.prop === &#x27;time&#x27;) return const dataStr = items.prop + &#x27;List&#x27; const fnStr = items.prop + &#x27;change&#x27; this.methodsList.push(&#123; prop:items.prop, propList:dataStr &#125;) &#125; &#125;) setTimeout(()=&gt;&#123; this.$refs.uForm.setRules(this.rules); &#125;,500) &#125;, methods:&#123; clickChange(item)&#123; this.selectList = &#123; prop:item.prop, formName:item.prop + &#x27;List&#x27; &#125; this.showList[item.prop + &#x27;show&#x27;] = true &#125;, selectchange(index)&#123; if(this.selectList)&#123; this.form[this.selectList.prop] = this.paramsData[this.selectList.formName][index].text; &#125; &#125;, timechange(obj)&#123; let timestr = Object.values(obj).join(&#x27;-&#x27;) this.form.time = timestr &#125;, timecancel()&#123; this.show2 = false &#125;, // 上传图片变化 imgChange(lists,name)&#123; this.fileLength = lists.length this.form.fileList = lists &#125;, validateForm()&#123; let flag this.$refs.uForm.validate(valid =&gt; &#123; if (valid) &#123; // 上传文件 // his.$refs.uUpload[0].upload() flag = true &#125; else &#123; flag = false &#125; &#125;) return flag &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import &#x27;./index.scss&#x27;&lt;/style&gt;//传入配置项 验证规则 export const rules = &#123; content: [ &#123; required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;,&#x27;change&#x27;] &#125; ], ...... fileList:[ &#123; type:&#x27;array&#x27;, required: true, message: &#x27;&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125; ], &#125;//表单配置 export const formItems = [ ...... &#123; labelName:&#x27; &#x27;, labelWidth:&#x27;0&#x27;, type:&#x27;textarea&#x27;, prop:&#x27;content&#x27;, placeholder:&#x27;默认文字&#x27;, height:&#x27;420&#x27;, class:&#x27;desbox&#x27;, border:false, borderBottom:false, maxlength:&#x27;300&#x27;, showInput:true, inputStyle:&#123; &#x27;background&#x27;: &#x27;#F5F5F5&#x27;, &#x27;border-radius&#x27;:&#x27;8px&#x27;, &#x27;padding&#x27;:&#x27;22rpx 26rpx&#x27; &#125; &#125; ]","categories":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}],"tags":[{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"}]},{"title":"JS运算方法-解决小数点运算精度问题","slug":"tips1","date":"2022-05-17T16:39:07.000Z","updated":"2022-05-17T16:51:21.090Z","comments":true,"path":"2022/05/18/tips1/","link":"","permalink":"https://222cabbage.github.io/2022/05/18/tips1/","excerpt":"","text":"解决小数点精度问题的JS方法一开始学JS的时候也遇到过小数点精度运算的问题，但是没怎么注意，后来在实习时公司的一个项目需要做到金额的运算 有的金额涉及到了小数点 后运算出的结果会带有很多位小数点 因此就有了这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106解决小数点计算精度问题/** * method ** * add / subtract / multiply /divide * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */export const floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123; times: 1, num: 0 &#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + &#x27;&#x27; var dotPos = strfi.indexOf(&#x27;.&#x27;) var len = strfi.substr(dotPos + 1).length var times = Math.pow(10, len) var intNum = Number(floatNum.toString().replace(&#x27;.&#x27;, &#x27;&#x27;)) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case &#x27;add&#x27;: if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case &#x27;subtract&#x27;: if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case &#x27;multiply&#x27;: result = (n1 * n2) / (t1 * t2) return result case &#x27;divide&#x27;: result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, &#x27;add&#x27;) &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, &#x27;subtract&#x27;) &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, &#x27;multiply&#x27;) &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, &#x27;divide&#x27;) &#125; // exports 暴露出加减乘除四个方法 其他页面引入解构调用 return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;","categories":[{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"}],"tags":[{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"}]},{"title":"Node内置模块","slug":"Node2","date":"2022-05-15T07:16:27.000Z","updated":"2022-05-23T05:35:33.585Z","comments":true,"path":"2022/05/15/Node2/","link":"","permalink":"https://222cabbage.github.io/2022/05/15/Node2/","excerpt":"","text":"Node内置模块path：路径12345678910111213141516171819const path = require(&#x27;path&#x27;)//获取路径信息const filepath = &#x27;./1/2/3.text&#x27;console.log(path.dirname(filepath))./1/2console.log(path.basename(filepath))3.textconsole.log(path.extname(filepath)).text//join路径拼接const path1 = &#x27;/hello&#x27;const path2 = &#x27;/world&#x27;const filepath = path.join(path1,path2)//resolve拼接const path1 = &#x27;/a&#x27;const path2 = &#x27;/b&#x27;const dirname = path.resolve(path1,path2)resolve与join的区别resolve会帮助查询拼接字符串中有没有最前方的路径拼接符 &#x27;/user&#x27; 自动识别路径 htttp：1 fs：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//文件系统const fs = require(&#x27;fs&#x27;)//同步读取const fileData = fs.stateSync(path) // 后续代码被阻塞//异步读取fs.stat(filepath,(err,info)=&gt;&#123; if(err)&#123; console.log(err) return false &#125; console.log(info)&#125;)//promise方式fs.promises.stat(filepath).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;)//文件描述符//返回描述符 fs.open(filepath,(err,fs)=&gt;&#123; if(err)=&gt;&#123; console.log(err) return false &#125; //通过描述符获取文件信息1 fs.fstat(fd,(err,info)=&gt;&#123; console.log(info//文件信息) console.log(info.isDirectory()//判断是否是文件夹) &#125;)&#125;)//文件读写const str = &#x27;123&#x27;options有两个选项&#x27;flag:w打开文件写入 默认值w+打开文件进行读写 如果不存在则创建并写入r+打开文件进行1读写，如果不存在则抛出异常r打开文件读取，读取时默认值a打开要写入的文件，将流放在文件末尾，如果不存在则创建文件a+打开文件以进行读写，将流放在末尾，如果不存在则创建文件fs.writeFile(&#x27;/1.txt&#x27;,content,&#123;flag:&#x27;a&#x27;,encoding:&#x27;&#x27;&#125;,(err)=&gt;&#123; if(err)&#123; console.log(err) &#125;&#125;)//文件读取fs.readFile(&#x27;&#x27;,&#123;encoding:&#x27;utf-8&#x27;&#125;,(err,data)=&gt;&#123; console.log(data) //buffer二进制在不使用encoding的情况下&#125;)//文件夹操作1：创建文件夹const dirname = &#x27;./why&#x27;if(fs.existsSync(dirname))&#123; fs.mkdir(dirname,err =&gt; &#123; console.log(err) &#125;)&#125;fs.mkdir //盲猜可以弄个脚本自动生成组件文件夹名2：读取文件夹中所有文件const readdir(dirname,(err,files)=&gt;&#123; console.log(files)//获取所有文件&#125;)//递归调用读取文件名const getFiles = (dirname)=&gt;&#123; fs.readdir(firname,&#123;withFileTypes:true&#125;,(err,files)=&gt;&#123; console.log(files) file.forEach(item=&gt;&#123; if(item.isDirectory())&#123; const filepath = path.resolve(dirname,item.name) getFiles(filepath) &#125;else&#123; console.log(item.name) &#125; &#125;) &#125;)&#125;getFiles(dirname)3：文件夹重命名fs.rename(旧名称，新名称，err=&gt;&#123; console.log(err)&#125;)fs.rename(&#x27;./why&#x27;,&#x27;./kobe&#x27;,err=&gt;&#123; console.log(err)&#125;) events：123456789101112131415161718192021222324//发出事件与监听事件const EnentEmitter = require(&#x27;event&#x27;)const emitter = new EventEmitter()//监听//emitter.addEventLister //addEventListener是on的简写emitter.on(&#x27;click&#x27;,(args)=&gt;&#123; console.log(&#x27;监听到了click事件&#x27;,args)&#125;)//发出emitter.emit(&#x27;click&#x27;,&quot;hao&quot;)//关闭emitter.off(&#x27;事件名&#x27;)//获取信息获取注册的事件console.log(emitter.eventNames())console.log(emitter.listenerCount(&#x27;click&#x27;)) //获取数量console.log(emitter.listeners(&#x27;click&#x27;))emitter.once // 只监听一次emitter.prependListener //将本次放在最前面emitter.removeAllListeners() //移除所有事件 未完待续……","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据结构","slug":"algorithm1","date":"2022-05-14T07:04:01.000Z","updated":"2022-05-14T07:46:18.604Z","comments":true,"path":"2022/05/14/algorithm1/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/algorithm1/","excerpt":"","text":"数据结构走起！Loading……","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS面试题集合","slug":"Face","date":"2022-05-13T17:40:15.000Z","updated":"2022-05-14T07:09:37.265Z","comments":true,"path":"2022/05/14/Face/","link":"","permalink":"https://222cabbage.github.io/2022/05/14/Face/","excerpt":"","text":"闲了很久，来看看JS面试题 涩涩狗子镇楼！1：延迟加载JS的方式？async 与 defer async 是解析与渲染DOM结构同时进行 defer虽然也是解析script脚本与渲染DOM同时进行，但是会等待DOM结构渲染完成以后再去加载script 12&lt;script defer src=&quot;../&quot;&gt;&lt;script&gt;&lt;script async src=&quot;../&quot;&gt;&lt;script&gt; 2：数据类型javascript数据类型分为基本类型与引用类型两大类 基本类型：string，number，boolean，null，undefined，symbol，bigInt(存在争论，有些人认为不应该) 引用类型：object（object是一个大类，包含对象，数组，函数等引用类型） 3：null和undefined的区别最初javascript木有undefined类型，是作者后续添加的，他本人认为不能将一切表示为无的值都设置为null，可以将无的基本类型设置为undefined 4：&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; 的区别&#x3D;&#x3D; 在数据比较时，会隐式转换（调用valueof进行转换对比）,只比较值不比较类型 而&#x3D;&#x3D;&#x3D;比较类型也比较值 必须到完全的相同，因此在项目中比较两个值应该采用&#x3D;&#x3D;&#x3D;的方式 1234let a = 2if（a == &#x27;2&#x27;）&#123; console.log(&#x27; a = &#x27;2&#x27; &#x27;)&#125; 5：微任务和宏任务script脚本中包含同步与异步逻辑，页面会首先执行同步代码，再执行异步代码 而异步代码又区分为微任务和宏任务，与事件循环机制相关 在执行宏任务之前，会查看页面有没有未执行的微任务，先清空页面微任务再执行宏任务 微任务：Promise.then 宏任务：定时器，事件 123456789101112131415161718setTimeout(()=&gt;&#123; console.log(&#x27;123&#x27;)&#125;,2000)new Promise((resolve,reject)=&gt;&#123; console.log(&#x27;promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then1&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then2&#x27;) resolve()&#125;)console.log(&#x27;同步&#x27;)result: &#x27;promise&#x27; &#x27;同步&#x27; &#x27;then1&#x27; &#x27;then2&#x27; &#x27;123&#x27; 6：作用域:smile_cat:1：除了函数外 js是没有块级作用域的 12345678910function aa()&#123; let a = 10&#125;aa()console.log(a) ::a is not definedfor(var i = 1; i &lt; 10 : i++)&#123; &#125;console.log(i) : i = 10 2：作用域链 内部可以访问外部变量 外部无法访问内部变量 从内到外依次查找 遵循内部优先 12345678let a = 10function fn（）&#123; function fnn（）&#123; console.log(a) &#125;fnn()&#125;fn() : 10 3；声明变量不带var 那么就是挂载window上 任意位置都能访问 var a &#x3D; b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 window.b &#x3D; 10 var a,b &#x3D; 10 &#x3D;&#x3D;&#x3D; var a &#x3D; 10 var b &#x3D; 10 4：js有变量提升 国外称为变量悬挂声明 123456function fn()&#123; //var str console.log(str) // undefined var str = 20&#125;fn() 5：优先级 声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升 7：对象1234567console.log([1,2,3] === [1,2,3]) //false 因为两个对象都是new出来的并不相同var a = &#123; a：1&#125;var b = aconsole.log(a === b) //true 因为史诗同一个引用对象 因此相同 对象的key都是字符串类型 1234567891011有趣的面试题var a = &#123;&#125;var b = &#123; key：&#x27;a&#x27;&#125;var c = &#123; key:&#x27;c&#x27;&#125;a[b] = &#x27;123&#x27; // a[obj obj] = &#x27;123&#x27;a[c] = &#x27;456&#x27; // a[obj obj] = &#x27;456&#x27;console.log(a[b]) //console.log(a[obj obj]) 对象是如何查找某个属性？ 对象是通过构造函数生成的 123456789function Fun（）&#123; this.a = &#x27;fun&#x27;&#125;Fun.prototype.a = &#x27;fun原型&#x27;let obj = new Fun()obj.a = &#x27;对象本身&#x27;obj.__proto__.a = &#x27;对象原型&#x27;console.log(obj.a) // &#x27;对象本身&#x27;先查找对象本身 =&gt; 构造函数的内部 =&gt; 对象的原型 =&gt; 构造函数的原型 =&gt; 对象上一层原型 8：作用域 + this指向 + 原型Loading—— 9：判断数组方法使用场景：虚拟dom判断子节点是不是数组 1：isArray 2：instanceof [坑多，typeof更多 不建议用] 3：原型判断 4:：isPrototypeOf() 5：constructor 123456let arr = [1,2,3]console.log(Array.isArray(arr)) //trueconsole.log(arr instanceof Array) //trueconsole.log(Object.prototype.toString.call(arr).indexOf(&#x27;Array&#x27;) != -1) //8 [Object Array]console.log(Array.prototypee.isPrototypeOf(arr)) console.log(arr.constructor.toString().indexOf(&#x27;Array&#x27;) &gt; -1) 10：slice与spliceslice的作用，splice是否会改变原数组 12345678//slice截取作用 参数可以写一个 代表从该参数位置开始截取到最后let arr = [a,b,c,d]let arr2 = arr.slice(1,3) //从索引1开始 截取到3之前一位 [b,c] 返回新数组//splice 删除 ，插入，替换 会改变原数组let arr2 = [a,b,c,d]let arr3 = arr2.splice(1,1) // b 返回删除的元素数组 原本的arr2 [a,c,d]let arr4 = arr2.splice(1,1,&#x27;你好&#x27;) // 从1开始 删除一个元素 在原本位置插入你好 11：多维数组最大值12345678910111213141516let arr = [ [4,4,5], [10,123,123], [123123,12,323,123]]分别找到每个数组最大的值输出[5,123,123123]code：function(arr)&#123; let newArr = [] arr.forEach((iitem,index)=&gt;&#123; newArr.push(Math.max(...item)) &#125;) reurn newArr&#125; 12：字符串新增方法实现某些功能给字符串定义一个方法addStart，当传入该方法一个字符串时，返回当前字符串+参数前缀 123String.prototype.addStr = function(str)&#123; return str + this&#125; 13：找出字符串出现最多次数字符和次数1234567891011121314151617181920212223241:var str = &#x27;111222333333444444444444&#x27;var obj = &#123;&#125;for(var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++ &#125;else&#123; obj[str[i]] = 1 &#125;&#125;console.log(obj) // &#123;a:b:c:d:&#125;///统计最大值var max = 0for(var k in obj)&#123; if(max &lt; obj.key)&#123; max = obj.key &#125;&#125;for(var key in obj)&#123; if(mx == obj[key])&#123; console.log(obj[key]) // 最多次数的字符 console.log(max) //最次数 &#125;&#125; 14：new操作符1：创建一个空的对象 2：将空对象的原型指向构造函数原型 3：将空对作为构造函数上下文（改变this指向） 4：对构造函数有返回值的处理判断 如果这个构造函数返回基本类型 那么会忽略 如果是引用类型则会返回这个引用类型 new失效 1234567891011121314151617181920212223function Fo（）&#123; &#125;console.log(new Fo()) //obj 创建一个空的对象console.log(new Fo.__proto__ === Fo.prototype)console.log()实现一个相同的函数function Fun(age,name)&#123; this.age = age this.name = name&#125;function create(fn,..args)&#123; //创建空对象 var obj = &#123;&#125; //将空对象原型指向构造函数原型 Object.setPrototypeOf(obj,fn.prototype) //改变this指向 var result = fn.apply(obj.args) //最后处理 return result instanceof Object ? result : obj&#125;function(create(Fun,18,&#x27;lisi&#x27;)) 15：闭包1：闭包是什么 一个函数加上到创建函数作用域的连接 闭包关闭了函数在自由变量 js中尽量不要写全局变量 因为系统并不知道什么时候会垃圾回收 2：闭包可以解决什么问题【优点】 内部函数可以访问到外部函数局部变量 3：闭包的缺点 变量会驻留在内存中 造成内存损耗问题 内存泄露是在ie的情况 解决方式手动清空 123456789101112131415161718192021222324function a ()&#123; var b = 10 return function()&#123; console.log(b) &#125;&#125;a()() // a()执行完以后没有销毁 因此a()()能够打印出b//优点let lis = document.getElementsByTagName(&#x27;li&#x27;)for(var i = 0; i &lt; 3; i++)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125;&#125;改造成闭包的形式for(var i = 0; i &lt; 3; i++)&#123; function((i)&#123; lis[i].onclick = function()&#123; console.log(i) // 3 &#125; lis[i] = null //手动清空 &#125;)(i)&#125; 16：原型链17：js继承方式18：call，apply，bind区别19：sort背后原理20：深拷贝与浅拷贝21：本次存储localStorage&#x2F;sessionStorage与cookie区别未完待续……","categories":[{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"HaoUI第二次尝试","slug":"HaoUI2","date":"2022-05-13T04:08:17.000Z","updated":"2022-05-13T06:16:36.669Z","comments":true,"path":"2022/05/13/HaoUI2/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI2/","excerpt":"","text":"之前完成了h-icon与h-button的封装，今天来尝试一下完成HaoUI其他组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"HaoUI开始","slug":"HaoUI1","date":"2022-05-12T17:45:55.000Z","updated":"2022-05-13T04:13:48.598Z","comments":true,"path":"2022/05/13/HaoUI1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/HaoUI1/","excerpt":"","text":"HaoUI h-icon 与 h-buttonh-icon 图标组件 h-button按钮组件","categories":[{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]},{"title":"邂逅Node","slug":"Node1","date":"2022-05-12T17:20:29.000Z","updated":"2022-05-15T07:18:40.385Z","comments":true,"path":"2022/05/13/Node1/","link":"","permalink":"https://222cabbage.github.io/2022/05/13/Node1/","excerpt":"","text":"邂逅Node1：浏览器内核Geoko，Trident，Webkit，Blink 但是前端经常提到的浏览器内核一般是浏览器的排版引擎 排版引擎 ，浏览器引擎，页面渲染引擎，样排引擎 2：比较常见的javascript引擎SpiderMonkey：js作者开发 Chakra：微软开发 JavascriptCore：Webkit中的js引擎 apple开发 V8：谷歌的，脱颖而出 V8执行js代码的原理 3：Nodenode是基于v8引擎的js运行环境 如果想在一台电脑运行多个node版本 那么可以借助nvm与n工具 但是这两个工具不支持windows，不过有其他人开发出了支持windows的版本 4：全局对象和模块化开发node index.js env&#x3D;development 可以在后面跟随传递参数 在index.js中根据console.log(process.argv)获取 console.clear() 清空 console.trace() 追踪 打印函数调用栈 常见全局对象require，__dirname，module，URL，exports等，可以去官网查看更多全局对象 模块化最终目的：将程序划分为一个个结构，每个结构包含自己的逻辑到&#x3D;代码，不会影响到其他作用域 可以暴露出变量，函数，对象供其他结构导入使用 js缺陷：var定义的变量作用域问题，没有模块化的问题 可以用立即执行函数解决 1234567var module = (function()&#123; var name = &#x27;zhangsan&#x27; var age = &#x27;21&#x27; return &#123; name,age &#125;&#125;)() Commonjsexports，module.exports导出 require导入 12345a.jsexports.name = &#x27;aaa&#x27;b.jslet a = require(&#x27;a.js&#x27;)console.log(a.name) // &#x27;aaa&#x27; module的原理 每个模块默认有个module指向一个空对象 exports.name &#x3D; name 是将空对象中的name 变为 name require是想办法将这个对象作为返回值返回 实际上是浅层拷贝 module.exports 与 exports 区别 exports是Module的一个实例 实际上exports是使用的module.exports 源码中将 module.exports &#x3D; exports require细节 require的查找规则 1：path&#x2F;http模块 2：.&#x2F; ..&#x2F; &#x2F; 开头 有后缀名按照后缀名查找 否则先查找不带后缀名 &#x3D;&gt; .js &#x3D;&gt; .json &#x3D;&gt; .node 如果是目录名 那么就会去该目录查找.js .json .node 3：既不是模块也不是目录 那么就会去node_modules查找 &#x2F;&#x2F;not found 模块的引入查找是数据结构图的便遍历 广度优先和深度优先 Node是采用的深度优先 AMDrequire.js cuel.js CMDsea.js ES Module使用import 与 export 默认导出exort default 一个模块只能有一个 es module加载过程 是异步的script type&#x3D;”module” 相当于加了async 并不会影响加载 es modole 原理 123456789export &#123; name,age&#125; //相当于 &#123; const name = name, const age = age&#125;//如果是基本类型import &#123; name,age &#125; from &#x27;index.js&#x27;name = &#x27;123&#x27; // 语法错误 不能直接修改const的值 如果name是引用地址可以修改","categories":[{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"}],"tags":[{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"typescript","slug":"typescript","permalink":"https://222cabbage.github.io/categories/typescript/"},{"name":"vue框架源码","slug":"vue框架源码","permalink":"https://222cabbage.github.io/categories/vue%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"},{"name":"面试","slug":"面试","permalink":"https://222cabbage.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据库mysql的学习","slug":"数据库mysql的学习","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/categories/websocket/"},{"name":"Node","slug":"Node","permalink":"https://222cabbage.github.io/categories/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"https://222cabbage.github.io/categories/Webpack/"},{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/categories/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"utils","slug":"utils","permalink":"https://222cabbage.github.io/categories/utils/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"HaoUI","slug":"HaoUI","permalink":"https://222cabbage.github.io/categories/HaoUI/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://222cabbage.github.io/tags/ts/"},{"name":"Vue2源码","slug":"Vue2源码","permalink":"https://222cabbage.github.io/tags/Vue2%E6%BA%90%E7%A0%81/"},{"name":"面试题","slug":"面试题","permalink":"https://222cabbage.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"mysql","slug":"mysql","permalink":"https://222cabbage.github.io/tags/mysql/"},{"name":"websocket","slug":"websocket","permalink":"https://222cabbage.github.io/tags/websocket/"},{"name":"Node学习","slug":"Node学习","permalink":"https://222cabbage.github.io/tags/Node%E5%AD%A6%E4%B9%A0/"},{"name":"Webpack学习","slug":"Webpack学习","permalink":"https://222cabbage.github.io/tags/Webpack%E5%AD%A6%E4%B9%A0/"},{"name":"组件封装","slug":"组件封装","permalink":"https://222cabbage.github.io/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"JS方法技巧","slug":"JS方法技巧","permalink":"https://222cabbage.github.io/tags/JS%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"个人组件库","slug":"个人组件库","permalink":"https://222cabbage.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BB%84%E4%BB%B6%E5%BA%93/"}]}