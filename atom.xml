<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://222cabbage.github.io/atom.xml" rel="self"/>
  
  <link href="https://222cabbage.github.io/"/>
  <updated>2024-10-23T17:23:52.160Z</updated>
  <id>https://222cabbage.github.io/</id>
  
  <author>
    <name>不知名小白菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络相关知识（学自掘金小满zs）</title>
    <link href="https://222cabbage.github.io/2024/10/23/network1/"/>
    <id>https://222cabbage.github.io/2024/10/23/network1/</id>
    <published>2024-10-23T04:29:20.000Z</published>
    <updated>2024-10-23T17:23:52.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><h5 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h5><p><img src="https://s21.ax1x.com/2024/10/24/pAdHqKO.png"></p><h6 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h6><p>应用层就是我们使用最多的一层，例如ajax调用接口发送http请求，再比如域名系统DNS，邮件协议SMTP，webSocket长连接，SSH协议</p><h6 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h6><p>表示层主要做了几件重要的事情 安全，压缩，也是程序在网络中的一个翻译官。<br>1.安全 在你的数据发送之前进行加密，在接受者的表示层进行解密。<br>2.表示层还会对图片文件等格式进行解码和编码 例如 JPEG、ASCll 图片是人类能读懂的计算机需要转换成计算机能读懂的编码。</p><h6 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h6><p>会话层，是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方，与电话通话有点相似。<br>会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，以及当双方发生拥塞时仍然能保持对话。<br>会话层包含了一种称为检查点（Checkpoint） 的机制来维持可靠会话。检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或损坏时需要回滚以便恢复丢失或损坏数据的点，即断点下载的原理</p><h6 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h6><p>传输层主要就是定义我们的端口号，以及控流，和校验。<br>并且拥有两个熟知的协议 TCP UDP<br>TCP 是面向连接的协议并且TCP是可靠的<br>因为TCP会进行三次握手四次挥手所以是可靠的，但是这样会降低速度<br>UDP 具有较好的实时性 效率比TCP高<br>UDP是没有三次握手四次挥手的，故此不稳定，但是速度快 常用于直播，游戏</p><h6 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h6><p>网络层是最复杂的一层，在这一层就定义了我们的IP，220.xxx.xxx.xxx。<br>该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备<br>1.寻址：对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址）<br>2.路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。<br>我们的路由器就是在第三层工作的<br>在数据链路层的时候说过了如果所有的使用互联网的用户在同一个网段中，会产生广播风暴，所以要将用户进行划分，让他们在不同的网段中，自己在自己的小网段中广播。而互联网就是这无数的子网络构成的一个巨型网络。<br>在网络层中引入了一套新的地址，让我们能够区分不同的网段。这套地址就叫做“网络地址”，简称“网址”。<br>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。<br>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。<br>这一层中有一个规定网络地址的协议，叫做IP协议，它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。因为IPv4的地址已经不够用了，所以现在推广IPv6，</p><h6 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h6><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><p>MAC地址：每个网卡的唯一标识<br>有了Mac地址之后就可以知道谁是接收者，谁是发送者，并且知道了数据的内容并且进行了分组。</p><p>那么他如何进行传播数据，他是进行广播的方式进行传输,在局域网内所有的计算机都能收到消息</p><h6 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h6><p>物理层是直接和物理介质打交道的。</p><p>物理层的设备 网卡，网线，集线器，中继器，调制解调器</p><p>物理层信道，有线信道，光纤，无线电波</p><h5 id="TCP握手与挥手"><a href="#TCP握手与挥手" class="headerlink" title="TCP握手与挥手"></a>TCP握手与挥手</h5><h5 id="浏览器输入url到按下回车发生了什么"><a href="#浏览器输入url到按下回车发生了什么" class="headerlink" title="浏览器输入url到按下回车发生了什么"></a>浏览器输入url到按下回车发生了什么</h5><h6 id="强缓存，协商缓存"><a href="#强缓存，协商缓存" class="headerlink" title="强缓存，协商缓存"></a>强缓存，协商缓存</h6><h6 id="回流，重绘"><a href="#回流，重绘" class="headerlink" title="回流，重绘"></a>回流，重绘</h6><p>回流：页面部分或者重新渲染<br>重绘：只需要更新相应内容，不会导致整个页面更新</p><h5 id="CDN内容分发"><a href="#CDN内容分发" class="headerlink" title="CDN内容分发"></a>CDN内容分发</h5><p>寻求更近的资源服务器请求资源，减少请求延迟，提高用户体验。</p><h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><p>jsonp，原理是script的src不受跨域访问限制，只能发送get，不安全，不容易维护，后端返回一个函数，前端定义一个函数，后端吧值注入到前端函数参数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const jsonp = (name) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    script.src = &#x27;loacl..../jsonp?callback?=&#x27; + name</span><br><span class="line">    document.body.append(script)</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        window[name] = (data) =&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">jsonp(`callback$&#123;new Date().getTime()&#125;`).then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>前端代理<br>安装webpack和vite配置webpack.config.js和vite.config.js</p><p>后端解决<br>设置头，但是不安全</p><p>运维nginx</p><h4 id="xhr，fetch（掘金小满zs）"><a href="#xhr，fetch（掘金小满zs）" class="headerlink" title="xhr，fetch（掘金小满zs）"></a>xhr，fetch（掘金小满zs）</h4><p>application&#x2F;x-www-form-urlencoded , 表单数据<br>multipart&#x2F;form-data , 文件数据<br>fetch 的 API 设计更加现代化、简洁和易于使用，使用起来更加直观和方便。相比之下，XHR 的 API 设计比较繁琐，需要进行多个参数的配置和回调函数的处理。<br>fetch API 默认只支持 GET 和 POST 请求方法，而 XHR 则支持所有标准的 HTTP 请求方法。<br>在 fetch 中设置请求头部的方式更加清晰和直接，可以通过 Headers 对象进行设置，而 XHR 的方式相对较为繁琐。<br>在发送 POST 请求时，fetch API 要求将请求体数据作为参数传递给 fetch 方法中的 options 对象，而 XHR 可以直接在 send() 方法中设置请求体数据。<br>在解析响应数据时，fetch API 提供了多种方法，包括 .json(), .blob(), .arrayBuffer() 等，而 XHR 只支持文本和二进制数据两种数据类型。<br>在进行跨域请求时，fetch API 提供了一种简单而强大的解决方案——使用 CORS（跨域资源共享）头部实现跨域请求，而 XHR 则使用了一个叫做 XMLHttpRequest Level 2 的规范，在代码编写上相对较为繁琐。</p><h6 id="fetch-返回格式"><a href="#fetch-返回格式" class="headerlink" title="fetch 返回格式"></a>fetch 返回格式</h6><p>text(): 将响应体解析为纯文本字符串并返回。<br>json(): 将响应体解析为JSON格式并返回一个JavaScript对象。<br>blob(): 将响应体解析为二进制数据并返回一个Blob对象。<br>arrayBuffer(): 将响应体解析为二进制数据并返回一个ArrayBuffer对象。<br>formData(): 将响应体解析为FormData对象。</p><h4 id="sse，websocket（掘金小满zs）"><a href="#sse，websocket（掘金小满zs）" class="headerlink" title="sse，websocket（掘金小满zs）"></a>sse，websocket（掘金小满zs）</h4><p>SSE（Server-Sent Events）是一种用于实现服务器主动向客户端推送数据的技术，也被称为“事件流”（Event Stream）。它基于 HTTP 协议，利用了其长连接特性，在客户端与服务器之间建立一条持久化连接，并通过这条连接实现服务器向客户端的实时数据推送</p><h6 id="SSE-和-Socket-区别"><a href="#SSE-和-Socket-区别" class="headerlink" title="SSE 和 Socket 区别"></a>SSE 和 Socket 区别</h6><p>SSE（Server-Sent Events）和 WebSocket 都是实现服务器向客户端实时推送数据的技术，但它们在某些方面还是有一定的区别。</p><p>技术实现</p><p>SSE 基于 HTTP 协议，利用了其长连接特性，通过浏览器向服务器发送一个 HTTP 请求，建立一条持久化的连接。而 WebSocket 则是通过特殊的升级协议（HTTP&#x2F;1.1 Upgrade 或者 HTTP&#x2F;2）建立新的 TCP 连接，与传统 HTTP 连接不同。</p><p>数据格式</p><p>SSE 可以传输文本和二进制格式的数据，但只支持单向数据流，即只能由服务器向客户端推送数据。WebSocket 支持双向数据流，客户端和服务器可以互相发送消息，并且没有消息大小限制。</p><p>连接状态</p><p>SSE 的连接状态仅有三种：已连接、连接中、已断开。连接状态是由浏览器自动维护的，客户端无法手动关闭或重新打开连接。而 WebSocket 连接的状态更灵活，可以手动打开、关闭、重连等。</p><p>兼容性</p><p>SSE 是标准的 Web API，可以在大部分现代浏览器和移动设备上使用。但如果需要兼容老版本的浏览器（如 IE6&#x2F;7&#x2F;8），则需要使用 polyfill 库进行兼容。而 WebSocket 在一些老版本 Android 手机上可能存在兼容性问题，需要使用一些特殊的 API 进行处理。</p><p>安全性</p><p>SSE 的实现比较简单，都是基于 HTTP 协议的，与普通的 Web 应用没有太大差异，因此风险相对较低。WebSocket 则需要通过额外的安全措施（如 SSL&#x2F;TLS 加密）来确保数据传输的安全性，避免被窃听和篡改，否则可能会带来安全隐患。<br>总体来说，SSE 和 WebSocket 都有各自的优缺点，适用于不同的场景和需求。如果只需要服务器向客户端单向推送数据，并且应用在前端的浏览器环境中，则 SSE 是一个更加轻量级、易于实现和维护的选择。而如果需要双向传输数据、支持自定义协议、或者在更加复杂的网络环境中应用，则 WebSocket 可能更加适合。</p><h6 id="1-EventSource-构造函数"><a href="#1-EventSource-构造函数" class="headerlink" title="1. EventSource() 构造函数"></a>1. EventSource() 构造函数</h6><h6 id="2-EventSource-readyState-属性"><a href="#2-EventSource-readyState-属性" class="headerlink" title="2. EventSource.readyState 属性"></a>2. EventSource.readyState 属性</h6><h6 id="3-EventSource-close-方法"><a href="#3-EventSource-close-方法" class="headerlink" title="3. EventSource.close() 方法"></a>3. EventSource.close() 方法</h6><h6 id="4-EventSource-onopen-事件"><a href="#4-EventSource-onopen-事件" class="headerlink" title="4. EventSource.onopen 事件"></a>4. EventSource.onopen 事件</h6><h6 id="5-EventSource-onerror-事件"><a href="#5-EventSource-onerror-事件" class="headerlink" title="5. EventSource.onerror 事件"></a>5. EventSource.onerror 事件</h6><h6 id="6-EventSource-onmessage-事件"><a href="#6-EventSource-onmessage-事件" class="headerlink" title="6. EventSource.onmessage 事件"></a>6. EventSource.onmessage 事件</h6><p>以上就是 EventSource 对象的常用 API 介绍，需要注意的是，在使用 EventSource 对象的过程中，如果服务器没有正确地设置响应头信息（如：Content-Type: text&#x2F;event-stream），可能会导致 EventSource 对象无法接收到服务器发送的数据。</p><h4 id="navigator-sendBeacon（掘金小满zs）数据上报，用户行为性能数据监测"><a href="#navigator-sendBeacon（掘金小满zs）数据上报，用户行为性能数据监测" class="headerlink" title="navigator.sendBeacon（掘金小满zs）数据上报，用户行为性能数据监测"></a>navigator.sendBeacon（掘金小满zs）数据上报，用户行为性能数据监测</h4><p>在 web 开发中，我们经常需要将用户行为或性能数据上报到服务器。为了不影响用户体验，开发者通常会在页面卸载时进行数据上报。然而，传统的数据上报方式，如 XMLHttpRequest 或 Fetch API，容易受到页面卸载过程中的阻塞，导致数据丢失。为了解决这个问题，navigator.sendBeacon API 被引入，它可以在页面卸载时安全、可靠地发送数据。</p><p>navigator.sendBeacon 对比 Ajax fetch<br>优点</p><p>不受页面卸载过程的影响，确保数据可靠发送。<br>异步执行，不阻塞页面关闭或跳转。<br>能够发送跨域请求。</p><p>缺点</p><p>fetch 和 ajax 都可以发送任意请求 而 sendBeacon 只能发送POST<br>fetch 和 ajax 可以传输任意字节数据 而 sendBeacon 只能传送少量数据（64KB 以内）<br>fetch 和 ajax 可以定义任意请求头 而  sendBeacon 无法自定义请求头<br>sendBeacon 只能传输 ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams 类型的数据<br>如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效</p><p>navigator.sendBeacon 应用场景</p><p>发送心跳包：可以使用 navigator.sendBeacon 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。<br>埋点：可以使用 navigator.sendBeacon 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。<br>发送用户反馈：可以使用 navigator.sendBeacon 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</p><p>其他注意事项 type<br>ping请求 是html5 新增的 并且是sendBeacon 特有的 ping 请求 只能携带少量数据，并且不需要等待服务端响应，因此非常适合做埋点统计，以及日志统计相关功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;send&quot;&gt;发送&lt;/button&gt;</span><br><span class="line">const send = document.querySelector(&#x27;.send&#x27;)</span><br><span class="line">send.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    let data = JSON.stringify(&#123;name:&#x27;test&#x27;&#125;)</span><br><span class="line">    const blob = new Blob([data], &#123; type: &#x27;application/json&#x27; &#125;)</span><br><span class="line">    navigator.sendBeacon(&#x27;http://localhost:3000/api/beacon&#x27;,blob,&#123;</span><br><span class="line">        type:&quot;beacon&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>nodejs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import express from &#x27;express&#x27;;</span><br><span class="line">const app = express();</span><br><span class="line">app.post(&#x27;/api/beacon&#x27;, (req: any, res) =&gt; &#123;</span><br><span class="line">    console.log(req.body);</span><br><span class="line">    res.send(&#x27;ok&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Listening on port 3000&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h4&gt;&lt;h5 id=&quot;osi七层模型&quot;&gt;&lt;a href=&quot;#osi七层模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="计算机网路" scheme="https://222cabbage.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"/>
    
    
    <category term="计算机网路" scheme="https://222cabbage.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>git版本回退</title>
    <link href="https://222cabbage.github.io/2024/10/22/git1/"/>
    <id>https://222cabbage.github.io/2024/10/22/git1/</id>
    <published>2024-10-22T14:49:00.000Z</published>
    <updated>2024-10-22T14:57:04.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git版本回退"><a href="#git版本回退" class="headerlink" title="git版本回退"></a>git版本回退</h3><h5 id="git-checkout：切换分支或恢复文件到指定提交。"><a href="#git-checkout：切换分支或恢复文件到指定提交。" class="headerlink" title="git checkout：切换分支或恢复文件到指定提交。"></a>git checkout：切换分支或恢复文件到指定提交。</h5><p>git checkout 命令用于切换分支或恢复工作目录中的文件到指定的提交。</p><p>恢复工作目录中的文件到某个提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt; -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>例如，将 file.txt 恢复到 abc123 提交时的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout abc123 -- file.txt</span><br></pre></td></tr></table></figure><p>切换到特定提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout abc123</span><br></pre></td></tr></table></figure><p>这种方式切换到特定的提交时，处于分离头指针（detached HEAD）状态。</p><h5 id="git-reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。"><a href="#git-reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。" class="headerlink" title="git reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。"></a>git reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。</h5><p>git reset 命令可以更改当前分支的提交历史，它有三种主要模式：–soft、–mixed 和 –hard。</p><p>–soft：只重置 HEAD 到指定的提交，暂存区和工作目录保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>–mixed（默认）：重置 HEAD 到指定的提交，暂存区重置，但工作目录保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>–hard：重置 HEAD 到指定的提交，暂存区和工作目录都重置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如，将当前分支重置到 abc123 提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard abc123</span><br></pre></td></tr></table></figure><h5 id="git-revert：创建一个新的提交以撤销指定提交，不改变提交历史，适用于已经推送到远程仓库的提交。"><a href="#git-revert：创建一个新的提交以撤销指定提交，不改变提交历史，适用于已经推送到远程仓库的提交。" class="headerlink" title="git revert：创建一个新的提交以撤销指定提交，不改变提交历史，适用于已经推送到远程仓库的提交。"></a>git revert：创建一个新的提交以撤销指定提交，不改变提交历史，适用于已经推送到远程仓库的提交。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如，撤销 abc123 提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert abc123</span><br></pre></td></tr></table></figure><h5 id="git-reflog：查看历史操作记录，找回丢失的提交。"><a href="#git-reflog：查看历史操作记录，找回丢失的提交。" class="headerlink" title="git reflog：查看历史操作记录，找回丢失的提交。"></a>git reflog：查看历史操作记录，找回丢失的提交。</h5><p>git reflog 命令记录了所有 HEAD 的移动。即使提交被删除或重置，也可以通过 reflog 找回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>利用 reflog 可以找到之前的提交哈希，从而恢复到特定状态。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;3&#125;</span><br></pre></td></tr></table></figure><p>实例<br>以下是一个综合示例，演示如何使用这些命令恢复历史版本：</p><p>查看提交历史：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>假设输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc1234 Commit 1</span><br><span class="line">def5678 Commit 2</span><br><span class="line">ghi9012 Commit 3</span><br></pre></td></tr></table></figure><p>切换到 Commit 2（处于分离头指针状态）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，保留更改到暂存区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，取消暂存区更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，丢弃所有更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard def5678</span><br></pre></td></tr></table></figure><p>撤销 Commit 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert def5678</span><br></pre></td></tr></table></figure><p>查看 reflog 找回丢失的提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>找到之前的提交哈希并恢复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;3&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git版本回退&quot;&gt;&lt;a href=&quot;#git版本回退&quot; class=&quot;headerlink&quot; title=&quot;git版本回退&quot;&gt;&lt;/a&gt;git版本回退&lt;/h3&gt;&lt;h5 id=&quot;git-checkout：切换分支或恢复文件到指定提交。&quot;&gt;&lt;a href=&quot;#git-c</summary>
      
    
    
    
    <category term="git" scheme="https://222cabbage.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://222cabbage.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>babel浅析</title>
    <link href="https://222cabbage.github.io/2024/10/22/babel1/"/>
    <id>https://222cabbage.github.io/2024/10/22/babel1/</id>
    <published>2024-10-22T14:45:21.000Z</published>
    <updated>2024-10-22T14:49:51.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Babel浅析"><a href="#Babel浅析" class="headerlink" title="Babel浅析"></a>Babel浅析</h3><p>1：Babel的编译原理是对字符串的操作，因为代码的本质就是字符串。<br>2：需要使用分词器tokenizer将代码语句分隔，再进行语法分析(parser)ast，语义分析，最后转化生成generator或者执行interpretor<br>3：程序都可以用json表示<br>4：AST将代码转换为json</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Babel浅析&quot;&gt;&lt;a href=&quot;#Babel浅析&quot; class=&quot;headerlink&quot; title=&quot;Babel浅析&quot;&gt;&lt;/a&gt;Babel浅析&lt;/h3&gt;&lt;p&gt;1：Babel的编译原理是对字符串的操作，因为代码的本质就是字符串。&lt;br&gt;2：需要使用分词器tok</summary>
      
    
    
    
    <category term="babel" scheme="https://222cabbage.github.io/categories/babel/"/>
    
    
    <category term="babel" scheme="https://222cabbage.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点盘点</title>
    <link href="https://222cabbage.github.io/2024/10/21/js1/"/>
    <id>https://222cabbage.github.io/2024/10/21/js1/</id>
    <published>2024-10-21T11:13:45.000Z</published>
    <updated>2024-10-23T17:31:55.749Z</updated>
    
    <content type="html"><![CDATA[<p>HTML&amp;CSS：<br>    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、<br>    HTML5、CSS3、Flexbox</p><p>JavaScript：<br>    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、<br>    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs</p><p>其他：<br>    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTML&amp;amp;CSS：&lt;br&gt;    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、&lt;br&gt;    HTML5、CSS3、Flexbox&lt;/p&gt;
&lt;p&gt;JavaScript：&lt;br&gt;    数据类型、运算、对象、Fun</summary>
      
    
    
    
    <category term="js知识" scheme="https://222cabbage.github.io/categories/js%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="js" scheme="https://222cabbage.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>利用canvas可以做什么</title>
    <link href="https://222cabbage.github.io/2024/10/21/html5/"/>
    <id>https://222cabbage.github.io/2024/10/21/html5/</id>
    <published>2024-10-21T08:05:16.000Z</published>
    <updated>2024-10-21T08:22:33.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电子签名版原理"><a href="#电子签名版原理" class="headerlink" title="电子签名版原理"></a>电子签名版原理</h3><p>利用canvas绘制一个画板，再结合mouse相关事件获取鼠标点击后移动过的坐标，赋值给canvas绘制api</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;电子签名版原理&quot;&gt;&lt;a href=&quot;#电子签名版原理&quot; class=&quot;headerlink&quot; title=&quot;电子签名版原理&quot;&gt;&lt;/a&gt;电子签名版原理&lt;/h3&gt;&lt;p&gt;利用canvas绘制一个画板，再结合mouse相关事件获取鼠标点击后移动过的坐标，赋值给canvas</summary>
      
    
    
    
    <category term="html5" scheme="https://222cabbage.github.io/categories/html5/"/>
    
    
    <category term="html5相关知识" scheme="https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Websocket</title>
    <link href="https://222cabbage.github.io/2024/10/21/html4/"/>
    <id>https://222cabbage.github.io/2024/10/21/html4/</id>
    <published>2024-10-20T17:13:32.000Z</published>
    <updated>2024-10-20T17:33:17.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML5-WebSocket-取自菜鸟教程"><a href="#HTML5-WebSocket-取自菜鸟教程" class="headerlink" title="HTML5 WebSocket 取自菜鸟教程"></a>HTML5 WebSocket 取自菜鸟教程</h2><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Socket = new WebSocket(url, [protocol] );</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h4 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h4><h5 id="Socket-readyState"><a href="#Socket-readyState" class="headerlink" title="Socket.readyState"></a>Socket.readyState</h5><p>只读属性 readyState 表示连接状态，可以是以下值：</p><p>0 - 表示连接尚未建立。</p><p>1 - 表示连接已建立，可以进行通信。</p><p>2 - 表示连接正在进行关闭。</p><p>3 - 表示连接已经关闭或者连接不能打开。</p><h5 id="Socket-bufferedAmount"><a href="#Socket-bufferedAmount" class="headerlink" title="Socket.bufferedAmount"></a>Socket.bufferedAmount</h5><p>只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</p><h4 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h4><p>事件事件处理程序描述<br>openSocket.onopen连接建立时触发<br>messageSocket.onmessage客户端接收服务端数据时触发<br>errorSocket.onerror通信发生错误时触发<br>closeSocket.onclose连接关闭时触发</p><h4 id="WebSocket-方法"><a href="#WebSocket-方法" class="headerlink" title="WebSocket 方法"></a>WebSocket 方法</h4><p>方法描述<br>Socket.send()使用连接发送数据<br>Socket.close()关闭连接</p><h4 id="WebSocket-实例"><a href="#WebSocket-实例" class="headerlink" title="WebSocket 实例"></a>WebSocket 实例</h4><p>WebSocket 协议本质上是一个基于 TCP 的协议。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">         function WebSocketTest()</span><br><span class="line">         &#123;</span><br><span class="line">            if (&quot;WebSocket&quot; in window)</span><br><span class="line">            &#123;</span><br><span class="line">               alert(&quot;您的浏览器支持 WebSocket!&quot;);</span><br><span class="line">               </span><br><span class="line">               // 打开一个 web socket</span><br><span class="line">               var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;);</span><br><span class="line">                </span><br><span class="line">               ws.onopen = function()</span><br><span class="line">               &#123;</span><br><span class="line">                  // Web Socket 已连接上，使用 send() 方法发送数据</span><br><span class="line">                  ws.send(&quot;发送数据&quot;);</span><br><span class="line">                  alert(&quot;数据发送中...&quot;);</span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line">               ws.onmessage = function (evt) </span><br><span class="line">               &#123; </span><br><span class="line">                  var received_msg = evt.data;</span><br><span class="line">                  alert(&quot;数据已接收...&quot;);</span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line">               ws.onclose = function()</span><br><span class="line">               &#123; </span><br><span class="line">                  // 关闭 websocket</span><br><span class="line">                  alert(&quot;连接已关闭...&quot;); </span><br><span class="line">               &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               // 浏览器不支持 WebSocket</span><br><span class="line">               alert(&quot;您的浏览器不支持 WebSocket!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">        </span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;div id=&quot;sse&quot;&gt;</span><br><span class="line">         &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      </span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML5-WebSocket-取自菜鸟教程&quot;&gt;&lt;a href=&quot;#HTML5-WebSocket-取自菜鸟教程&quot; class=&quot;headerlink&quot; title=&quot;HTML5 WebSocket 取自菜鸟教程&quot;&gt;&lt;/a&gt;HTML5 WebSocket 取自菜鸟</summary>
      
    
    
    
    <category term="html5" scheme="https://222cabbage.github.io/categories/html5/"/>
    
    
    <category term="html5相关知识" scheme="https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>html5拖放api</title>
    <link href="https://222cabbage.github.io/2024/10/21/html3/"/>
    <id>https://222cabbage.github.io/2024/10/21/html3/</id>
    <published>2024-10-20T16:24:59.000Z</published>
    <updated>2024-10-20T16:41:28.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML5拖拽api（Drag与Drop）取自于菜鸟教程"><a href="#HTML5拖拽api（Drag与Drop）取自于菜鸟教程" class="headerlink" title="HTML5拖拽api（Drag与Drop）取自于菜鸟教程"></a>HTML5拖拽api（Drag与Drop）取自于菜鸟教程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;拖放api&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function allowDrop(ev)</span><br><span class="line">&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function drag(ev)</span><br><span class="line">&#123;</span><br><span class="line">    ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function drop(ev)</span><br><span class="line">&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    var data=ev.dataTransfer.getData(&quot;Text&quot;);</span><br><span class="line">    ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="设置元素为可拖放"><a href="#设置元素为可拖放" class="headerlink" title="设置元素为可拖放"></a>设置元素为可拖放</h4><p>首先，为了使元素可拖动，把 draggable 属性设置为 true ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img draggable=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="拖动什么-ondragstart-和-setData"><a href="#拖动什么-ondragstart-和-setData" class="headerlink" title="拖动什么 - ondragstart 和 setData()"></a>拖动什么 - ondragstart 和 setData()</h4><p>然后，规定当元素被拖动时，会发生什么。</p><p>在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。</p><p>dataTransfer.setData() 方法设置被拖数据的数据类型和值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function drag(ev)</span><br><span class="line">&#123;</span><br><span class="line">    ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Text 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id (“drag1”)。</p><h4 id="放放到何处-ondragover"><a href="#放放到何处-ondragover" class="headerlink" title="放放到何处 - ondragover"></a>放放到何处 - ondragover</h4><p>ondragover 事件规定在何处放置被拖动的数据。</p><p>默认地，无法将数据&#x2F;元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p><p>这要通过调用 ondragover 事件的 event.preventDefault() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()</span><br></pre></td></tr></table></figure><h4 id="进行放置-ondrop"><a href="#进行放置-ondrop" class="headerlink" title="进行放置 - ondrop"></a>进行放置 - ondrop</h4><p>当放置被拖数据时，会发生 drop 事件。</p><p>在上面的例子中，ondrop 属性调用了一个函数，drop(event)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function drop(ev)</span><br><span class="line">&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    var data=ev.dataTransfer.getData(&quot;Text&quot;);</span><br><span class="line">    ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><p>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）<br>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。<br>被拖数据是被拖元素的 id (“drag1”)<br>把被拖元素追加到放置元素（目标元素）中</p><h4 id="来回拖放图片"><a href="#来回拖放图片" class="headerlink" title="来回拖放图片"></a>来回拖放图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#div1, #div2 &#123;</span><br><span class="line">float:left; </span><br><span class="line">width:100px; </span><br><span class="line">height:35px; </span><br><span class="line">margin:10px;</span><br><span class="line">padding:10px;</span><br><span class="line">border:1px solid #aaaaaa;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function allowDrop(ev) &#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function drag(ev) &#123;</span><br><span class="line">ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function drop(ev) &#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">var data=ev.dataTransfer.getData(&quot;Text&quot;);</span><br><span class="line">ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;</span><br><span class="line">&lt;img src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; width=&quot;88&quot; height=&quot;31&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML5拖拽api（Drag与Drop）取自于菜鸟教程&quot;&gt;&lt;a href=&quot;#HTML5拖拽api（Drag与Drop）取自于菜鸟教程&quot; class=&quot;headerlink&quot; title=&quot;HTML5拖拽api（Drag与Drop）取自于菜鸟教程&quot;&gt;&lt;/a&gt;HT</summary>
      
    
    
    
    <category term="html5" scheme="https://222cabbage.github.io/categories/html5/"/>
    
    
    <category term="html5相关知识" scheme="https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>canvas与svg</title>
    <link href="https://222cabbage.github.io/2024/10/21/html2/"/>
    <id>https://222cabbage.github.io/2024/10/21/html2/</id>
    <published>2024-10-20T16:24:46.000Z</published>
    <updated>2024-10-20T16:32:09.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><p>HTML5 canvas标签 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.</p><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><h5 id="svg概念："><a href="#svg概念：" class="headerlink" title="svg概念："></a>svg概念：</h5><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)<br>SVG 用于定义用于网络的基于矢量的图形<br>SVG 使用 XML 格式定义图形<br>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失<br>SVG 是万维网联盟的标准</p><h5 id="svg优势"><a href="#svg优势" class="headerlink" title="svg优势"></a>svg优势</h5><p>SVG 图像可通过文本编辑器来创建和修改<br>SVG 图像可被搜索、索引、脚本化或压缩<br>SVG 是可伸缩的<br>SVG 图像可在任何的分辨率下被高质量地打印<br>SVG 可在图像质量不下降的情况下被放大</p><h2 id="SVG-与-Canvas两者间的区别"><a href="#SVG-与-Canvas两者间的区别" class="headerlink" title="SVG 与 Canvas两者间的区别"></a>SVG 与 Canvas两者间的区别</h2><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><h2 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h2><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p>依赖分辨率<br>不支持事件处理器<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</p><h4 id="svg-1"><a href="#svg-1" class="headerlink" title="svg"></a>svg</h4><p>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>不适合游戏应用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;canvas&quot;&gt;&lt;a href=&quot;#canvas&quot; class=&quot;headerlink&quot; title=&quot;canvas&quot;&gt;&lt;/a&gt;canvas&lt;/h2&gt;&lt;p&gt;HTML5 canvas标签 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="html5" scheme="https://222cabbage.github.io/categories/html5/"/>
    
    
    <category term="html5相关知识" scheme="https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IE浏览器兼容html5</title>
    <link href="https://222cabbage.github.io/2024/10/20/html1/"/>
    <id>https://222cabbage.github.io/2024/10/20/html1/</id>
    <published>2024-10-20T15:07:56.000Z</published>
    <updated>2024-10-20T16:24:00.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IE浏览器兼容html5"><a href="#IE浏览器兼容html5" class="headerlink" title="IE浏览器兼容html5"></a>IE浏览器兼容html5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">完美的 Shiv 解决方案</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;渲染 HTML5&lt;/title&gt;</span><br><span class="line">  &lt;!--[if lt IE 9]&gt;</span><br><span class="line">  &lt;script src=&quot;https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;![endif]--&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">html5shiv.js 引用代码必须放在 &lt;head&gt; 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;IE浏览器兼容html5&quot;&gt;&lt;a href=&quot;#IE浏览器兼容html5&quot; class=&quot;headerlink&quot; title=&quot;IE浏览器兼容html5&quot;&gt;&lt;/a&gt;IE浏览器兼容html5&lt;/h3&gt;&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    <category term="html5" scheme="https://222cabbage.github.io/categories/html5/"/>
    
    
    <category term="html5相关知识" scheme="https://222cabbage.github.io/tags/html5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>看一下mongodb</title>
    <link href="https://222cabbage.github.io/2022/12/11/mongostudy/"/>
    <id>https://222cabbage.github.io/2022/12/11/mongostudy/</id>
    <published>2022-12-11T10:01:56.000Z</published>
    <updated>2022-12-11T15:29:43.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近想做个日程表"><a href="#最近想做个日程表" class="headerlink" title="最近想做个日程表"></a>最近想做个日程表</h2><p>下载mongodb</p><p>cmd打开窗口</p><p>show dbs 展示已有数据库</p><p>use block 创建一个名为block的数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最近想做个日程表&quot;&gt;&lt;a href=&quot;#最近想做个日程表&quot; class=&quot;headerlink&quot; title=&quot;最近想做个日程表&quot;&gt;&lt;/a&gt;最近想做个日程表&lt;/h2&gt;&lt;p&gt;下载mongodb&lt;/p&gt;
&lt;p&gt;cmd打开窗口&lt;/p&gt;
&lt;p&gt;show dbs 展示已有数</summary>
      
    
    
    
    <category term="mongo" scheme="https://222cabbage.github.io/categories/mongo/"/>
    
    
    <category term="mongo" scheme="https://222cabbage.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>vuejs设计与实现的阅读</title>
    <link href="https://222cabbage.github.io/2022/12/07/realizationvue/"/>
    <id>https://222cabbage.github.io/2022/12/07/realizationvue/</id>
    <published>2022-12-07T13:00:21.000Z</published>
    <updated>2022-12-07T16:23:57.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>@click&#x3D;”toXXXX”</p><p>注重过程，内部实现了该事件</p><h3 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h3><p>xxx.textContent &#x3D; ‘xxx’</p><p>注重过程</p><p>声明式和命令式的对比，命令式性能更好，声明式是在方便开发，利于维护的情况下尽量去减少性能的损耗</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>紧跟着的是虚拟DOM</p><p>循环向数组push对象和循环向一个节点appendChild对比起来，明显前者效率更高，性能更好</p><p>如何让声明式的性能更加接近命令式呢，就需要最小化的寻找到二者之间对比的差异</p><p>提供一个render函数，将一个树形结构对象递归转换成真实DOM</p><p>缺少了一部分，我们只是将属性结构对象递归转换成真实DOM，缺少将真实DOM转换成树形结构的方法</p><p>因此complier函数设计出来</p><p>let dom &#x3D; <div>节点</div></p><p>let obj &#x3D; compiler(dom) &#x2F;&#x2F;转换成树形结构对象</p><p>render(obj，document.body)&#x2F;&#x2F;将转换后的树形结构渲染成真实DOM插入body中</p><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>去除打包后项目中的无用代码，必须依赖于es module</p><p>什么是副作用函数？就是内部操作会影响外部变量的函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;声明式&quot;&gt;&lt;a href=&quot;#声明式&quot; class=&quot;headerlink&quot; title=&quot;声明式&quot;&gt;&lt;/a&gt;声明式&lt;/h3&gt;&lt;p&gt;@click&amp;#x3D;”toXXXX”&lt;/p&gt;
&lt;p&gt;注重过程，内部实现了该事件&lt;/p&gt;
&lt;h3 id=&quot;命令式&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="vue实现" scheme="https://222cabbage.github.io/categories/vue%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="vue实现" scheme="https://222cabbage.github.io/tags/vue%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>与react-native在职场上的碰撞</title>
    <link href="https://222cabbage.github.io/2022/12/01/reactnative/"/>
    <id>https://222cabbage.github.io/2022/12/01/reactnative/</id>
    <published>2022-12-01T14:53:48.000Z</published>
    <updated>2022-12-03T14:44:09.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="与react-native在职场上的碰撞"><a href="#与react-native在职场上的碰撞" class="headerlink" title="与react-native在职场上的碰撞"></a>与react-native在职场上的碰撞</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;与react-native在职场上的碰撞&quot;&gt;&lt;a href=&quot;#与react-native在职场上的碰撞&quot; class=&quot;headerlink&quot; title=&quot;与react-native在职场上的碰撞&quot;&gt;&lt;/a&gt;与react-native在职场上的碰撞&lt;/h2&gt;</summary>
      
    
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/categories/react-native/"/>
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>react-native上手</title>
    <link href="https://222cabbage.github.io/2022/10/19/rn1/"/>
    <id>https://222cabbage.github.io/2022/10/19/rn1/</id>
    <published>2022-10-19T15:15:21.000Z</published>
    <updated>2022-10-19T16:39:40.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-native，一个按照官网来搭建环境都能搭建错的app开发方案"><a href="#react-native，一个按照官网来搭建环境都能搭建错的app开发方案" class="headerlink" title="react-native，一个按照官网来搭建环境都能搭建错的app开发方案"></a>react-native，一个按照官网来搭建环境都能搭建错的app开发方案</h2><p>环境什么的就不说了，百度一下大概就知道</p><p>安装node，react-native-cli，android-studio，jdk8版</p><p>react-native init mypro –version 0.68.2 不带后面的版本会报错</p><p>yarn android运行</p><p>然后有报奇奇怪怪的错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-native，一个按照官网来搭建环境都能搭建错的app开发方案&quot;&gt;&lt;a href=&quot;#react-native，一个按照官网来搭建环境都能搭建错的app开发方案&quot; class=&quot;headerlink&quot; title=&quot;react-native，一个按照官</summary>
      
    
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/categories/react-native/"/>
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>讲讲入职第一天的工作</title>
    <link href="https://222cabbage.github.io/2022/10/17/work1/"/>
    <id>https://222cabbage.github.io/2022/10/17/work1/</id>
    <published>2022-10-17T14:15:26.000Z</published>
    <updated>2022-10-17T14:21:51.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分享一下入职第一天的生活"><a href="#分享一下入职第一天的生活" class="headerlink" title="分享一下入职第一天的生活"></a>分享一下入职第一天的生活</h2><p>第一天入职嘛，难免紧张</p><p>这是我实习结束后的第一份正式工作，我想在任何方面都做好</p><p>在办理玩入职后，有小姐姐带我领取了一台电脑，并带领我去了工位</p><p>我的工位旁就是带我的老大，还是蛮刺激的</p><p>老大后续带我去会议室和我讲解了一下团队的项目</p><p>光看成品还没什么，看代码才是真头痛</p><p>看代码的同时顺路搭建react native环境，这安卓环境是真难安装，按照react native官网上的步骤一步一步来都不知道哪里搞错了</p><p>再结合代码的难度，目录我都看不懂，因此让我萌生出了放弃的想法</p><p>但是再困难也得坚持下去，坚持才会有胜利的希望，我坚信我会变得越来越好</p><p>也很感谢那些激励我的小伙伴们，没有大家的鼓励我也很难重拾信心，啾咪……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分享一下入职第一天的生活&quot;&gt;&lt;a href=&quot;#分享一下入职第一天的生活&quot; class=&quot;headerlink&quot; title=&quot;分享一下入职第一天的生活&quot;&gt;&lt;/a&gt;分享一下入职第一天的生活&lt;/h2&gt;&lt;p&gt;第一天入职嘛，难免紧张&lt;/p&gt;
&lt;p&gt;这是我实习结束后的第一</summary>
      
    
    
    
    <category term="工作日志" scheme="https://222cabbage.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="工作日志" scheme="https://222cabbage.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://222cabbage.github.io/2022/10/09/mobile1/"/>
    <id>https://222cabbage.github.io/2022/10/09/mobile1/</id>
    <published>2022-10-09T06:10:24.000Z</published>
    <updated>2022-10-09T10:56:19.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端适配的方案"><a href="#移动端适配的方案" class="headerlink" title="移动端适配的方案"></a>移动端适配的方案</h2><h4 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h4><p>响应式布局，通过@media媒体查询实现一套html配合多套css实现适配</p><p>通过rem或者vh，vw实现不同设备有相同比例进而进行适配</p><p>或者媒体查询配合rem适配</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>viewport视口标签，想要统一标准视口</p><p>需要在head中添加</p><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><h4 id="rem实现原理"><a href="#rem实现原理" class="headerlink" title="rem实现原理"></a>rem实现原理</h4><p>rem是font-size的倍数大小，只需要在不同设备相同比例下设置不同的font-size大小就可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;title&gt;rem适配&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .box &#123;</span><br><span class="line">            /* 随意写大小，px to rem工具自动适配 */</span><br><span class="line">            width: 5rem;</span><br><span class="line">            height: 5rem;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 动态设置font-size</span><br><span class="line">        function resetHtmlFontSize()&#123;</span><br><span class="line">            document.documentElement.style.fontSize = screen.width / 10 + &#x27;px&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        // window.onresize = resetHtmlFontSize</span><br><span class="line">        window.addEventListener(&#x27;resize&#x27;,resetHtmlFontSize)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>弊端是如果设计稿修改，那么整体都要修改</p><h4 id="px-to-rem插件"><a href="#px-to-rem插件" class="headerlink" title="px to  rem插件"></a>px to  rem插件</h4><p>在vscode插件中搜索</p><p>安装后自动匹配px进行转换rem</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要一个配置文件，在目录下创建.cssrem</span><br><span class="line">复制</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/09/xJLb1P.png"></p><p>存在的弊端</p><p>转换错误后无法观看转换前的大小，所以一般是保留px，后期通过第三方工具，比如gulp动态监听转换</p><h4 id="媒体监听"><a href="#媒体监听" class="headerlink" title="媒体监听"></a>媒体监听</h4><p>媒体监听不是缩放，是同一个内容在不同设备上有合理的表现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media screen and （maxwidth：1000px）&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><h5 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h5><p>原理相对不好理解</p><p>从px到rem想要灵活的转换需要借助工具</p><p>灵活可控，完美复制设计稿</p><p>比较适合具有完全移动端的项目</p><h5 id="媒体查询："><a href="#媒体查询：" class="headerlink" title="媒体查询："></a>媒体查询：</h5><p>没有学习成本</p><p>如何适配需要重新定义，设计稿麻烦</p><p>复杂的组件很难完美呈现</p><p>适合只有pc端设计稿，但是需要兼容移动端的项目</p><h5 id="综合方案："><a href="#综合方案：" class="headerlink" title="综合方案："></a>综合方案：</h5><p>同时使用media和rem</p><p>实现比较复杂</p><p>自由度更好</p><p>颗粒度不好把握</p><p>微信小程序的css单位px换算单位1px&#x3D;2rpx，应该和rem适配原理大概相同</p><h4 id="如果是vue，可以使用postcss-px-to-viewport"><a href="#如果是vue，可以使用postcss-px-to-viewport" class="headerlink" title="如果是vue，可以使用postcss-px-to-viewport"></a>如果是vue，可以使用postcss-px-to-viewport</h4><p>我也看到别人说的其实没有最好的适配，或者移动端准备一套，pc准备一套</p><p>或者tailwindcss</p><p>每个人对技术的感悟都是不同的，都有各自的看法，最后采用什么样的技术方案也还是得根据实际项目来，没有什么最好的方案一说</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移动端适配的方案&quot;&gt;&lt;a href=&quot;#移动端适配的方案&quot; class=&quot;headerlink&quot; title=&quot;移动端适配的方案&quot;&gt;&lt;/a&gt;移动端适配的方案&lt;/h2&gt;&lt;h4 id=&quot;常见方案&quot;&gt;&lt;a href=&quot;#常见方案&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="移动端适配" scheme="https://222cabbage.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
    
    <category term="移动端适配" scheme="https://222cabbage.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>canvas2D绘图</title>
    <link href="https://222cabbage.github.io/2022/10/07/canvas1/"/>
    <id>https://222cabbage.github.io/2022/10/07/canvas1/</id>
    <published>2022-10-07T06:40:05.000Z</published>
    <updated>2022-10-08T06:11:53.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="canvas2D绘图"><a href="#canvas2D绘图" class="headerlink" title="canvas2D绘图"></a>canvas2D绘图</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- Canvas标签的默认大小为：300 x 150 (像素)，而这里咱们设置为了：200 x 200（像素）。</span><br><span class="line">    Canvas标签中的文字是在不支持Canvas标签的浏览器中使用的，因为支持Canvas标签的浏览器会忽略容器中包含的内  容正常渲染Canvas标签，而不支持Canvas标签的浏览器则相反，浏览器会忽略容器而显示其中的内容 --&gt;</span><br><span class="line">    &lt;canvas width=&quot;200&quot; height=&quot;200&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3qxtx.png"></p><h4 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h4><p>canvas标签提供了一个容器画布，如果想要进行绘制就得找到渲染上下文</p><p>getContext()</p><p>getContext方法是有一个接收参数，它是绘图上下文的类型</p><p>2d：建立一个二维渲染上下文。这种情况可以用 CanvasRenderingContext2D()来替换getContext(‘2d’)。</p><p>webgl（或 experimental-webgl）： 创建一个 WebGLRenderingContext 三维渲染上下文对象。只在实现WebGL 版本1(OpenGL ES 2.0)的浏览器上可用。</p><p>webgl2（或 experimental-webgl2）：创建一个 WebGL2RenderingContext 三维渲染上下文对象。只在实现 WebGL 版本2 (OpenGL ES 3.0)的浏览器上可用。</p><p>bitmaprenderer：创建一个只提供将canvas内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot;&gt;</span><br><span class="line">        当前浏览器不支持canvas元素，请升级或者更换浏览器</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let canvas = document.getElementById(&#x27;canvas&#x27;)</span><br><span class="line">        console.log(canvas.getContext)</span><br><span class="line">        if(canvas.getContext)&#123;</span><br><span class="line">            let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在获取上下文之后就可以绘制基本形状</p><h4 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h4><h5 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">moveTo(x, y)</span><br><span class="line">设置初始位置，参数为初始位置x和y的坐标点</span><br><span class="line"></span><br><span class="line">lineTo(x, y)</span><br><span class="line">绘制一条从初始位置到指定位置的直线，参数为指定位置x和y的坐标点</span><br><span class="line"></span><br><span class="line">stroke()</span><br><span class="line">通过线条来绘制图形轮廓</span><br><span class="line"></span><br><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">    ctx.moveTo(50,50)</span><br><span class="line">    ctx.lineTo(300,300)</span><br><span class="line">    ctx.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">    ctx.moveTo(50,50) //起点坐标</span><br><span class="line">    ctx.lineTo(300,300)</span><br><span class="line">    ctx.lineTo(50,300)</span><br><span class="line">    ctx.lineTo(50,50) //终点坐标。闭合点</span><br><span class="line">    ctx.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3xpOU.png"></p><h5 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h5><p>矩形的绘制并不是单纯的直线拼凑，canvas提供了相关api绘制矩形</p><p>strokeRect(x, y, width, height) 绘制一个矩形的边框</p><p>fillRect(x, y, width, height) 绘制一个填充的矩形</p><p>clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 矩形</span><br><span class="line">ctx.strokeRect(50,50,200,100)</span><br><span class="line">ctx.fillRect(50,160,200,100)</span><br><span class="line">ctx.clearRect(60,180,50,50</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3zZNj.png"></p><h5 id="圆弧和圆"><a href="#圆弧和圆" class="headerlink" title="圆弧和圆"></a>圆弧和圆</h5><p>arc(x, y, radius, startAngle, endAngle, anticlockwise)。x和Y为圆心的坐标，radius为半径，startAngle为圆弧或圆的开始位置，endAngle为圆弧或圆的结束位置，anticlockwise是绘制的方向（不写默认为false，从顺时针方向)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 原型和弧</span><br><span class="line">ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">ctx.stroke()</span><br><span class="line"></span><br><span class="line">需要注意的是：在画弧的时候，arc()函数中角的单位是弧度而不是角度。角度换算为弧度的表达式为：弧度=(Math.PI/180)*角度。</span><br><span class="line"></span><br><span class="line">// 原型和弧</span><br><span class="line">// ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">// ctx.stroke()</span><br><span class="line"></span><br><span class="line">//  // 绘制一个圆弧</span><br><span class="line">// ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">// ctx.stroke();</span><br><span class="line"></span><br><span class="line">// 如果按照上述写法绘制一根弧线和圆 会出现路径相连，因此需要开启和闭合路径</span><br><span class="line">// beginPath</span><br><span class="line">// 新建一条路径，生成之后，图形绘制命令被指向到路径上。</span><br><span class="line"></span><br><span class="line">// closePath</span><br><span class="line">// 闭合路径之后图形绘制命令又重新指向到上下文中。 具体怎么使用这两个函数呢？下面咱们介绍一下，直接上代码：</span><br><span class="line">// 原型和弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">ctx.fill(); //填充黑色</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line">// 绘制一个圆弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8S8QP.png"></p><p><img src="https://s1.ax1x.com/2022/10/07/x8SGsf.png"></p><p>在咱们开启和关闭路径的时候，关闭路径其实并不是必须的，对于新路径其实每次都开启新路径就ok。</p><p>填充fill</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 绘制一个圆弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h5 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h5><p>ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)</p><ul><li>x、y：椭圆的圆心位置</li><li>radiusX、radiusY：x轴和y轴的半径</li><li>rotation：椭圆的旋转角度，以弧度表示</li><li>startAngle：开始绘制点</li><li>endAngle：结束绘制点</li><li>anticlockwise：绘制的方向（默认顺时针），可选参数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合了一下，有点搞笑</span><br><span class="line">// 椭圆</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(100, 150, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(400, 150, 50, 100, 0, 0, 2 * Math.PI);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(400, 150, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(250, 350, 20, 200, Math.PI/2, 0, 2 * Math.PI); // 旋转90°</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8CXY4.png"></p><h5 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 贝塞尔曲线</span><br><span class="line"> // 贝塞尔曲线一般用来绘制复杂有规律的图形，在Canvas中也是一个十分有用的路径类型。</span><br><span class="line"> // 二次贝塞尔曲线</span><br><span class="line"> // 语法：quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点</span><br><span class="line"> // 绘制一段二次贝塞尔曲线</span><br><span class="line"> ctx.moveTo(50, 50);</span><br><span class="line"> ctx.quadraticCurveTo(200, 200, 350, 50);</span><br><span class="line"> // 绘制</span><br><span class="line"> ctx.stroke();</span><br><span class="line"></span><br><span class="line">// 三次贝塞尔曲线</span><br><span class="line">// 和二次贝塞尔曲线不同的是三次贝塞尔曲线有两个控制点。</span><br><span class="line">// 语法：ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。</span><br><span class="line">ctx.beginPath() // 开启路径</span><br><span class="line">ctx.moveTo(50, 200);</span><br><span class="line">ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);</span><br><span class="line">// 绘制</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8P8hQ.png"></p><p><img src="https://s1.ax1x.com/2022/10/07/x8PJpj.png"></p><h4 id="绘制样式"><a href="#绘制样式" class="headerlink" title="绘制样式"></a>绘制样式</h4><h5 id="线条样式"><a href="#线条样式" class="headerlink" title="线条样式"></a>线条样式</h5><p>lineWidth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">let canvas = document.getElementById(&#x27;canvas&#x27;)</span><br><span class="line">        console.log(canvas.getContext)</span><br><span class="line">        if(canvas.getContext)&#123;</span><br><span class="line">            let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">            // 线条样式</span><br><span class="line">             // lineWidth 设置当前绘线的粗细。属性值必须为正数。默认值是 1.0。</span><br><span class="line">            //  lineCap</span><br><span class="line">            // lineCap 设置线段端点显示的样子。可选值为：butt，round 和 square。默认是 butt。</span><br><span class="line">            // lineJoin</span><br><span class="line">            // lineJoin 该属性可以设置两线段连接处所显示的样子。可选值为：round, bevel 和 miter。默认是</span><br><span class="line">            // ctx.lineWidth = 10;</span><br><span class="line">            // ctx.lineCap=&#x27;round&#x27;</span><br><span class="line">            // ctx.moveTo(50,50)</span><br><span class="line">            // ctx.lineTo(300,300)</span><br><span class="line">            // ctx.stroke()</span><br><span class="line">            </span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.lineWidth = 10;</span><br><span class="line">            // ctx.lineJoin=&#x27;miter&#x27;</span><br><span class="line">            // ctx.moveTo(50, 20);</span><br><span class="line">            // ctx.lineTo(100, 60);</span><br><span class="line">            // ctx.lineTo(150, 20);</span><br><span class="line">            // ctx.lineTo(200, 60);</span><br><span class="line">            // ctx.lineTo(250, 20);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // ctx.closePath();</span><br><span class="line"></span><br><span class="line">            // miterLimit</span><br><span class="line">            // miterLimit 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</span><br><span class="line">            // 线段之间夹角比较大时，交点不会太远，但随着夹角变小，交点距离会呈指数级增大。</span><br><span class="line">            // 如果交点距离大于miterLimit值，连接效果会变成了 lineJoin = bevel 的效果。</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.lineWidth = 5;</span><br><span class="line">            // ctx.lineJoin=&#x27;miter&#x27;</span><br><span class="line">            // ctx.miterLimit = 10</span><br><span class="line">            // ctx.moveTo(0, 100);</span><br><span class="line">            // for (i = 0; i &lt; 30 ; i++) &#123;</span><br><span class="line">            //     var dy = i % 2 == 0 ? 200 : 100;</span><br><span class="line">            //     ctx.lineTo(Math.pow(i, 1.5) * 2, dy);</span><br><span class="line">            // &#125;</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // ctx.closePath();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // setLineDash/getLineDash</span><br><span class="line">            // setLineDash 可以设置当前虚线样式。</span><br><span class="line">            // getLineDash 则是返回当前虚线设置的样式，长度为非负偶数的数组。</span><br><span class="line">            // ctx.setLineDash([5, 10, 20]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,100);</span><br><span class="line">            // ctx.lineTo(400, 100);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // // 再绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20, 40]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 40]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,200);</span><br><span class="line">            // ctx.lineTo(400, 200);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line"></span><br><span class="line">            // lineDashOffset</span><br><span class="line">            // lineDashOffset 设置虚线样式的起始偏移量</span><br><span class="line">            // 绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,100);</span><br><span class="line">            // ctx.lineTo(400, 100);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // // 再绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20, 40]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 40]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,200);</span><br><span class="line">            // ctx.lineTo(400, 200);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            </span><br><span class="line">            // 设置 globalAlpha 属性或者使用有透明度的样式作为轮廓或填充都可以实现</span><br><span class="line">            // 绘制一个矩形</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // // 指定透明度的填充样式</span><br><span class="line">            // ctx.fillStyle = &quot;rgba(0, 255, 0, 0.2)&quot;;</span><br><span class="line">            // ctx.fillRect(10,10,300,100);</span><br><span class="line">            // // 绘制一个矩形边框</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // // 指定透明度的描边样式</span><br><span class="line">            // ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.7)&quot;;</span><br><span class="line">            // ctx.strokeRect(10, 90, 100, 300);</span><br><span class="line">            // // 绘制一个圆</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.fillStyle = &quot;rgba(255, 255, 0, 1)&quot;;</span><br><span class="line">            // // 设置透明度值</span><br><span class="line">            // ctx.globalAlpha = 0.5;</span><br><span class="line">            // ctx.arc(200, 200, 100, 0, Math.PI*2, true);</span><br><span class="line">            // ctx.fill();</span><br><span class="line"></span><br><span class="line">            // 渐变</span><br><span class="line">            // 线性渐变和径向渐变</span><br><span class="line">            // 线性渐变</span><br><span class="line">            // 语法： createLinearGradient(x1, y1, x2, y2)，参数分别为 起点的坐标和终点的坐标。</span><br><span class="line">            // 在渐变的设置中还需要一个方法来添加渐变的颜色，语法为：gradient.addColorStop(offset, color)，</span><br><span class="line">            // 其中color就是颜色，offset 则是颜色的偏移值，只为0到1之间的数。</span><br><span class="line">            // 创建渐变</span><br><span class="line">            // var gradient1 = ctx.createLinearGradient(10, 10, 400, 10);</span><br><span class="line">            // gradient1.addColorStop(0, &quot;#00ff00&quot;);</span><br><span class="line">            // gradient1.addColorStop(1, &quot;#ff0000&quot;);</span><br><span class="line">            // var gradient2 = ctx.createLinearGradient(10, 10, 400, 10);</span><br><span class="line">            // // 从0.5的位置才开始渐变</span><br><span class="line">            // gradient2.addColorStop(0.5, &quot;#00ff00&quot;);</span><br><span class="line">            // gradient2.addColorStop(1, &quot;#ff0000&quot;);</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.fillStyle = gradient1;</span><br><span class="line">            // ctx.fillRect(10, 10, 400, 100);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient2;</span><br><span class="line">            // ctx.fillRect(10, 150, 400, 100);</span><br><span class="line"></span><br><span class="line">            //   径向渐变</span><br><span class="line">            // ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)，参数分别为开始圆的坐标和半径以及结束圆的坐标和半径。</span><br><span class="line">            // 结束坐标为点</span><br><span class="line">            // var gradient1 = ctx.createRadialGradient(100, 100, 100, 100, 100, 0);</span><br><span class="line">            // gradient1.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient1.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 结束坐标为半径30的圆</span><br><span class="line">            // var gradient2 = ctx.createRadialGradient(320, 100, 100, 320, 100, 30); </span><br><span class="line">            // gradient2.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient2.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 从0.5的位置才开始渲染</span><br><span class="line">            // var gradient3 = ctx.createRadialGradient(100, 320, 100, 100, 320, 0); </span><br><span class="line">            // gradient3.addColorStop(0.5, &quot;#ff770f&quot;); </span><br><span class="line">            // gradient3.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 开始坐标和结束坐标不一样</span><br><span class="line">            // var gradient4 = ctx.createRadialGradient(320, 320, 100, 250, 250, 0);</span><br><span class="line">            // gradient4.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient4.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient1;</span><br><span class="line">            // ctx.fillRect(10, 10, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient2;</span><br><span class="line">            // ctx.fillRect(220, 10, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient3;</span><br><span class="line">            // ctx.fillRect(10, 220, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient4;</span><br><span class="line">            // ctx.fillRect(220, 220, 200, 200);</span><br><span class="line"></span><br><span class="line">            // Canvas中想绘制图案效果，需要用 createPattern 方法来实现。</span><br><span class="line">            // 语法：createPattern(image, type)，参数分别为：Image 参数可以是一个 Image 对象，也可以是一个 canvas 对象，Type 为图案绘制的类型，可用的类型分别有：repeat，repeat-x，repeat-y 和 no-repeat。</span><br><span class="line">            // 创建一个 image对象</span><br><span class="line">            // var img = new Image();</span><br><span class="line">            // img.src = &quot;./image.png&quot;;</span><br><span class="line">            // img.onload = function() &#123;</span><br><span class="line">            //     // 图片加载完以后</span><br><span class="line">            //     // 创建图案</span><br><span class="line">            //     var ptrn = ctx.createPattern(img, &#x27;no-repeat&#x27;);</span><br><span class="line">            //     ctx.fillStyle = ptrn;</span><br><span class="line">            //     ctx.fillRect(0, 0, 500, 500);</span><br><span class="line">            // &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>loading……</p><h5 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h5><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><h5 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h5><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><h5 id="strokeText描边"><a href="#strokeText描边" class="headerlink" title="strokeText描边"></a>strokeText描边</h5><h5 id="fillText填充"><a href="#fillText填充" class="headerlink" title="fillText填充"></a>fillText填充</h5><h5 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h5><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><h5 id="drawImage"><a href="#drawImage" class="headerlink" title="drawImage"></a>drawImage</h5><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><h5 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h5><h5 id="移动、旋转和缩放"><a href="#移动、旋转和缩放" class="headerlink" title="移动、旋转和缩放"></a>移动、旋转和缩放</h5><h5 id="transform，setTransform，resetTransform"><a href="#transform，setTransform，resetTransform" class="headerlink" title="transform，setTransform，resetTransform"></a>transform，setTransform，resetTransform</h5><h4 id="合成与裁剪"><a href="#合成与裁剪" class="headerlink" title="合成与裁剪"></a>合成与裁剪</h4><h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><h5 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h5><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><h4 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h4><h5 id="绘制小球"><a href="#绘制小球" class="headerlink" title="绘制小球"></a>绘制小球</h5><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><h5 id="加速度"><a href="#加速度" class="headerlink" title="加速度"></a>加速度</h5><h5 id="拖尾效果"><a href="#拖尾效果" class="headerlink" title="拖尾效果"></a>拖尾效果</h5><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h5><h5 id="反相颜色"><a href="#反相颜色" class="headerlink" title="反相颜色"></a>反相颜色</h5><h5 id="像素数据"><a href="#像素数据" class="headerlink" title="像素数据"></a>像素数据</h5><p>跟着掘金上的一篇文章学习的</p><p>作者：ndz链接：<a href="https://juejin.cn/post/7119495608938790942%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.cn/post/7119495608938790942来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;canvas2D绘图&quot;&gt;&lt;a href=&quot;#canvas2D绘图&quot; class=&quot;headerlink&quot; title=&quot;canvas2D绘图&quot;&gt;&lt;/a&gt;canvas2D绘图&lt;/h2&gt;&lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;head</summary>
      
    
    
    
    <category term="canvas" scheme="https://222cabbage.github.io/categories/canvas/"/>
    
    
    <category term="canvas" scheme="https://222cabbage.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>学一下Go</title>
    <link href="https://222cabbage.github.io/2022/09/27/go1/"/>
    <id>https://222cabbage.github.io/2022/09/27/go1/</id>
    <published>2022-09-27T15:41:02.000Z</published>
    <updated>2022-09-27T17:37:22.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来看看Go，躺平无出路，内卷才是真"><a href="#来看看Go，躺平无出路，内卷才是真" class="headerlink" title="来看看Go，躺平无出路，内卷才是真"></a>来看看Go，躺平无出路，内卷才是真</h2><p>go对比其他语言阿巴阿巴，百度一下长篇大论很多</p><p>我是看的电子书，因为感觉看视频学习太慢了，看书的话效率或许会高一些</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>还能怎么安装？官网下载安装包双击启动一把梭哈，无脑下一步，再配置配置环境变量GOPATH(安装后自动生成)，完美</p><p>cmd后输入go env 回车测试go安装成功与否</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="src：放置项目和库的源文件"><a href="#src：放置项目和库的源文件" class="headerlink" title="src：放置项目和库的源文件"></a>src：放置项目和库的源文件</h4><h4 id="pkg：放置编译后生成的包-x2F-库的归档文件"><a href="#pkg：放置编译后生成的包-x2F-库的归档文件" class="headerlink" title="pkg：放置编译后生成的包&#x2F;库的归档文件"></a>pkg：放置编译后生成的包&#x2F;库的归档文件</h4><h4 id="bin：放置编译后生成的可执行文件"><a href="#bin：放置编译后生成的可执行文件" class="headerlink" title="bin：放置编译后生成的可执行文件"></a>bin：放置编译后生成的可执行文件</h4><p>loading……学完再提交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;来看看Go，躺平无出路，内卷才是真&quot;&gt;&lt;a href=&quot;#来看看Go，躺平无出路，内卷才是真&quot; class=&quot;headerlink&quot; title=&quot;来看看Go，躺平无出路，内卷才是真&quot;&gt;&lt;/a&gt;来看看Go，躺平无出路，内卷才是真&lt;/h2&gt;&lt;p&gt;go对比其他语言阿巴</summary>
      
    
    
    
    <category term="Go" scheme="https://222cabbage.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://222cabbage.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>vue3的优化</title>
    <link href="https://222cabbage.github.io/2022/09/24/vue32/"/>
    <id>https://222cabbage.github.io/2022/09/24/vue32/</id>
    <published>2022-09-24T05:02:16.000Z</published>
    <updated>2022-09-24T14:34:09.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3做了什么样的优化？为什么需要这些优化？"><a href="#vue3做了什么样的优化？为什么需要这些优化？" class="headerlink" title="vue3做了什么样的优化？为什么需要这些优化？"></a>vue3做了什么样的优化？为什么需要这些优化？</h2><p>vue从1-2最大的变化就是引入了虚拟dom</p><p>vue3的优化</p><h4 id="更好的代码管理方式monorepo，将不同模块拆分到不同的package中"><a href="#更好的代码管理方式monorepo，将不同模块拆分到不同的package中" class="headerlink" title="更好的代码管理方式monorepo，将不同模块拆分到不同的package中"></a>更好的代码管理方式monorepo，将不同模块拆分到不同的package中</h4><p>每个package有各自的API，类型定义和测试</p><p>package-比如reactive，是可以独立于vue.js使用的，这样用户如果只想使用单个vue的能力而不必去依赖整个库。减少了引用包的体积大小，v2是做不到的</p><p>import { reactive }  from ‘vue’</p><h4 id="采用了ts开发"><a href="#采用了ts开发" class="headerlink" title="采用了ts开发"></a>采用了ts开发</h4><p>v2是flow，v3使用ts重构</p><p>flow是facebook出品的js静态类型检查工具，以非常小的成本对已有js代码迁入，v2采用时就是考虑到了flow的轻便灵活性</p><p>但是flow对于复杂场景类型十分不友好，v2源码有吐槽</p><p><img src="https://s1.ax1x.com/2022/09/24/xAIa7V.png"></p><p>ts则相反，更好的类型检查</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>减少了包的体积，移除冷门的feature，使用了tree-shaking</p><p>tree-shaking是依赖es6的静态结构，import和export。通过编译阶段的静态分析，找到没有引入的模块并打标记</p><p>间接减少了vue包的体积</p><p>数据劫持优化</p><p>vue的数据从1x版本开始就是响应式的</p><p><img src="https://s1.ax1x.com/2022/09/24/xAIbnI.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vue2是通过object.deineProperty(data,&#x27;a&#x27;,&#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        //track</span><br><span class="line">    &#125;,</span><br><span class="line">    set()&#123;</span><br><span class="line">        //trigger</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">缺点：必须要先知道拦截对象的key，因此无法检测对象属性的删除和添加</span><br><span class="line">因此退出了$set和$delete</span><br><span class="line"></span><br><span class="line">obj.define缺陷：如果对象层级较深，为了对所有属性进行劫持，需要遍历劫持，性能消耗高</span><br><span class="line"></span><br><span class="line">因此vue3采用了proxy</span><br><span class="line">proxy检测的是整个对象，因此对于新增删除都可以监听到</span><br><span class="line">但是proxy无法监听内部深层次的对象变化，因此v3的处理方式是在getter中去递归响应式</span><br><span class="line">这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</span><br></pre></td></tr></table></figure><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>除了在数据劫持部分的优化，也可以在耗时较多的patch阶段想办法</p><p>2x</p><p><img src="https://s1.ax1x.com/2022/09/24/xAom34.png"></p><p>3x</p><p>通过在编译阶段优化编译结果，实现运行时patch过程的优化</p><p>2x版本对于数据更新并触发重新渲染的粒度是组件级的</p><p>每次diff都会全部对比，vnode和模板大小正相关</p><p>当只有小部分更改时，多余的便利是对性能的浪费</p><p>v3通过编译阶段对静态模板的分析，编译生成了Block tree &#x2F;&#x2F;将模板基于动态节点指令切割的嵌套区域，每个区块内部的节点结构是固定的，每个区块只需要一个Array来追踪自身包含的动态节点</p><p>借助block tree vue将vnode更新性能由整体模板大小相关变成了与动态内容修改的数量有关</p><p>3x版本在编译节点还包含对slot的编译优化，事件侦听函数的缓存优化，并且在运行时重写了diff算法</p><h4 id="优化逻辑组织"><a href="#优化逻辑组织" class="headerlink" title="优化逻辑组织"></a>优化逻辑组织</h4><p>3x还提供了comonsition api</p><p>2x被称为options api</p><p>options api在组件小的时候一目了然，大的时候就很复杂，每当修改某一个关注点，就需要上下滑动变动多个位置</p><h4 id="优化逻辑复用"><a href="#优化逻辑复用" class="headerlink" title="优化逻辑复用"></a>优化逻辑复用</h4><p>v2采用mixins，可以定义props，data，容易导致定义相同名称变量，导致命名冲突</p><p>而且在使用时，对于不在当前组件定义的变量等事物，使用时数据来源不清器</p><p>v3采用hook方式</p><p>更好的类型支持</p><p>因为componsition具备更好的类型支持，因为都是函数，类型容易被推导，和v2不同，v2使用this不容易推导。</p><p>componsition api对tree-shaking更友好，代码压缩更容易</p><h4 id="引入RFC：使每个版本改动可控"><a href="#引入RFC：使每个版本改动可控" class="headerlink" title="引入RFC：使每个版本改动可控"></a>引入RFC：使每个版本改动可控</h4><p>v2部分采用REF(reqquest for comments) &#x2F;&#x2F;为新功能进入框架提供一个一致且受控的路径</p><p>v3大规模采用RFC，你可以了解每一个feature采用或者被废弃的前因后果</p><h4 id="小缺点："><a href="#小缺点：" class="headerlink" title="小缺点："></a>小缺点：</h4><p>vue3是采用es6的语法开发，有些api如proxy是没有polyfill的，这就意味着官方需要单独出一个ie11的compat版本来支持ie11</p><p>v2官方声明继续维护18个月，也就是说18个月以后，如果你的项目出了什么问题，那么就需要你自己阅读源码解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3做了什么样的优化？为什么需要这些优化？&quot;&gt;&lt;a href=&quot;#vue3做了什么样的优化？为什么需要这些优化？&quot; class=&quot;headerlink&quot; title=&quot;vue3做了什么样的优化？为什么需要这些优化？&quot;&gt;&lt;/a&gt;vue3做了什么样的优化？为什么需</summary>
      
    
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>看看WebGIS，极简单的智慧校园小demo</title>
    <link href="https://222cabbage.github.io/2022/09/23/webgis1/"/>
    <id>https://222cabbage.github.io/2022/09/23/webgis1/</id>
    <published>2022-09-22T18:30:26.000Z</published>
    <updated>2022-09-24T04:57:51.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近闲来无事，看看WebGIS"><a href="#最近闲来无事，看看WebGIS" class="headerlink" title="最近闲来无事，看看WebGIS"></a>最近闲来无事，看看WebGIS</h2><h3 id="什么是GIS？"><a href="#什么是GIS？" class="headerlink" title="什么是GIS？"></a>什么是GIS？</h3><p>GIS是一门综合型学科，结合了地理学与地图学以及遥感和计算机科学</p><h3 id="GIS开发方向"><a href="#GIS开发方向" class="headerlink" title="GIS开发方向"></a>GIS开发方向</h3><p>桌面端开发&#x2F;桌面GIS-C&#x2F;S架构，web开发&#x2F;webgis-BS架构，移动端开发&#x2F;移动gis-高德地图，美团外卖等</p><h3 id="WebGIS开发"><a href="#WebGIS开发" class="headerlink" title="WebGIS开发"></a>WebGIS开发</h3><p>前端可视化技术和GIS相结合</p><p>以canvas和webGL为代表的的前端可视化技术提供了很多效果和交互</p><p>处理二维GIS的openLayers，MapBox，leaflet</p><p>处理三维GIS的cesium</p><p>WebGIS和云计算，分布式机构结合，GIS云平台的出现 - 中地数码推出的GIS云平台</p><h4 id="为什么选择WebGIS"><a href="#为什么选择WebGIS" class="headerlink" title="为什么选择WebGIS"></a>为什么选择WebGIS</h4><p>相对于其他技术和编程语言，难度较低，上手快，成就感大</p><h3 id="基础平台"><a href="#基础平台" class="headerlink" title="基础平台"></a>基础平台</h3><p>MapGIS，ArcGIS，SuperMap  &#x2F;&#x2F;类似安卓和苹果</p><p>可以基于基础平台开发定制应用</p><p>有些应用方向也会提供自己的平台，比如地图导航应用，高德开放平台，百度开放平台</p><p>面向大众提供地图API接口服务</p><p>所有的开放平台都一样，都能解决WebGIS的核心问题</p><p>高德比较好配置，轻量</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="地图组成结构"><a href="#地图组成结构" class="headerlink" title="地图组成结构"></a>地图组成结构</h4><p><img src="https://s1.ax1x.com/2022/09/23/xktUYQ.png"></p><h4 id="地图容器"><a href="#地图容器" class="headerlink" title="地图容器"></a>地图容器</h4><p>创建指定的id容器，和echarts一样，需要一个容器承载所有图层，点标记，矢量图形，控件</p><h4 id="图层layer"><a href="#图层layer" class="headerlink" title="图层layer"></a>图层layer</h4><p>一个地图通常由一个或者多个图层组成</p><p>高德地图提供了很多标准图层和自定义图层</p><p>标准图层</p><p>卫星图层</p><p>路网图层</p><p>路况图层</p><h4 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h4><p>覆盖在图层上，通过矢量的方式，几何的方式，展示大小变化，但是其代表的实际路径和范围不变</p><p>除了折线，圆，多变性之外，JS的API还提供了矩形椭圆等常用矢量图形</p><h4 id="点标记"><a href="#点标记" class="headerlink" title="点标记"></a>点标记</h4><p>一个点要素，标记点</p><h4 id="地图控件"><a href="#地图控件" class="headerlink" title="地图控件"></a>地图控件</h4><p>悬浮在所有图层和地图要素上，满足一定交互和提示功能</p><p>放大缩小，调整方向</p><h4 id="地图级别ZoomLevel"><a href="#地图级别ZoomLevel" class="headerlink" title="地图级别ZoomLevel"></a>地图级别ZoomLevel</h4><p>级别与地图比例尺成正比，每增大一级，比例尺放大一倍，地图显示的越详细，最小级别通常为3级，高德地图目前最大级别为20级</p><h4 id="经纬度LngLat"><a href="#经纬度LngLat" class="headerlink" title="经纬度LngLat"></a>经纬度LngLat</h4><p>经纬度坐标</p><p>东西经180度，(-180-180)，西半球为负，东半球为正</p><p>南北纬(-85-85)，北半球为正，南半球为负</p><h4 id="底图BaseLayer"><a href="#底图BaseLayer" class="headerlink" title="底图BaseLayer"></a>底图BaseLayer</h4><p>位于所有图层和图形的最下方的图层，通常不透明，可以是单一图层，比如官方标准图层，也可以是图层组合，比如卫星图层和路网图层结合</p><h4 id="地图要素Map-Features"><a href="#地图要素Map-Features" class="headerlink" title="地图要素Map Features"></a>地图要素Map Features</h4><p>展示在地图上的地理要素，道路，区域面，建筑，POI标注，路名等，开发者自定义的点标记矢量图形也可以看做是地图要素</p><h4 id="标注Label"><a href="#标注Label" class="headerlink" title="标注Label"></a>标注Label</h4><p>地图上带有标示信息的文字或图标，POI标注，道路名称标注</p><h4 id="地图平面像素坐标Plane-Coordinates"><a href="#地图平面像素坐标Plane-Coordinates" class="headerlink" title="地图平面像素坐标Plane Coordinates"></a>地图平面像素坐标Plane Coordinates</h4><p>投影为平面之后的地图上的平面像素坐标……</p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>将地球球面的经纬度坐标映射到动图平面坐标的变换和映射关系，高德地图使用Web墨卡托投影，采用EPSG:3857坐标系统</p><h3 id="注册高德开放平台"><a href="#注册高德开放平台" class="headerlink" title="注册高德开放平台"></a>注册高德开放平台</h3><p>进入高德开放平台注册登录认证，在控制台点击应用管理新增一个应用</p><p>新增完后点击右上角添加key，选择web</p><p>添加成功后会出现key和安全密匙</p><p>后续可看开发支持中的开发文档</p><p>因为第一次接触，所以使用的是不带框架的用法，后面研究一下搭配vue或者react如何使用，应该要安装然全局配置<br>首先需要准备一个具备宽高的容器container</p><h3 id="GeoJSON"><a href="#GeoJSON" class="headerlink" title="GeoJSON"></a>GeoJSON</h3><p>一种保存地理信息数据的格式</p><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>在地图上绘制了多个标记点后，刷新页面标记点消失，是因为代表着标记点的变量是临时在内存中开辟出来的，刷新后就会消失</p><h4 id="持久化的方式"><a href="#持久化的方式" class="headerlink" title="持久化的方式"></a>持久化的方式</h4><p>1：使用GDB数据库，将数据保存在地理数据库中</p><p>2：使用GeoJSON，将数据保存在该格式的文件中</p><h3 id="智慧校园小demo"><a href="#智慧校园小demo" class="headerlink" title="智慧校园小demo"></a>智慧校园小demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;智慧校园demo&lt;/title&gt;</span><br><span class="line">    &lt;title&gt;点标记锚点&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        window._AMapSecurityConfig = &#123;</span><br><span class="line">            securityJsCode:&#x27;注册高德开发者后得到的安全密匙&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=2.0&amp;key=注册高德开发者后得到的key&quot;&gt;&lt;/script&gt; </span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;info&quot;&gt;点击地图标注热门地点&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let map = new AMap.Map(&#x27;container&#x27;,&#123;</span><br><span class="line">            center: [105.888,29.3915],</span><br><span class="line">            zoom:16.5,</span><br><span class="line">            viewMode:&#x27;3D&#x27;,</span><br><span class="line">            pitch:45</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //使用空间</span><br><span class="line">        AMap.plugin([</span><br><span class="line">            &#x27;AMap.ToolBar&#x27;,</span><br><span class="line">            &#x27;AMap.Scale&#x27;,</span><br><span class="line">            &#x27;AMap.HawkEye&#x27;,</span><br><span class="line">            &#x27;AMap.MapType&#x27;,</span><br><span class="line">            &#x27;AMap.Geolocation&#x27;,</span><br><span class="line">            &#x27;AMap.ControlBar&#x27;,</span><br><span class="line">            // &#x27;AMap.GeoJSON&#x27;</span><br><span class="line">        ], function()&#123;</span><br><span class="line">            // 在图面添加工具条控件，工具条控件集成了缩放、平移、定位等功能按钮在内的组合控件</span><br><span class="line">            map.addControl(new AMap.ToolBar());</span><br><span class="line">            // 在图面添加比例尺控件，展示地图在当前层级和纬度下的比例尺</span><br><span class="line">            map.addControl(new AMap.Scale());</span><br><span class="line">            // 在图面添加鹰眼控件，在地图右下角显示地图的缩略图</span><br><span class="line">            // map.addControl(new AMap.HawkEye(&#123;isOpen:true&#125;));</span><br><span class="line">            // 在图面添加类别切换控件，实现默认图层与卫星图、实施交通图层之间切换的控制</span><br><span class="line">            // map.addControl(new AMap.MapType());</span><br><span class="line">            // 在图面添加定位控件，用来获取和展示用户主机所在的经纬度位置</span><br><span class="line">            // map.addControl(new AMap.Geolocation());</span><br><span class="line">            map.addControl(new AMap.ControlBar());</span><br><span class="line">            // map.addControl(new AMap.GeoJSON())</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 定义一个全局对象保存json 持久化 有点小问题，按照官网来的报错</span><br><span class="line">        // let geojson = new AMap.GeoJSON(&#123;</span><br><span class="line">        //     geoJSON:null</span><br><span class="line">        // &#125;)</span><br><span class="line">        // // //导入数据 如果存在数据，n那么才导入数据，不存在数据什么都不做</span><br><span class="line">        // if(JSON.stringify(getStorageData) != &#x27;[]&#x27;)&#123;</span><br><span class="line">        //     geojson.importData(getStorageData())</span><br><span class="line">        // &#125;</span><br><span class="line">        // map.add(geojson)</span><br><span class="line">        </span><br><span class="line">        // console.log(geojson)</span><br><span class="line">        // 标记点 刷新页面会丢失</span><br><span class="line">         map.on(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">            // 获取点击地点信息 </span><br><span class="line">            var marker = new AMap.Marker(&#123;</span><br><span class="line">                position:e.lnglat,   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            //使用覆盖物的点击事件</span><br><span class="line">            marker.on(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">                console.log(e)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            map.add(marker);</span><br><span class="line">            // 通过geojson对象来管理覆盖物</span><br><span class="line">            // geojson.addOverlay(marker)</span><br><span class="line">            // setStorageData(geojson.toGeoJSON())</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结束也意味着新的开始……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最近闲来无事，看看WebGIS&quot;&gt;&lt;a href=&quot;#最近闲来无事，看看WebGIS&quot; class=&quot;headerlink&quot; title=&quot;最近闲来无事，看看WebGIS&quot;&gt;&lt;/a&gt;最近闲来无事，看看WebGIS&lt;/h2&gt;&lt;h3 id=&quot;什么是GIS？&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="WebGIS" scheme="https://222cabbage.github.io/categories/WebGIS/"/>
    
    
    <category term="WebGIS" scheme="https://222cabbage.github.io/tags/WebGIS/"/>
    
  </entry>
  
  <entry>
    <title>跟着官网过过微信小程序</title>
    <link href="https://222cabbage.github.io/2022/09/14/miniweixin/"/>
    <id>https://222cabbage.github.io/2022/09/14/miniweixin/</id>
    <published>2022-09-14T05:01:21.000Z</published>
    <updated>2022-09-14T06:24:09.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跟着官网过过微信小程序"><a href="#跟着官网过过微信小程序" class="headerlink" title="跟着官网过过微信小程序"></a>跟着官网过过微信小程序</h2><p>记录一些小的知识点</p><h3 id="场景值"><a href="#场景值" class="headerlink" title="场景值"></a>场景值</h3><p>记录用户进入小程序的路径，where进入</p><ul><li>对于小程序，可以在 <code>App</code> 的 <code>onLaunch</code> 和 <code>onShow</code>，或<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中获取上述场景值。</li><li>对于小游戏，可以在 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 和 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/(wx.onShow)">wx.onShow</a> 中获取上述场景值</li></ul><p>部分场景值：官网copy</p><table><thead><tr><th>场景值</th><th>场景</th><th>appId含义</th></tr></thead><tbody><tr><td>1020</td><td>公众号 profile 页相关小程序列表</td><td>来源公众号</td></tr><tr><td>1035</td><td>公众号自定义菜单</td><td>来源公众号</td></tr><tr><td>1036</td><td>App 分享消息卡片</td><td>来源App</td></tr><tr><td>1037</td><td>小程序打开小程序</td><td>来源小程序</td></tr><tr><td>1038</td><td>从另一个小程序返回</td><td>来源小程序</td></tr><tr><td>1043</td><td>公众号模板消息</td><td>来源公众号</td></tr></tbody></table><h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><table><thead><tr><th>路由方式</th><th>触发时机</th><th>路由前页面</th><th>路由后页面</th></tr></thead><tbody><tr><td>初始化</td><td>小程序打开的第一个页面</td><td></td><td>onLoad, onShow</td></tr><tr><td>打开新页面</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onHide</td><td>onLoad, onShow</td></tr><tr><td>页面重定向</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onUnload</td><td>onLoad, onShow</td></tr><tr><td>页面返回</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a>使用组件<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a>用户按左上角返回按钮</td><td>onUnload</td><td>onShow</td></tr><tr><td>Tab 切换</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a>用户切换 Tab</td><td></td><td>各种情况请参考下表</td></tr><tr><td>重启动</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onUnload</td><td>onLoad, onShow</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li><li><code>switchTab</code> 只能打开 tabBar 页面。</li><li><code>reLaunch</code> 可以打开任意页面。</li><li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li><li>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</li></ul><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><p>大多数 API 都是异步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login</a> 等。这类 API 接口通常都接受一个 <code>Object</code> 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：</p><p><strong>Object 参数说明</strong></p><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>success</td><td>function</td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）</td></tr><tr><td>其他</td><td>Any</td><td>-</td><td>接口定义的其他参数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    console.log(res.code)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">异步调用返回promise</span><br><span class="line">// callback 形式调用</span><br><span class="line">wx.chooseImage(&#123;</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// promise 形式调用</span><br><span class="line">wx.chooseImage().then(res =&gt; console.log(&#x27;res: &#x27;, res))</span><br></pre></td></tr></table></figure><h3 id="云开发API"><a href="#云开发API" class="headerlink" title="云开发API"></a>云开发API</h3><p>开通并使用<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信云开发</a>，即可使用云开发API，在小程序端直接调用服务端的<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#%E4%BA%91%E5%87%BD%E6%95%B0">云函数</a>。</p><p><strong>代码示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">  // 云函数名称</span><br><span class="line">  name: &#x27;cloudFunc&#x27;,</span><br><span class="line">  // 传给云函数的参数</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    console.log(res.result) // 示例</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: console.error</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 此外，云函数同样支持 promise 形式调用</span><br></pre></td></tr></table></figure><p>loading……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跟着官网过过微信小程序&quot;&gt;&lt;a href=&quot;#跟着官网过过微信小程序&quot; class=&quot;headerlink&quot; title=&quot;跟着官网过过微信小程序&quot;&gt;&lt;/a&gt;跟着官网过过微信小程序&lt;/h2&gt;&lt;p&gt;记录一些小的知识点&lt;/p&gt;
&lt;h3 id=&quot;场景值&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="微信小程序" scheme="https://222cabbage.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="https://222cabbage.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
