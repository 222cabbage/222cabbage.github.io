<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://222cabbage.github.io/atom.xml" rel="self"/>
  
  <link href="https://222cabbage.github.io/"/>
  <updated>2022-12-11T15:29:43.307Z</updated>
  <id>https://222cabbage.github.io/</id>
  
  <author>
    <name>不知名小白菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>看一下mongodb</title>
    <link href="https://222cabbage.github.io/2022/12/11/mongostudy/"/>
    <id>https://222cabbage.github.io/2022/12/11/mongostudy/</id>
    <published>2022-12-11T10:01:56.000Z</published>
    <updated>2022-12-11T15:29:43.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近想做个日程表"><a href="#最近想做个日程表" class="headerlink" title="最近想做个日程表"></a>最近想做个日程表</h2><p>下载mongodb</p><p>cmd打开窗口</p><p>show dbs 展示已有数据库</p><p>use block 创建一个名为block的数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最近想做个日程表&quot;&gt;&lt;a href=&quot;#最近想做个日程表&quot; class=&quot;headerlink&quot; title=&quot;最近想做个日程表&quot;&gt;&lt;/a&gt;最近想做个日程表&lt;/h2&gt;&lt;p&gt;下载mongodb&lt;/p&gt;
&lt;p&gt;cmd打开窗口&lt;/p&gt;
&lt;p&gt;show dbs 展示已有数</summary>
      
    
    
    
    <category term="mongo" scheme="https://222cabbage.github.io/categories/mongo/"/>
    
    
    <category term="mongo" scheme="https://222cabbage.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>vuejs设计与实现的阅读</title>
    <link href="https://222cabbage.github.io/2022/12/07/realizationvue/"/>
    <id>https://222cabbage.github.io/2022/12/07/realizationvue/</id>
    <published>2022-12-07T13:00:21.000Z</published>
    <updated>2022-12-07T16:23:57.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>@click&#x3D;”toXXXX”</p><p>注重过程，内部实现了该事件</p><h3 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h3><p>xxx.textContent &#x3D; ‘xxx’</p><p>注重过程</p><p>声明式和命令式的对比，命令式性能更好，声明式是在方便开发，利于维护的情况下尽量去减少性能的损耗</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>紧跟着的是虚拟DOM</p><p>循环向数组push对象和循环向一个节点appendChild对比起来，明显前者效率更高，性能更好</p><p>如何让声明式的性能更加接近命令式呢，就需要最小化的寻找到二者之间对比的差异</p><p>提供一个render函数，将一个树形结构对象递归转换成真实DOM</p><p>缺少了一部分，我们只是将属性结构对象递归转换成真实DOM，缺少将真实DOM转换成树形结构的方法</p><p>因此complier函数设计出来</p><p>let dom &#x3D; <div>节点</div></p><p>let obj &#x3D; compiler(dom) &#x2F;&#x2F;转换成树形结构对象</p><p>render(obj，document.body)&#x2F;&#x2F;将转换后的树形结构渲染成真实DOM插入body中</p><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>去除打包后项目中的无用代码，必须依赖于es module</p><p>什么是副作用函数？就是内部操作会影响外部变量的函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;声明式&quot;&gt;&lt;a href=&quot;#声明式&quot; class=&quot;headerlink&quot; title=&quot;声明式&quot;&gt;&lt;/a&gt;声明式&lt;/h3&gt;&lt;p&gt;@click&amp;#x3D;”toXXXX”&lt;/p&gt;
&lt;p&gt;注重过程，内部实现了该事件&lt;/p&gt;
&lt;h3 id=&quot;命令式&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="vue实现" scheme="https://222cabbage.github.io/categories/vue%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="vue实现" scheme="https://222cabbage.github.io/tags/vue%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>与react-native在职场上的碰撞</title>
    <link href="https://222cabbage.github.io/2022/12/01/reactnative/"/>
    <id>https://222cabbage.github.io/2022/12/01/reactnative/</id>
    <published>2022-12-01T14:53:48.000Z</published>
    <updated>2022-12-03T14:44:09.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="与react-native在职场上的碰撞"><a href="#与react-native在职场上的碰撞" class="headerlink" title="与react-native在职场上的碰撞"></a>与react-native在职场上的碰撞</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;与react-native在职场上的碰撞&quot;&gt;&lt;a href=&quot;#与react-native在职场上的碰撞&quot; class=&quot;headerlink&quot; title=&quot;与react-native在职场上的碰撞&quot;&gt;&lt;/a&gt;与react-native在职场上的碰撞&lt;/h2&gt;</summary>
      
    
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/categories/react-native/"/>
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>react-native上手</title>
    <link href="https://222cabbage.github.io/2022/10/19/rn1/"/>
    <id>https://222cabbage.github.io/2022/10/19/rn1/</id>
    <published>2022-10-19T15:15:21.000Z</published>
    <updated>2022-10-19T16:39:40.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-native，一个按照官网来搭建环境都能搭建错的app开发方案"><a href="#react-native，一个按照官网来搭建环境都能搭建错的app开发方案" class="headerlink" title="react-native，一个按照官网来搭建环境都能搭建错的app开发方案"></a>react-native，一个按照官网来搭建环境都能搭建错的app开发方案</h2><p>环境什么的就不说了，百度一下大概就知道</p><p>安装node，react-native-cli，android-studio，jdk8版</p><p>react-native init mypro –version 0.68.2 不带后面的版本会报错</p><p>yarn android运行</p><p>然后有报奇奇怪怪的错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-native，一个按照官网来搭建环境都能搭建错的app开发方案&quot;&gt;&lt;a href=&quot;#react-native，一个按照官网来搭建环境都能搭建错的app开发方案&quot; class=&quot;headerlink&quot; title=&quot;react-native，一个按照官</summary>
      
    
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/categories/react-native/"/>
    
    
    <category term="react-native" scheme="https://222cabbage.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>讲讲入职第一天的工作</title>
    <link href="https://222cabbage.github.io/2022/10/17/work1/"/>
    <id>https://222cabbage.github.io/2022/10/17/work1/</id>
    <published>2022-10-17T14:15:26.000Z</published>
    <updated>2022-10-17T14:21:51.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分享一下入职第一天的生活"><a href="#分享一下入职第一天的生活" class="headerlink" title="分享一下入职第一天的生活"></a>分享一下入职第一天的生活</h2><p>第一天入职嘛，难免紧张</p><p>这是我实习结束后的第一份正式工作，我想在任何方面都做好</p><p>在办理玩入职后，有小姐姐带我领取了一台电脑，并带领我去了工位</p><p>我的工位旁就是带我的老大，还是蛮刺激的</p><p>老大后续带我去会议室和我讲解了一下团队的项目</p><p>光看成品还没什么，看代码才是真头痛</p><p>看代码的同时顺路搭建react native环境，这安卓环境是真难安装，按照react native官网上的步骤一步一步来都不知道哪里搞错了</p><p>再结合代码的难度，目录我都看不懂，因此让我萌生出了放弃的想法</p><p>但是再困难也得坚持下去，坚持才会有胜利的希望，我坚信我会变得越来越好</p><p>也很感谢那些激励我的小伙伴们，没有大家的鼓励我也很难重拾信心，啾咪……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分享一下入职第一天的生活&quot;&gt;&lt;a href=&quot;#分享一下入职第一天的生活&quot; class=&quot;headerlink&quot; title=&quot;分享一下入职第一天的生活&quot;&gt;&lt;/a&gt;分享一下入职第一天的生活&lt;/h2&gt;&lt;p&gt;第一天入职嘛，难免紧张&lt;/p&gt;
&lt;p&gt;这是我实习结束后的第一</summary>
      
    
    
    
    <category term="工作日志" scheme="https://222cabbage.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="工作日志" scheme="https://222cabbage.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://222cabbage.github.io/2022/10/09/mobile1/"/>
    <id>https://222cabbage.github.io/2022/10/09/mobile1/</id>
    <published>2022-10-09T06:10:24.000Z</published>
    <updated>2022-10-09T10:56:19.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端适配的方案"><a href="#移动端适配的方案" class="headerlink" title="移动端适配的方案"></a>移动端适配的方案</h2><h4 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h4><p>响应式布局，通过@media媒体查询实现一套html配合多套css实现适配</p><p>通过rem或者vh，vw实现不同设备有相同比例进而进行适配</p><p>或者媒体查询配合rem适配</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>viewport视口标签，想要统一标准视口</p><p>需要在head中添加</p><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><h4 id="rem实现原理"><a href="#rem实现原理" class="headerlink" title="rem实现原理"></a>rem实现原理</h4><p>rem是font-size的倍数大小，只需要在不同设备相同比例下设置不同的font-size大小就可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;title&gt;rem适配&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .box &#123;</span><br><span class="line">            /* 随意写大小，px to rem工具自动适配 */</span><br><span class="line">            width: 5rem;</span><br><span class="line">            height: 5rem;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 动态设置font-size</span><br><span class="line">        function resetHtmlFontSize()&#123;</span><br><span class="line">            document.documentElement.style.fontSize = screen.width / 10 + &#x27;px&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        // window.onresize = resetHtmlFontSize</span><br><span class="line">        window.addEventListener(&#x27;resize&#x27;,resetHtmlFontSize)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>弊端是如果设计稿修改，那么整体都要修改</p><h4 id="px-to-rem插件"><a href="#px-to-rem插件" class="headerlink" title="px to  rem插件"></a>px to  rem插件</h4><p>在vscode插件中搜索</p><p>安装后自动匹配px进行转换rem</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要一个配置文件，在目录下创建.cssrem</span><br><span class="line">复制</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/09/xJLb1P.png"></p><p>存在的弊端</p><p>转换错误后无法观看转换前的大小，所以一般是保留px，后期通过第三方工具，比如gulp动态监听转换</p><h4 id="媒体监听"><a href="#媒体监听" class="headerlink" title="媒体监听"></a>媒体监听</h4><p>媒体监听不是缩放，是同一个内容在不同设备上有合理的表现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media screen and （maxwidth：1000px）&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><h5 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h5><p>原理相对不好理解</p><p>从px到rem想要灵活的转换需要借助工具</p><p>灵活可控，完美复制设计稿</p><p>比较适合具有完全移动端的项目</p><h5 id="媒体查询："><a href="#媒体查询：" class="headerlink" title="媒体查询："></a>媒体查询：</h5><p>没有学习成本</p><p>如何适配需要重新定义，设计稿麻烦</p><p>复杂的组件很难完美呈现</p><p>适合只有pc端设计稿，但是需要兼容移动端的项目</p><h5 id="综合方案："><a href="#综合方案：" class="headerlink" title="综合方案："></a>综合方案：</h5><p>同时使用media和rem</p><p>实现比较复杂</p><p>自由度更好</p><p>颗粒度不好把握</p><p>微信小程序的css单位px换算单位1px&#x3D;2rpx，应该和rem适配原理大概相同</p><h4 id="如果是vue，可以使用postcss-px-to-viewport"><a href="#如果是vue，可以使用postcss-px-to-viewport" class="headerlink" title="如果是vue，可以使用postcss-px-to-viewport"></a>如果是vue，可以使用postcss-px-to-viewport</h4><p>我也看到别人说的其实没有最好的适配，或者移动端准备一套，pc准备一套</p><p>或者tailwindcss</p><p>每个人对技术的感悟都是不同的，都有各自的看法，最后采用什么样的技术方案也还是得根据实际项目来，没有什么最好的方案一说</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移动端适配的方案&quot;&gt;&lt;a href=&quot;#移动端适配的方案&quot; class=&quot;headerlink&quot; title=&quot;移动端适配的方案&quot;&gt;&lt;/a&gt;移动端适配的方案&lt;/h2&gt;&lt;h4 id=&quot;常见方案&quot;&gt;&lt;a href=&quot;#常见方案&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="移动端适配" scheme="https://222cabbage.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
    
    <category term="移动端适配" scheme="https://222cabbage.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>canvas2D绘图</title>
    <link href="https://222cabbage.github.io/2022/10/07/canvas1/"/>
    <id>https://222cabbage.github.io/2022/10/07/canvas1/</id>
    <published>2022-10-07T06:40:05.000Z</published>
    <updated>2022-10-08T06:11:53.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="canvas2D绘图"><a href="#canvas2D绘图" class="headerlink" title="canvas2D绘图"></a>canvas2D绘图</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- Canvas标签的默认大小为：300 x 150 (像素)，而这里咱们设置为了：200 x 200（像素）。</span><br><span class="line">    Canvas标签中的文字是在不支持Canvas标签的浏览器中使用的，因为支持Canvas标签的浏览器会忽略容器中包含的内  容正常渲染Canvas标签，而不支持Canvas标签的浏览器则相反，浏览器会忽略容器而显示其中的内容 --&gt;</span><br><span class="line">    &lt;canvas width=&quot;200&quot; height=&quot;200&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3qxtx.png"></p><h4 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h4><p>canvas标签提供了一个容器画布，如果想要进行绘制就得找到渲染上下文</p><p>getContext()</p><p>getContext方法是有一个接收参数，它是绘图上下文的类型</p><p>2d：建立一个二维渲染上下文。这种情况可以用 CanvasRenderingContext2D()来替换getContext(‘2d’)。</p><p>webgl（或 experimental-webgl）： 创建一个 WebGLRenderingContext 三维渲染上下文对象。只在实现WebGL 版本1(OpenGL ES 2.0)的浏览器上可用。</p><p>webgl2（或 experimental-webgl2）：创建一个 WebGL2RenderingContext 三维渲染上下文对象。只在实现 WebGL 版本2 (OpenGL ES 3.0)的浏览器上可用。</p><p>bitmaprenderer：创建一个只提供将canvas内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas&quot;&gt;</span><br><span class="line">        当前浏览器不支持canvas元素，请升级或者更换浏览器</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        let canvas = document.getElementById(&#x27;canvas&#x27;)</span><br><span class="line">        console.log(canvas.getContext)</span><br><span class="line">        if(canvas.getContext)&#123;</span><br><span class="line">            let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在获取上下文之后就可以绘制基本形状</p><h4 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h4><h5 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">moveTo(x, y)</span><br><span class="line">设置初始位置，参数为初始位置x和y的坐标点</span><br><span class="line"></span><br><span class="line">lineTo(x, y)</span><br><span class="line">绘制一条从初始位置到指定位置的直线，参数为指定位置x和y的坐标点</span><br><span class="line"></span><br><span class="line">stroke()</span><br><span class="line">通过线条来绘制图形轮廓</span><br><span class="line"></span><br><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">    ctx.moveTo(50,50)</span><br><span class="line">    ctx.lineTo(300,300)</span><br><span class="line">    ctx.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">    ctx.moveTo(50,50) //起点坐标</span><br><span class="line">    ctx.lineTo(300,300)</span><br><span class="line">    ctx.lineTo(50,300)</span><br><span class="line">    ctx.lineTo(50,50) //终点坐标。闭合点</span><br><span class="line">    ctx.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3xpOU.png"></p><h5 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h5><p>矩形的绘制并不是单纯的直线拼凑，canvas提供了相关api绘制矩形</p><p>strokeRect(x, y, width, height) 绘制一个矩形的边框</p><p>fillRect(x, y, width, height) 绘制一个填充的矩形</p><p>clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 矩形</span><br><span class="line">ctx.strokeRect(50,50,200,100)</span><br><span class="line">ctx.fillRect(50,160,200,100)</span><br><span class="line">ctx.clearRect(60,180,50,50</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x3zZNj.png"></p><h5 id="圆弧和圆"><a href="#圆弧和圆" class="headerlink" title="圆弧和圆"></a>圆弧和圆</h5><p>arc(x, y, radius, startAngle, endAngle, anticlockwise)。x和Y为圆心的坐标，radius为半径，startAngle为圆弧或圆的开始位置，endAngle为圆弧或圆的结束位置，anticlockwise是绘制的方向（不写默认为false，从顺时针方向)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 原型和弧</span><br><span class="line">ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">ctx.stroke()</span><br><span class="line"></span><br><span class="line">需要注意的是：在画弧的时候，arc()函数中角的单位是弧度而不是角度。角度换算为弧度的表达式为：弧度=(Math.PI/180)*角度。</span><br><span class="line"></span><br><span class="line">// 原型和弧</span><br><span class="line">// ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">// ctx.stroke()</span><br><span class="line"></span><br><span class="line">//  // 绘制一个圆弧</span><br><span class="line">// ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">// ctx.stroke();</span><br><span class="line"></span><br><span class="line">// 如果按照上述写法绘制一根弧线和圆 会出现路径相连，因此需要开启和闭合路径</span><br><span class="line">// beginPath</span><br><span class="line">// 新建一条路径，生成之后，图形绘制命令被指向到路径上。</span><br><span class="line"></span><br><span class="line">// closePath</span><br><span class="line">// 闭合路径之后图形绘制命令又重新指向到上下文中。 具体怎么使用这两个函数呢？下面咱们介绍一下，直接上代码：</span><br><span class="line">// 原型和弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(60, 60, 50, 0, Math.PI, false);</span><br><span class="line">ctx.fill(); //填充黑色</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line">// 绘制一个圆弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8S8QP.png"></p><p><img src="https://s1.ax1x.com/2022/10/07/x8SGsf.png"></p><p>在咱们开启和关闭路径的时候，关闭路径其实并不是必须的，对于新路径其实每次都开启新路径就ok。</p><p>填充fill</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 绘制一个圆弧</span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(200, 60, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><h5 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h5><p>ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)</p><ul><li>x、y：椭圆的圆心位置</li><li>radiusX、radiusY：x轴和y轴的半径</li><li>rotation：椭圆的旋转角度，以弧度表示</li><li>startAngle：开始绘制点</li><li>endAngle：结束绘制点</li><li>anticlockwise：绘制的方向（默认顺时针），可选参数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合了一下，有点搞笑</span><br><span class="line">// 椭圆</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(100, 150, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(400, 150, 50, 100, 0, 0, 2 * Math.PI);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath()</span><br><span class="line">ctx.arc(400, 150, 50, 0, Math.PI*2, false);</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.ellipse(250, 350, 20, 200, Math.PI/2, 0, 2 * Math.PI); // 旋转90°</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8CXY4.png"></p><h5 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 贝塞尔曲线</span><br><span class="line"> // 贝塞尔曲线一般用来绘制复杂有规律的图形，在Canvas中也是一个十分有用的路径类型。</span><br><span class="line"> // 二次贝塞尔曲线</span><br><span class="line"> // 语法：quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点</span><br><span class="line"> // 绘制一段二次贝塞尔曲线</span><br><span class="line"> ctx.moveTo(50, 50);</span><br><span class="line"> ctx.quadraticCurveTo(200, 200, 350, 50);</span><br><span class="line"> // 绘制</span><br><span class="line"> ctx.stroke();</span><br><span class="line"></span><br><span class="line">// 三次贝塞尔曲线</span><br><span class="line">// 和二次贝塞尔曲线不同的是三次贝塞尔曲线有两个控制点。</span><br><span class="line">// 语法：ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。</span><br><span class="line">ctx.beginPath() // 开启路径</span><br><span class="line">ctx.moveTo(50, 200);</span><br><span class="line">ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);</span><br><span class="line">// 绘制</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/10/07/x8P8hQ.png"></p><p><img src="https://s1.ax1x.com/2022/10/07/x8PJpj.png"></p><h4 id="绘制样式"><a href="#绘制样式" class="headerlink" title="绘制样式"></a>绘制样式</h4><h5 id="线条样式"><a href="#线条样式" class="headerlink" title="线条样式"></a>线条样式</h5><p>lineWidth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">let canvas = document.getElementById(&#x27;canvas&#x27;)</span><br><span class="line">        console.log(canvas.getContext)</span><br><span class="line">        if(canvas.getContext)&#123;</span><br><span class="line">            let ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">            // 线条样式</span><br><span class="line">             // lineWidth 设置当前绘线的粗细。属性值必须为正数。默认值是 1.0。</span><br><span class="line">            //  lineCap</span><br><span class="line">            // lineCap 设置线段端点显示的样子。可选值为：butt，round 和 square。默认是 butt。</span><br><span class="line">            // lineJoin</span><br><span class="line">            // lineJoin 该属性可以设置两线段连接处所显示的样子。可选值为：round, bevel 和 miter。默认是</span><br><span class="line">            // ctx.lineWidth = 10;</span><br><span class="line">            // ctx.lineCap=&#x27;round&#x27;</span><br><span class="line">            // ctx.moveTo(50,50)</span><br><span class="line">            // ctx.lineTo(300,300)</span><br><span class="line">            // ctx.stroke()</span><br><span class="line">            </span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.lineWidth = 10;</span><br><span class="line">            // ctx.lineJoin=&#x27;miter&#x27;</span><br><span class="line">            // ctx.moveTo(50, 20);</span><br><span class="line">            // ctx.lineTo(100, 60);</span><br><span class="line">            // ctx.lineTo(150, 20);</span><br><span class="line">            // ctx.lineTo(200, 60);</span><br><span class="line">            // ctx.lineTo(250, 20);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // ctx.closePath();</span><br><span class="line"></span><br><span class="line">            // miterLimit</span><br><span class="line">            // miterLimit 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</span><br><span class="line">            // 线段之间夹角比较大时，交点不会太远，但随着夹角变小，交点距离会呈指数级增大。</span><br><span class="line">            // 如果交点距离大于miterLimit值，连接效果会变成了 lineJoin = bevel 的效果。</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.lineWidth = 5;</span><br><span class="line">            // ctx.lineJoin=&#x27;miter&#x27;</span><br><span class="line">            // ctx.miterLimit = 10</span><br><span class="line">            // ctx.moveTo(0, 100);</span><br><span class="line">            // for (i = 0; i &lt; 30 ; i++) &#123;</span><br><span class="line">            //     var dy = i % 2 == 0 ? 200 : 100;</span><br><span class="line">            //     ctx.lineTo(Math.pow(i, 1.5) * 2, dy);</span><br><span class="line">            // &#125;</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // ctx.closePath();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // setLineDash/getLineDash</span><br><span class="line">            // setLineDash 可以设置当前虚线样式。</span><br><span class="line">            // getLineDash 则是返回当前虚线设置的样式，长度为非负偶数的数组。</span><br><span class="line">            // ctx.setLineDash([5, 10, 20]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,100);</span><br><span class="line">            // ctx.lineTo(400, 100);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // // 再绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20, 40]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 40]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,200);</span><br><span class="line">            // ctx.lineTo(400, 200);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line"></span><br><span class="line">            // lineDashOffset</span><br><span class="line">            // lineDashOffset 设置虚线样式的起始偏移量</span><br><span class="line">            // 绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 5, 10, 20]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,100);</span><br><span class="line">            // ctx.lineTo(400, 100);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            // // 再绘制一条虚线</span><br><span class="line">            // ctx.setLineDash([5, 10, 20, 40]);</span><br><span class="line">            // console.log(ctx.getLineDash()); // [5, 10, 20, 40]</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.moveTo(0,200);</span><br><span class="line">            // ctx.lineTo(400, 200);</span><br><span class="line">            // ctx.stroke();</span><br><span class="line">            </span><br><span class="line">            // 设置 globalAlpha 属性或者使用有透明度的样式作为轮廓或填充都可以实现</span><br><span class="line">            // 绘制一个矩形</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // // 指定透明度的填充样式</span><br><span class="line">            // ctx.fillStyle = &quot;rgba(0, 255, 0, 0.2)&quot;;</span><br><span class="line">            // ctx.fillRect(10,10,300,100);</span><br><span class="line">            // // 绘制一个矩形边框</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // // 指定透明度的描边样式</span><br><span class="line">            // ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.7)&quot;;</span><br><span class="line">            // ctx.strokeRect(10, 90, 100, 300);</span><br><span class="line">            // // 绘制一个圆</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.fillStyle = &quot;rgba(255, 255, 0, 1)&quot;;</span><br><span class="line">            // // 设置透明度值</span><br><span class="line">            // ctx.globalAlpha = 0.5;</span><br><span class="line">            // ctx.arc(200, 200, 100, 0, Math.PI*2, true);</span><br><span class="line">            // ctx.fill();</span><br><span class="line"></span><br><span class="line">            // 渐变</span><br><span class="line">            // 线性渐变和径向渐变</span><br><span class="line">            // 线性渐变</span><br><span class="line">            // 语法： createLinearGradient(x1, y1, x2, y2)，参数分别为 起点的坐标和终点的坐标。</span><br><span class="line">            // 在渐变的设置中还需要一个方法来添加渐变的颜色，语法为：gradient.addColorStop(offset, color)，</span><br><span class="line">            // 其中color就是颜色，offset 则是颜色的偏移值，只为0到1之间的数。</span><br><span class="line">            // 创建渐变</span><br><span class="line">            // var gradient1 = ctx.createLinearGradient(10, 10, 400, 10);</span><br><span class="line">            // gradient1.addColorStop(0, &quot;#00ff00&quot;);</span><br><span class="line">            // gradient1.addColorStop(1, &quot;#ff0000&quot;);</span><br><span class="line">            // var gradient2 = ctx.createLinearGradient(10, 10, 400, 10);</span><br><span class="line">            // // 从0.5的位置才开始渐变</span><br><span class="line">            // gradient2.addColorStop(0.5, &quot;#00ff00&quot;);</span><br><span class="line">            // gradient2.addColorStop(1, &quot;#ff0000&quot;);</span><br><span class="line">            // ctx.beginPath()</span><br><span class="line">            // ctx.fillStyle = gradient1;</span><br><span class="line">            // ctx.fillRect(10, 10, 400, 100);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient2;</span><br><span class="line">            // ctx.fillRect(10, 150, 400, 100);</span><br><span class="line"></span><br><span class="line">            //   径向渐变</span><br><span class="line">            // ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)，参数分别为开始圆的坐标和半径以及结束圆的坐标和半径。</span><br><span class="line">            // 结束坐标为点</span><br><span class="line">            // var gradient1 = ctx.createRadialGradient(100, 100, 100, 100, 100, 0);</span><br><span class="line">            // gradient1.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient1.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 结束坐标为半径30的圆</span><br><span class="line">            // var gradient2 = ctx.createRadialGradient(320, 100, 100, 320, 100, 30); </span><br><span class="line">            // gradient2.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient2.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 从0.5的位置才开始渲染</span><br><span class="line">            // var gradient3 = ctx.createRadialGradient(100, 320, 100, 100, 320, 0); </span><br><span class="line">            // gradient3.addColorStop(0.5, &quot;#ff770f&quot;); </span><br><span class="line">            // gradient3.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // // 开始坐标和结束坐标不一样</span><br><span class="line">            // var gradient4 = ctx.createRadialGradient(320, 320, 100, 250, 250, 0);</span><br><span class="line">            // gradient4.addColorStop(0, &quot;#ff770f&quot;);</span><br><span class="line">            // gradient4.addColorStop(1, &quot;#ffffff&quot;);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient1;</span><br><span class="line">            // ctx.fillRect(10, 10, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient2;</span><br><span class="line">            // ctx.fillRect(220, 10, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient3;</span><br><span class="line">            // ctx.fillRect(10, 220, 200, 200);</span><br><span class="line">            // ctx.beginPath();</span><br><span class="line">            // ctx.fillStyle = gradient4;</span><br><span class="line">            // ctx.fillRect(220, 220, 200, 200);</span><br><span class="line"></span><br><span class="line">            // Canvas中想绘制图案效果，需要用 createPattern 方法来实现。</span><br><span class="line">            // 语法：createPattern(image, type)，参数分别为：Image 参数可以是一个 Image 对象，也可以是一个 canvas 对象，Type 为图案绘制的类型，可用的类型分别有：repeat，repeat-x，repeat-y 和 no-repeat。</span><br><span class="line">            // 创建一个 image对象</span><br><span class="line">            // var img = new Image();</span><br><span class="line">            // img.src = &quot;./image.png&quot;;</span><br><span class="line">            // img.onload = function() &#123;</span><br><span class="line">            //     // 图片加载完以后</span><br><span class="line">            //     // 创建图案</span><br><span class="line">            //     var ptrn = ctx.createPattern(img, &#x27;no-repeat&#x27;);</span><br><span class="line">            //     ctx.fillStyle = ptrn;</span><br><span class="line">            //     ctx.fillRect(0, 0, 500, 500);</span><br><span class="line">            // &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>loading……</p><h5 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h5><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><h5 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h5><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><h5 id="strokeText描边"><a href="#strokeText描边" class="headerlink" title="strokeText描边"></a>strokeText描边</h5><h5 id="fillText填充"><a href="#fillText填充" class="headerlink" title="fillText填充"></a>fillText填充</h5><h5 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h5><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><h5 id="drawImage"><a href="#drawImage" class="headerlink" title="drawImage"></a>drawImage</h5><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><h5 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h5><h5 id="移动、旋转和缩放"><a href="#移动、旋转和缩放" class="headerlink" title="移动、旋转和缩放"></a>移动、旋转和缩放</h5><h5 id="transform，setTransform，resetTransform"><a href="#transform，setTransform，resetTransform" class="headerlink" title="transform，setTransform，resetTransform"></a>transform，setTransform，resetTransform</h5><h4 id="合成与裁剪"><a href="#合成与裁剪" class="headerlink" title="合成与裁剪"></a>合成与裁剪</h4><h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><h5 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h5><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><h4 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h4><h5 id="绘制小球"><a href="#绘制小球" class="headerlink" title="绘制小球"></a>绘制小球</h5><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><h5 id="加速度"><a href="#加速度" class="headerlink" title="加速度"></a>加速度</h5><h5 id="拖尾效果"><a href="#拖尾效果" class="headerlink" title="拖尾效果"></a>拖尾效果</h5><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h5><h5 id="反相颜色"><a href="#反相颜色" class="headerlink" title="反相颜色"></a>反相颜色</h5><h5 id="像素数据"><a href="#像素数据" class="headerlink" title="像素数据"></a>像素数据</h5><p>跟着掘金上的一篇文章学习的</p><p>作者：ndz链接：<a href="https://juejin.cn/post/7119495608938790942%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.cn/post/7119495608938790942来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;canvas2D绘图&quot;&gt;&lt;a href=&quot;#canvas2D绘图&quot; class=&quot;headerlink&quot; title=&quot;canvas2D绘图&quot;&gt;&lt;/a&gt;canvas2D绘图&lt;/h2&gt;&lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;head</summary>
      
    
    
    
    <category term="canvas" scheme="https://222cabbage.github.io/categories/canvas/"/>
    
    
    <category term="canvas" scheme="https://222cabbage.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>学一下Go</title>
    <link href="https://222cabbage.github.io/2022/09/27/go1/"/>
    <id>https://222cabbage.github.io/2022/09/27/go1/</id>
    <published>2022-09-27T15:41:02.000Z</published>
    <updated>2022-09-27T17:37:22.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来看看Go，躺平无出路，内卷才是真"><a href="#来看看Go，躺平无出路，内卷才是真" class="headerlink" title="来看看Go，躺平无出路，内卷才是真"></a>来看看Go，躺平无出路，内卷才是真</h2><p>go对比其他语言阿巴阿巴，百度一下长篇大论很多</p><p>我是看的电子书，因为感觉看视频学习太慢了，看书的话效率或许会高一些</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>还能怎么安装？官网下载安装包双击启动一把梭哈，无脑下一步，再配置配置环境变量GOPATH(安装后自动生成)，完美</p><p>cmd后输入go env 回车测试go安装成功与否</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="src：放置项目和库的源文件"><a href="#src：放置项目和库的源文件" class="headerlink" title="src：放置项目和库的源文件"></a>src：放置项目和库的源文件</h4><h4 id="pkg：放置编译后生成的包-x2F-库的归档文件"><a href="#pkg：放置编译后生成的包-x2F-库的归档文件" class="headerlink" title="pkg：放置编译后生成的包&#x2F;库的归档文件"></a>pkg：放置编译后生成的包&#x2F;库的归档文件</h4><h4 id="bin：放置编译后生成的可执行文件"><a href="#bin：放置编译后生成的可执行文件" class="headerlink" title="bin：放置编译后生成的可执行文件"></a>bin：放置编译后生成的可执行文件</h4><p>loading……学完再提交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;来看看Go，躺平无出路，内卷才是真&quot;&gt;&lt;a href=&quot;#来看看Go，躺平无出路，内卷才是真&quot; class=&quot;headerlink&quot; title=&quot;来看看Go，躺平无出路，内卷才是真&quot;&gt;&lt;/a&gt;来看看Go，躺平无出路，内卷才是真&lt;/h2&gt;&lt;p&gt;go对比其他语言阿巴</summary>
      
    
    
    
    <category term="Go" scheme="https://222cabbage.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://222cabbage.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>vue3的优化</title>
    <link href="https://222cabbage.github.io/2022/09/24/vue32/"/>
    <id>https://222cabbage.github.io/2022/09/24/vue32/</id>
    <published>2022-09-24T05:02:16.000Z</published>
    <updated>2022-09-24T14:34:09.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3做了什么样的优化？为什么需要这些优化？"><a href="#vue3做了什么样的优化？为什么需要这些优化？" class="headerlink" title="vue3做了什么样的优化？为什么需要这些优化？"></a>vue3做了什么样的优化？为什么需要这些优化？</h2><p>vue从1-2最大的变化就是引入了虚拟dom</p><p>vue3的优化</p><h4 id="更好的代码管理方式monorepo，将不同模块拆分到不同的package中"><a href="#更好的代码管理方式monorepo，将不同模块拆分到不同的package中" class="headerlink" title="更好的代码管理方式monorepo，将不同模块拆分到不同的package中"></a>更好的代码管理方式monorepo，将不同模块拆分到不同的package中</h4><p>每个package有各自的API，类型定义和测试</p><p>package-比如reactive，是可以独立于vue.js使用的，这样用户如果只想使用单个vue的能力而不必去依赖整个库。减少了引用包的体积大小，v2是做不到的</p><p>import { reactive }  from ‘vue’</p><h4 id="采用了ts开发"><a href="#采用了ts开发" class="headerlink" title="采用了ts开发"></a>采用了ts开发</h4><p>v2是flow，v3使用ts重构</p><p>flow是facebook出品的js静态类型检查工具，以非常小的成本对已有js代码迁入，v2采用时就是考虑到了flow的轻便灵活性</p><p>但是flow对于复杂场景类型十分不友好，v2源码有吐槽</p><p><img src="https://s1.ax1x.com/2022/09/24/xAIa7V.png"></p><p>ts则相反，更好的类型检查</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>减少了包的体积，移除冷门的feature，使用了tree-shaking</p><p>tree-shaking是依赖es6的静态结构，import和export。通过编译阶段的静态分析，找到没有引入的模块并打标记</p><p>间接减少了vue包的体积</p><p>数据劫持优化</p><p>vue的数据从1x版本开始就是响应式的</p><p><img src="https://s1.ax1x.com/2022/09/24/xAIbnI.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vue2是通过object.deineProperty(data,&#x27;a&#x27;,&#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        //track</span><br><span class="line">    &#125;,</span><br><span class="line">    set()&#123;</span><br><span class="line">        //trigger</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">缺点：必须要先知道拦截对象的key，因此无法检测对象属性的删除和添加</span><br><span class="line">因此退出了$set和$delete</span><br><span class="line"></span><br><span class="line">obj.define缺陷：如果对象层级较深，为了对所有属性进行劫持，需要遍历劫持，性能消耗高</span><br><span class="line"></span><br><span class="line">因此vue3采用了proxy</span><br><span class="line">proxy检测的是整个对象，因此对于新增删除都可以监听到</span><br><span class="line">但是proxy无法监听内部深层次的对象变化，因此v3的处理方式是在getter中去递归响应式</span><br><span class="line">这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</span><br></pre></td></tr></table></figure><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>除了在数据劫持部分的优化，也可以在耗时较多的patch阶段想办法</p><p>2x</p><p><img src="https://s1.ax1x.com/2022/09/24/xAom34.png"></p><p>3x</p><p>通过在编译阶段优化编译结果，实现运行时patch过程的优化</p><p>2x版本对于数据更新并触发重新渲染的粒度是组件级的</p><p>每次diff都会全部对比，vnode和模板大小正相关</p><p>当只有小部分更改时，多余的便利是对性能的浪费</p><p>v3通过编译阶段对静态模板的分析，编译生成了Block tree &#x2F;&#x2F;将模板基于动态节点指令切割的嵌套区域，每个区块内部的节点结构是固定的，每个区块只需要一个Array来追踪自身包含的动态节点</p><p>借助block tree vue将vnode更新性能由整体模板大小相关变成了与动态内容修改的数量有关</p><p>3x版本在编译节点还包含对slot的编译优化，事件侦听函数的缓存优化，并且在运行时重写了diff算法</p><h4 id="优化逻辑组织"><a href="#优化逻辑组织" class="headerlink" title="优化逻辑组织"></a>优化逻辑组织</h4><p>3x还提供了comonsition api</p><p>2x被称为options api</p><p>options api在组件小的时候一目了然，大的时候就很复杂，每当修改某一个关注点，就需要上下滑动变动多个位置</p><h4 id="优化逻辑复用"><a href="#优化逻辑复用" class="headerlink" title="优化逻辑复用"></a>优化逻辑复用</h4><p>v2采用mixins，可以定义props，data，容易导致定义相同名称变量，导致命名冲突</p><p>而且在使用时，对于不在当前组件定义的变量等事物，使用时数据来源不清器</p><p>v3采用hook方式</p><p>更好的类型支持</p><p>因为componsition具备更好的类型支持，因为都是函数，类型容易被推导，和v2不同，v2使用this不容易推导。</p><p>componsition api对tree-shaking更友好，代码压缩更容易</p><h4 id="引入RFC：使每个版本改动可控"><a href="#引入RFC：使每个版本改动可控" class="headerlink" title="引入RFC：使每个版本改动可控"></a>引入RFC：使每个版本改动可控</h4><p>v2部分采用REF(reqquest for comments) &#x2F;&#x2F;为新功能进入框架提供一个一致且受控的路径</p><p>v3大规模采用RFC，你可以了解每一个feature采用或者被废弃的前因后果</p><h4 id="小缺点："><a href="#小缺点：" class="headerlink" title="小缺点："></a>小缺点：</h4><p>vue3是采用es6的语法开发，有些api如proxy是没有polyfill的，这就意味着官方需要单独出一个ie11的compat版本来支持ie11</p><p>v2官方声明继续维护18个月，也就是说18个月以后，如果你的项目出了什么问题，那么就需要你自己阅读源码解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3做了什么样的优化？为什么需要这些优化？&quot;&gt;&lt;a href=&quot;#vue3做了什么样的优化？为什么需要这些优化？&quot; class=&quot;headerlink&quot; title=&quot;vue3做了什么样的优化？为什么需要这些优化？&quot;&gt;&lt;/a&gt;vue3做了什么样的优化？为什么需</summary>
      
    
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>看看WebGIS，极简单的智慧校园小demo</title>
    <link href="https://222cabbage.github.io/2022/09/23/webgis1/"/>
    <id>https://222cabbage.github.io/2022/09/23/webgis1/</id>
    <published>2022-09-22T18:30:26.000Z</published>
    <updated>2022-09-24T04:57:51.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近闲来无事，看看WebGIS"><a href="#最近闲来无事，看看WebGIS" class="headerlink" title="最近闲来无事，看看WebGIS"></a>最近闲来无事，看看WebGIS</h2><h3 id="什么是GIS？"><a href="#什么是GIS？" class="headerlink" title="什么是GIS？"></a>什么是GIS？</h3><p>GIS是一门综合型学科，结合了地理学与地图学以及遥感和计算机科学</p><h3 id="GIS开发方向"><a href="#GIS开发方向" class="headerlink" title="GIS开发方向"></a>GIS开发方向</h3><p>桌面端开发&#x2F;桌面GIS-C&#x2F;S架构，web开发&#x2F;webgis-BS架构，移动端开发&#x2F;移动gis-高德地图，美团外卖等</p><h3 id="WebGIS开发"><a href="#WebGIS开发" class="headerlink" title="WebGIS开发"></a>WebGIS开发</h3><p>前端可视化技术和GIS相结合</p><p>以canvas和webGL为代表的的前端可视化技术提供了很多效果和交互</p><p>处理二维GIS的openLayers，MapBox，leaflet</p><p>处理三维GIS的cesium</p><p>WebGIS和云计算，分布式机构结合，GIS云平台的出现 - 中地数码推出的GIS云平台</p><h4 id="为什么选择WebGIS"><a href="#为什么选择WebGIS" class="headerlink" title="为什么选择WebGIS"></a>为什么选择WebGIS</h4><p>相对于其他技术和编程语言，难度较低，上手快，成就感大</p><h3 id="基础平台"><a href="#基础平台" class="headerlink" title="基础平台"></a>基础平台</h3><p>MapGIS，ArcGIS，SuperMap  &#x2F;&#x2F;类似安卓和苹果</p><p>可以基于基础平台开发定制应用</p><p>有些应用方向也会提供自己的平台，比如地图导航应用，高德开放平台，百度开放平台</p><p>面向大众提供地图API接口服务</p><p>所有的开放平台都一样，都能解决WebGIS的核心问题</p><p>高德比较好配置，轻量</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="地图组成结构"><a href="#地图组成结构" class="headerlink" title="地图组成结构"></a>地图组成结构</h4><p><img src="https://s1.ax1x.com/2022/09/23/xktUYQ.png"></p><h4 id="地图容器"><a href="#地图容器" class="headerlink" title="地图容器"></a>地图容器</h4><p>创建指定的id容器，和echarts一样，需要一个容器承载所有图层，点标记，矢量图形，控件</p><h4 id="图层layer"><a href="#图层layer" class="headerlink" title="图层layer"></a>图层layer</h4><p>一个地图通常由一个或者多个图层组成</p><p>高德地图提供了很多标准图层和自定义图层</p><p>标准图层</p><p>卫星图层</p><p>路网图层</p><p>路况图层</p><h4 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h4><p>覆盖在图层上，通过矢量的方式，几何的方式，展示大小变化，但是其代表的实际路径和范围不变</p><p>除了折线，圆，多变性之外，JS的API还提供了矩形椭圆等常用矢量图形</p><h4 id="点标记"><a href="#点标记" class="headerlink" title="点标记"></a>点标记</h4><p>一个点要素，标记点</p><h4 id="地图控件"><a href="#地图控件" class="headerlink" title="地图控件"></a>地图控件</h4><p>悬浮在所有图层和地图要素上，满足一定交互和提示功能</p><p>放大缩小，调整方向</p><h4 id="地图级别ZoomLevel"><a href="#地图级别ZoomLevel" class="headerlink" title="地图级别ZoomLevel"></a>地图级别ZoomLevel</h4><p>级别与地图比例尺成正比，每增大一级，比例尺放大一倍，地图显示的越详细，最小级别通常为3级，高德地图目前最大级别为20级</p><h4 id="经纬度LngLat"><a href="#经纬度LngLat" class="headerlink" title="经纬度LngLat"></a>经纬度LngLat</h4><p>经纬度坐标</p><p>东西经180度，(-180-180)，西半球为负，东半球为正</p><p>南北纬(-85-85)，北半球为正，南半球为负</p><h4 id="底图BaseLayer"><a href="#底图BaseLayer" class="headerlink" title="底图BaseLayer"></a>底图BaseLayer</h4><p>位于所有图层和图形的最下方的图层，通常不透明，可以是单一图层，比如官方标准图层，也可以是图层组合，比如卫星图层和路网图层结合</p><h4 id="地图要素Map-Features"><a href="#地图要素Map-Features" class="headerlink" title="地图要素Map Features"></a>地图要素Map Features</h4><p>展示在地图上的地理要素，道路，区域面，建筑，POI标注，路名等，开发者自定义的点标记矢量图形也可以看做是地图要素</p><h4 id="标注Label"><a href="#标注Label" class="headerlink" title="标注Label"></a>标注Label</h4><p>地图上带有标示信息的文字或图标，POI标注，道路名称标注</p><h4 id="地图平面像素坐标Plane-Coordinates"><a href="#地图平面像素坐标Plane-Coordinates" class="headerlink" title="地图平面像素坐标Plane Coordinates"></a>地图平面像素坐标Plane Coordinates</h4><p>投影为平面之后的地图上的平面像素坐标……</p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>将地球球面的经纬度坐标映射到动图平面坐标的变换和映射关系，高德地图使用Web墨卡托投影，采用EPSG:3857坐标系统</p><h3 id="注册高德开放平台"><a href="#注册高德开放平台" class="headerlink" title="注册高德开放平台"></a>注册高德开放平台</h3><p>进入高德开放平台注册登录认证，在控制台点击应用管理新增一个应用</p><p>新增完后点击右上角添加key，选择web</p><p>添加成功后会出现key和安全密匙</p><p>后续可看开发支持中的开发文档</p><p>因为第一次接触，所以使用的是不带框架的用法，后面研究一下搭配vue或者react如何使用，应该要安装然全局配置<br>首先需要准备一个具备宽高的容器container</p><h3 id="GeoJSON"><a href="#GeoJSON" class="headerlink" title="GeoJSON"></a>GeoJSON</h3><p>一种保存地理信息数据的格式</p><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>在地图上绘制了多个标记点后，刷新页面标记点消失，是因为代表着标记点的变量是临时在内存中开辟出来的，刷新后就会消失</p><h4 id="持久化的方式"><a href="#持久化的方式" class="headerlink" title="持久化的方式"></a>持久化的方式</h4><p>1：使用GDB数据库，将数据保存在地理数据库中</p><p>2：使用GeoJSON，将数据保存在该格式的文件中</p><h3 id="智慧校园小demo"><a href="#智慧校园小demo" class="headerlink" title="智慧校园小demo"></a>智慧校园小demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;智慧校园demo&lt;/title&gt;</span><br><span class="line">    &lt;title&gt;点标记锚点&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        window._AMapSecurityConfig = &#123;</span><br><span class="line">            securityJsCode:&#x27;注册高德开发者后得到的安全密匙&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=2.0&amp;key=注册高德开发者后得到的key&quot;&gt;&lt;/script&gt; </span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;info&quot;&gt;点击地图标注热门地点&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let map = new AMap.Map(&#x27;container&#x27;,&#123;</span><br><span class="line">            center: [105.888,29.3915],</span><br><span class="line">            zoom:16.5,</span><br><span class="line">            viewMode:&#x27;3D&#x27;,</span><br><span class="line">            pitch:45</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //使用空间</span><br><span class="line">        AMap.plugin([</span><br><span class="line">            &#x27;AMap.ToolBar&#x27;,</span><br><span class="line">            &#x27;AMap.Scale&#x27;,</span><br><span class="line">            &#x27;AMap.HawkEye&#x27;,</span><br><span class="line">            &#x27;AMap.MapType&#x27;,</span><br><span class="line">            &#x27;AMap.Geolocation&#x27;,</span><br><span class="line">            &#x27;AMap.ControlBar&#x27;,</span><br><span class="line">            // &#x27;AMap.GeoJSON&#x27;</span><br><span class="line">        ], function()&#123;</span><br><span class="line">            // 在图面添加工具条控件，工具条控件集成了缩放、平移、定位等功能按钮在内的组合控件</span><br><span class="line">            map.addControl(new AMap.ToolBar());</span><br><span class="line">            // 在图面添加比例尺控件，展示地图在当前层级和纬度下的比例尺</span><br><span class="line">            map.addControl(new AMap.Scale());</span><br><span class="line">            // 在图面添加鹰眼控件，在地图右下角显示地图的缩略图</span><br><span class="line">            // map.addControl(new AMap.HawkEye(&#123;isOpen:true&#125;));</span><br><span class="line">            // 在图面添加类别切换控件，实现默认图层与卫星图、实施交通图层之间切换的控制</span><br><span class="line">            // map.addControl(new AMap.MapType());</span><br><span class="line">            // 在图面添加定位控件，用来获取和展示用户主机所在的经纬度位置</span><br><span class="line">            // map.addControl(new AMap.Geolocation());</span><br><span class="line">            map.addControl(new AMap.ControlBar());</span><br><span class="line">            // map.addControl(new AMap.GeoJSON())</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 定义一个全局对象保存json 持久化 有点小问题，按照官网来的报错</span><br><span class="line">        // let geojson = new AMap.GeoJSON(&#123;</span><br><span class="line">        //     geoJSON:null</span><br><span class="line">        // &#125;)</span><br><span class="line">        // // //导入数据 如果存在数据，n那么才导入数据，不存在数据什么都不做</span><br><span class="line">        // if(JSON.stringify(getStorageData) != &#x27;[]&#x27;)&#123;</span><br><span class="line">        //     geojson.importData(getStorageData())</span><br><span class="line">        // &#125;</span><br><span class="line">        // map.add(geojson)</span><br><span class="line">        </span><br><span class="line">        // console.log(geojson)</span><br><span class="line">        // 标记点 刷新页面会丢失</span><br><span class="line">         map.on(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">            // 获取点击地点信息 </span><br><span class="line">            var marker = new AMap.Marker(&#123;</span><br><span class="line">                position:e.lnglat,   // 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            //使用覆盖物的点击事件</span><br><span class="line">            marker.on(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">                console.log(e)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            map.add(marker);</span><br><span class="line">            // 通过geojson对象来管理覆盖物</span><br><span class="line">            // geojson.addOverlay(marker)</span><br><span class="line">            // setStorageData(geojson.toGeoJSON())</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结束也意味着新的开始……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最近闲来无事，看看WebGIS&quot;&gt;&lt;a href=&quot;#最近闲来无事，看看WebGIS&quot; class=&quot;headerlink&quot; title=&quot;最近闲来无事，看看WebGIS&quot;&gt;&lt;/a&gt;最近闲来无事，看看WebGIS&lt;/h2&gt;&lt;h3 id=&quot;什么是GIS？&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="WebGIS" scheme="https://222cabbage.github.io/categories/WebGIS/"/>
    
    
    <category term="WebGIS" scheme="https://222cabbage.github.io/tags/WebGIS/"/>
    
  </entry>
  
  <entry>
    <title>跟着官网过过微信小程序</title>
    <link href="https://222cabbage.github.io/2022/09/14/miniweixin/"/>
    <id>https://222cabbage.github.io/2022/09/14/miniweixin/</id>
    <published>2022-09-14T05:01:21.000Z</published>
    <updated>2022-09-14T06:24:09.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跟着官网过过微信小程序"><a href="#跟着官网过过微信小程序" class="headerlink" title="跟着官网过过微信小程序"></a>跟着官网过过微信小程序</h2><p>记录一些小的知识点</p><h3 id="场景值"><a href="#场景值" class="headerlink" title="场景值"></a>场景值</h3><p>记录用户进入小程序的路径，where进入</p><ul><li>对于小程序，可以在 <code>App</code> 的 <code>onLaunch</code> 和 <code>onShow</code>，或<a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 中获取上述场景值。</li><li>对于小游戏，可以在 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 和 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/(wx.onShow)">wx.onShow</a> 中获取上述场景值</li></ul><p>部分场景值：官网copy</p><table><thead><tr><th>场景值</th><th>场景</th><th>appId含义</th></tr></thead><tbody><tr><td>1020</td><td>公众号 profile 页相关小程序列表</td><td>来源公众号</td></tr><tr><td>1035</td><td>公众号自定义菜单</td><td>来源公众号</td></tr><tr><td>1036</td><td>App 分享消息卡片</td><td>来源App</td></tr><tr><td>1037</td><td>小程序打开小程序</td><td>来源小程序</td></tr><tr><td>1038</td><td>从另一个小程序返回</td><td>来源小程序</td></tr><tr><td>1043</td><td>公众号模板消息</td><td>来源公众号</td></tr></tbody></table><h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><table><thead><tr><th>路由方式</th><th>触发时机</th><th>路由前页面</th><th>路由后页面</th></tr></thead><tbody><tr><td>初始化</td><td>小程序打开的第一个页面</td><td></td><td>onLoad, onShow</td></tr><tr><td>打开新页面</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onHide</td><td>onLoad, onShow</td></tr><tr><td>页面重定向</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onUnload</td><td>onLoad, onShow</td></tr><tr><td>页面返回</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a>使用组件<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a>用户按左上角返回按钮</td><td>onUnload</td><td>onShow</td></tr><tr><td>Tab 切换</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a>用户切换 Tab</td><td></td><td>各种情况请参考下表</td></tr><tr><td>重启动</td><td>调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a>使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">&#96;&#96;</a></td><td>onUnload</td><td>onLoad, onShow</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li><li><code>switchTab</code> 只能打开 tabBar 页面。</li><li><code>reLaunch</code> 可以打开任意页面。</li><li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li><li>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</li></ul><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><p>大多数 API 都是异步 API，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">wx.request</a>，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login</a> 等。这类 API 接口通常都接受一个 <code>Object</code> 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：</p><p><strong>Object 参数说明</strong></p><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>success</td><td>function</td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）</td></tr><tr><td>其他</td><td>Any</td><td>-</td><td>接口定义的其他参数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    console.log(res.code)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">异步调用返回promise</span><br><span class="line">// callback 形式调用</span><br><span class="line">wx.chooseImage(&#123;</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// promise 形式调用</span><br><span class="line">wx.chooseImage().then(res =&gt; console.log(&#x27;res: &#x27;, res))</span><br></pre></td></tr></table></figure><h3 id="云开发API"><a href="#云开发API" class="headerlink" title="云开发API"></a>云开发API</h3><p>开通并使用<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信云开发</a>，即可使用云开发API，在小程序端直接调用服务端的<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#%E4%BA%91%E5%87%BD%E6%95%B0">云函数</a>。</p><p><strong>代码示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">  // 云函数名称</span><br><span class="line">  name: &#x27;cloudFunc&#x27;,</span><br><span class="line">  // 传给云函数的参数</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    console.log(res.result) // 示例</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: console.error</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 此外，云函数同样支持 promise 形式调用</span><br></pre></td></tr></table></figure><p>loading……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跟着官网过过微信小程序&quot;&gt;&lt;a href=&quot;#跟着官网过过微信小程序&quot; class=&quot;headerlink&quot; title=&quot;跟着官网过过微信小程序&quot;&gt;&lt;/a&gt;跟着官网过过微信小程序&lt;/h2&gt;&lt;p&gt;记录一些小的知识点&lt;/p&gt;
&lt;h3 id=&quot;场景值&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="微信小程序" scheme="https://222cabbage.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="https://222cabbage.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>实现一个vue-router</title>
    <link href="https://222cabbage.github.io/2022/09/06/vuerouterandvuex/"/>
    <id>https://222cabbage.github.io/2022/09/06/vuerouterandvuex/</id>
    <published>2022-09-06T08:15:58.000Z</published>
    <updated>2022-09-07T09:20:00.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现一个vue-router"><a href="#实现一个vue-router" class="headerlink" title="实现一个vue-router"></a>实现一个vue-router</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">myrouter.js</span><br><span class="line">import HashHistory from &quot;./hashHistory&quot;</span><br><span class="line">class VueRouter &#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line"></span><br><span class="line">        this.options = options</span><br><span class="line"></span><br><span class="line">        // 如果不传mode，默认为hash</span><br><span class="line">        this.mode = options.mode || &#x27;hash&#x27;</span><br><span class="line"></span><br><span class="line">        // 判断模式是哪种</span><br><span class="line">        switch (this.mode) &#123;</span><br><span class="line">            case &#x27;hash&#x27;:</span><br><span class="line">                this.history = new HashHistory(this)</span><br><span class="line">                break</span><br><span class="line">            case &#x27;history&#x27;:</span><br><span class="line">                // this.history = new HTML5History(this, options.base)</span><br><span class="line">                break</span><br><span class="line">            case &#x27;abstract&#x27;:</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(app) &#123;</span><br><span class="line">        this.history.listen((route) =&gt; app._route = route)</span><br><span class="line"></span><br><span class="line">        // 初始化时执行一次，保证刷新能渲染</span><br><span class="line">        this.history.transitionTo(window.location.hash.slice(1))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据hash变化获取对应的所有组件</span><br><span class="line">    createMathcer(location) &#123;</span><br><span class="line">        const &#123; pathMap &#125; = createRouteMap(this.options.routes)</span><br><span class="line"></span><br><span class="line">        const record = pathMap[location]</span><br><span class="line">        const local = &#123;</span><br><span class="line">            path: location</span><br><span class="line">        &#125;</span><br><span class="line">        if (record) &#123;</span><br><span class="line">            return createRoute(record, local)</span><br><span class="line">        &#125;</span><br><span class="line">        return createRoute(null, local)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let _Vue</span><br><span class="line">VueRouter.install = (Vue) =&gt; &#123;</span><br><span class="line">    _Vue = Vue</span><br><span class="line">    // 使用Vue.mixin混入每一个组件</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        // 在每一个组件的beforeCreate生命周期去执行</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            if (this.$options.router) &#123; // 如果是根组件</span><br><span class="line">                // this 是 根组件本身</span><br><span class="line">                this._routerRoot = this</span><br><span class="line"></span><br><span class="line">                // this.$options.router就是挂在根组件上的VueRouter实例</span><br><span class="line">                this.$router = this.$options.router</span><br><span class="line"></span><br><span class="line">                // 执行VueRouter实例上的init方法，初始化</span><br><span class="line">                this.$router.init(this)</span><br><span class="line"></span><br><span class="line">                // 相当于存在_routerRoot上，并且调用Vue的defineReactive方法进行响应式处理</span><br><span class="line">                Vue.util.defineReactive(this, &#x27;_route&#x27;, this.$router.history.current)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 非根组件，也要把父组件的_routerRoot保存到自身身上</span><br><span class="line">                this._routerRoot = this.$parent &amp;&amp; this.$parent._routerRoot</span><br><span class="line">                // 子组件也要挂上$router</span><br><span class="line">                this.$router = this._routerRoot.$router</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    Object.defineProperty(Vue.prototype, &#x27;$route&#x27;, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            return this._routerRoot._route</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRouteMap(routes) &#123;</span><br><span class="line"></span><br><span class="line">    const pathList = []</span><br><span class="line">    const pathMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 对传进来的routes数组进行遍历处理</span><br><span class="line">    routes.forEach(route =&gt; &#123;</span><br><span class="line">        addRouteRecord(route, pathList, pathMap)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    console.log(pathList)</span><br><span class="line">    // [&quot;/home&quot;, &quot;/home/child1&quot;, &quot;/home/child2&quot;, &quot;/hello&quot;, &quot;/hello/child1&quot;]</span><br><span class="line">    console.log(pathMap)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     /hello: &#123;path: xxx, component: xxx, parent: xxx &#125;,</span><br><span class="line">    //     /hello/child1: &#123;path: xxx, component: xxx, parent: xxx &#125;,</span><br><span class="line">    //     /hello/child2: &#123;path: xxx, component: xxx, parent: xxx &#125;,</span><br><span class="line">    //     /home: &#123;path: xxx, component: xxx, parent: xxx &#125;,</span><br><span class="line">    //     /home/child1: &#123;path: xxx, component: xxx, parent: xxx &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 将pathList与pathMap返回</span><br><span class="line">    return &#123;</span><br><span class="line">        pathList,</span><br><span class="line">        pathMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addRouteRecord(route, pathList, pathMap, parent) &#123;</span><br><span class="line">    // 拼接path</span><br><span class="line">    const path = parent ? `$&#123;parent.path&#125;/$&#123;route.path&#125;` : route.path</span><br><span class="line">    const &#123; component, children = null &#125; = route</span><br><span class="line">    const record = &#123;</span><br><span class="line">        path,</span><br><span class="line">        component,</span><br><span class="line">        parent</span><br><span class="line">    &#125;</span><br><span class="line">    if (!pathMap[path]) &#123;</span><br><span class="line">        pathList.push(path)</span><br><span class="line">        pathMap[path] = record</span><br><span class="line">    &#125;</span><br><span class="line">    if (children) &#123;</span><br><span class="line">        // 如果有children，则递归执行addRouteRecord</span><br><span class="line">        children.forEach(child =&gt; addRouteRecord(child, pathList, pathMap, record))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createRoute(record, location) &#123;</span><br><span class="line">    const res = []</span><br><span class="line">    if (record) &#123;</span><br><span class="line">        while (record) &#123;</span><br><span class="line">            res.unshift(record)</span><br><span class="line">            record = record.parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        ...location,</span><br><span class="line">        matched: res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default VueRouter</span><br><span class="line"></span><br><span class="line">hashHistory.js</span><br><span class="line">class HashHistory &#123;</span><br><span class="line">    constructor(router) &#123;</span><br><span class="line"></span><br><span class="line">        // 将传进来的VueRouter实例保存</span><br><span class="line">        this.router = router</span><br><span class="line"></span><br><span class="line">        // 一开始给current赋值初始值</span><br><span class="line">        this.current = createRoute(null, &#123;</span><br><span class="line">            path: &#x27;/&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 如果url没有 # ，自动填充 /#/ </span><br><span class="line">        ensureSlash()</span><br><span class="line"></span><br><span class="line">        // 监听hash变化</span><br><span class="line">        this.setupHashLister()</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听hash的变化</span><br><span class="line">    setupHashLister() &#123;</span><br><span class="line">        window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;</span><br><span class="line">            // 传入当前url的hash</span><br><span class="line">            this.transitionTo(window.location.hash.slice(1))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 跳转路由时触发的函数</span><br><span class="line">    transitionTo(location) &#123;</span><br><span class="line">        console.log(location)</span><br><span class="line">        </span><br><span class="line">        // 找出所有对应组件</span><br><span class="line">        let route = this.router.createMathcer(location)</span><br><span class="line"></span><br><span class="line">        console.log(route)</span><br><span class="line"></span><br><span class="line">        // hash更新时给current赋真实值</span><br><span class="line">        this.current = route</span><br><span class="line">        // 同时更新_route</span><br><span class="line">        this.cb &amp;&amp; this.cb(route)</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听回调</span><br><span class="line">    listen(cb) &#123;</span><br><span class="line">        this.cb = cb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果浏览器url上没有#，则自动补充/#/</span><br><span class="line">function ensureSlash() &#123;</span><br><span class="line">    if (window.location.hash) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    window.location.hash = &#x27;/&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createRoute(record, location) &#123;</span><br><span class="line">    const res = []</span><br><span class="line">    if (record) &#123;</span><br><span class="line">        while (record) &#123;</span><br><span class="line">            res.unshift(record)</span><br><span class="line">            record = record.parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        ...location,</span><br><span class="line">        matched: res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HashHistory</span><br><span class="line"></span><br><span class="line">router-view组件</span><br><span class="line">const myView = &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    render(h, &#123; parent, data &#125;) &#123;</span><br><span class="line">        const &#123; matched &#125; = parent.$route</span><br><span class="line"></span><br><span class="line">        data.routerView = true // 标识此组件为router-view</span><br><span class="line">        let depth = 0 // 深度索引</span><br><span class="line"></span><br><span class="line">        while(parent) &#123;</span><br><span class="line">            // 如果有父组件且父组件为router-view 说明索引需要加1</span><br><span class="line">            if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">                depth++</span><br><span class="line">            &#125;</span><br><span class="line">            parent = parent.$parent</span><br><span class="line">        &#125;</span><br><span class="line">        const record = matched[depth]</span><br><span class="line"></span><br><span class="line">        if (!record) &#123;</span><br><span class="line">            return h()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const component = record.component</span><br><span class="line"></span><br><span class="line">        // 使用render的h函数进行渲染组件</span><br><span class="line">        return h(component, data)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default myView</span><br><span class="line"></span><br><span class="line">router-link组件</span><br><span class="line">const myLink = &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        to: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            required: true,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 渲染</span><br><span class="line">    render(h) &#123;</span><br><span class="line"></span><br><span class="line">        // 使用render的h函数渲染</span><br><span class="line">        return h(</span><br><span class="line">            // 标签名</span><br><span class="line">            &#x27;a&#x27;,</span><br><span class="line">            // 标签属性</span><br><span class="line">            &#123;</span><br><span class="line">                domProps: &#123;</span><br><span class="line">                    href: &#x27;#&#x27; + this.to,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            // 插槽内容</span><br><span class="line">            [this.$slots.default]</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default myLink</span><br><span class="line"></span><br><span class="line">//学习自掘金林三心老师的代码</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现一个vue-router&quot;&gt;&lt;a href=&quot;#实现一个vue-router&quot; class=&quot;headerlink&quot; title=&quot;实现一个vue-router&quot;&gt;&lt;/a&gt;实现一个vue-router&lt;/h3&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="vue" scheme="https://222cabbage.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://222cabbage.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>手写一个简单的promise</title>
    <link href="https://222cabbage.github.io/2022/09/06/promise1/"/>
    <id>https://222cabbage.github.io/2022/09/06/promise1/</id>
    <published>2022-09-06T08:09:46.000Z</published>
    <updated>2022-09-07T03:03:04.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写一个简单的promise"><a href="#手写一个简单的promise" class="headerlink" title="手写一个简单的promise"></a>手写一个简单的promise</h2><h3 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h3><p>promise是js异步编程的解决方案，比传统的回调函数的方式更合理和强大，完美解决回调地狱，使的异步操作更加容易</p><h3 id="Promises-x2F-A-规范"><a href="#Promises-x2F-A-规范" class="headerlink" title="Promises&#x2F;A+规范"></a>Promises&#x2F;A+规范</h3><p>想要编写一个完整的，规范的promise就要哦根据promises&#x2F;A+规范编写</p><p><a href="https://promisesaplus.com/%E8%8B%B1%E6%96%87%E5%9C%B0%E5%9D%80">https://promisesaplus.com/英文地址</a></p><p><a href="https://blog.csdn.net/qq_41800366/article/details/120788569?spm=1001.2014.3001.5501%E4%B8%AD%E6%96%87%E5%9C%B0%E5%9D%80">https://blog.csdn.net/qq_41800366/article/details/120788569?spm=1001.2014.3001.5501中文地址</a></p><h3 id="最简单的promise使用"><a href="#最简单的promise使用" class="headerlink" title="最简单的promise使用"></a>最简单的promise使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let  p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    settimeOut(()=&gt;&#123;</span><br><span class="line">        if(true)&#123;</span><br><span class="line">            resolve(&#x27;true&#x27;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            reject(&#x27;false&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">    console.log(value) // true</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err) // false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="写一个promise基本结构"><a href="#写一个promise基本结构" class="headerlink" title="写一个promise基本结构"></a>写一个promise基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">promise是一个构造函数</span><br><span class="line">new Promise传入一个函数立即执行</span><br><span class="line">执行函数有resolve和reject两个参数</span><br><span class="line">有一个then方法，接收两个参数</span><br><span class="line">class Promise &#123;</span><br><span class="line">    contructor(exector)&#123;</span><br><span class="line">    const resolve = value =&gt; &#123;</span><br><span class="line">            console.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const reject = reason =&gt; &#123;</span><br><span class="line">            console.log(reason)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        try&#123;</span><br><span class="line">exector(resolve,reject)</span><br><span class="line"> &#125; catch(err) &#123;</span><br><span class="line">            throw err</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(arg1,arg2)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h3><p>pending，fullfilled：解决&#x2F;resolved，rejected</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">三个状态</span><br><span class="line">调用resolve和reject时状态要从pending变为fullfilled或者rejected</span><br><span class="line">const PENDING = &#x27;pending&#x27;</span><br><span class="line">const FULLFILLED = &#x27;fullfilled&#x27;</span><br><span class="line">const REJECT = &#x27;rejected&#x27;</span><br><span class="line">class Promise &#123;</span><br><span class="line">    contructor(exector)&#123;</span><br><span class="line">    this.state = PENDING //初始pending状态</span><br><span class="line">    this.value = undefined</span><br><span class="line">    this.reason = undefined</span><br><span class="line">    this.obFullFillCallBack = undefined //保存promise内部执行的函数</span><br><span class="line">    this.onRejectedCallBack = undefined //保存执行的函数</span><br><span class="line">    const resolve = value =&gt; &#123;</span><br><span class="line">    if(this.state = PENDING)&#123;</span><br><span class="line">            this.state = FULLFILLED</span><br><span class="line">            this.value = value</span><br><span class="line">            this.onFUllFillCallBack &amp;&amp; this.onFUllFillCallBack()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const reject = reason =&gt; &#123;</span><br><span class="line">    if(this.state = PENDING)&#123;</span><br><span class="line">            this.state = REJECT</span><br><span class="line">            this.reason = reason</span><br><span class="line">            this.onRejectedCallBack() &amp;&amp; this.onRejectedCallBack()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        try&#123;</span><br><span class="line">exector(resolve,reject)</span><br><span class="line"> &#125; catch(err) &#123;</span><br><span class="line">            throw err</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFullfilled,onRejected //都是可选参数，如果不是函数直接忽略)&#123;</span><br><span class="line">        // typeof onFullfilled === &#x27;function&#x27; &amp;&amp; onFullfilled()</span><br><span class="line">        // typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected()</span><br><span class="line">        if(this.state === FULLFILLED)&#123;</span><br><span class="line">typeof onFullfilled === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123;</span><br><span class="line">                onFullfilled(this.value)</span><br><span class="line">&#125;,0)</span><br><span class="line">&#125;else if(this.state === REJECTED)&#123;</span><br><span class="line">             typeof onRejected === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123;</span><br><span class="line">               onRejected(this.reason)  </span><br><span class="line">             &#125;,0) </span><br><span class="line">&#125; else &#123;</span><br><span class="line">typeof onFullfilled === &#x27;function&#x27; &amp;&amp; (this.onFUllFillCallBack =  value =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                   onFullfilled(value) </span><br><span class="line">                &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line">type onRejected === &#x27;function&#x27; &amp;&amp; (this.onRejectedCallBack =  reason =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                   onRejected(reason) </span><br><span class="line">                &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="再修改一下-x2F-x2F-最基础版Promise实现"><a href="#再修改一下-x2F-x2F-最基础版Promise实现" class="headerlink" title="再修改一下 &#x2F;&#x2F;最基础版Promise实现"></a>再修改一下 &#x2F;&#x2F;最基础版Promise实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &#x27;pending&#x27;</span><br><span class="line">const FULLFILLED = &#x27;fullfilled&#x27;</span><br><span class="line">const REJECT = &#x27;rejected&#x27;</span><br><span class="line">class Promise &#123;</span><br><span class="line">    contructor(exector)&#123;</span><br><span class="line">    this.state = PENDING //初始pending状态</span><br><span class="line">    this.value = undefined</span><br><span class="line">    this.reason = undefined</span><br><span class="line">    this.obFullFillCallBacks = [] //保存promise内部执行的函数</span><br><span class="line">    this.onRejectedCallBacks = [] //保存执行的函数</span><br><span class="line">    const resolve = value =&gt; &#123;</span><br><span class="line">    if(this.state = PENDING)&#123;</span><br><span class="line">            this.state = FULLFILLED</span><br><span class="line">            this.value = value</span><br><span class="line">            this.onFUllFillCallBacks &amp;&amp; this.onFUllFillCallBacks.forEach(fn =&gt; fn(value))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const reject = reason =&gt; &#123;</span><br><span class="line">    if(this.state = PENDING)&#123;</span><br><span class="line">            this.state = REJECT</span><br><span class="line">            this.reason = reason</span><br><span class="line">            this.onRejectedCallBacks &amp;&amp; this.onRejectedCallBacks.forEach(fn =&gt; fn(reason))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        try&#123;</span><br><span class="line">exector(resolve,reject)</span><br><span class="line"> &#125; catch(err) &#123;</span><br><span class="line">            throw err</span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFullfilled,onRejected //都是可选参数，如果不是函数直接忽略)&#123;</span><br><span class="line">        // typeof onFullfilled === &#x27;function&#x27; &amp;&amp; onFullfilled()</span><br><span class="line">        // typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected()</span><br><span class="line">        if(this.state === FULLFILLED)&#123;</span><br><span class="line">typeof onFullfilled === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123;</span><br><span class="line">                onFullfilled(this.value)</span><br><span class="line">&#125;,0)</span><br><span class="line">&#125;else if(this.state === REJECTED)&#123;</span><br><span class="line">             typeof onRejected === &#x27;function&#x27; &amp;&amp; setTimeout(()=&gt;&#123;</span><br><span class="line">               onRejected(this.reason)  </span><br><span class="line">             &#125;,0) </span><br><span class="line">&#125; else &#123;</span><br><span class="line">typeof onFullfilled === &#x27;function&#x27; &amp;&amp; (this.onFUllFillCallBack.push(value =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                   onFullfilled(value) </span><br><span class="line">                &#125;,0)</span><br><span class="line">&#125;))</span><br><span class="line">type onRejected === &#x27;function&#x27; &amp;&amp; (this.onRejectedCallBack.push(reason =&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                   onRejected(reason) </span><br><span class="line">                &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="完整版promise实现"><a href="#完整版promise实现" class="headerlink" title="完整版promise实现"></a>完整版promise实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &#x27;pending&#x27;;</span><br><span class="line">const FULFILLED = &#x27;fulfilled&#x27;;</span><br><span class="line">const REJECTED = &#x27;rejected&#x27;;</span><br><span class="line"></span><br><span class="line">function resolvePromise(promise, x, resolve, reject) &#123;</span><br><span class="line">  if (promise === x) &#123;</span><br><span class="line">    reject(new TypeError(&#x27;Chaining cycle detected for promise&#x27;));</span><br><span class="line">  &#125; else if (typeof x === &#x27;function&#x27; || (typeof x === &#x27;object&#x27; &amp;&amp; x !== null)) &#123;</span><br><span class="line">    let called = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      const then = x.then;</span><br><span class="line">      if (typeof then === &#x27;function&#x27;) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          if (called) return;</span><br><span class="line">          called = true;</span><br><span class="line">          resolvePromise(promise, y, resolve, reject);</span><br><span class="line">        &#125;, r =&gt; &#123;</span><br><span class="line">          if (called) return;</span><br><span class="line">          called = true;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      if (called) return;</span><br><span class="line">      called = true;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">class FullPromisePerfect &#123;</span><br><span class="line">  state = PENDING;</span><br><span class="line">  value = undefined;</span><br><span class="line">  reason = undefined;</span><br><span class="line">  onFulfilledCallback = [];</span><br><span class="line">  onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    const resolve = value =&gt; &#123;</span><br><span class="line">      if (this.state === PENDING) &#123;</span><br><span class="line">        this.state = FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onFulfilledCallback.forEach(onFulfilled =&gt; onFulfilled(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const reject = reason =&gt; &#123;</span><br><span class="line">      if (this.state === PENDING) &#123;</span><br><span class="line">        this.state = REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallback.forEach(onRejected =&gt; onRejected(reason)); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      reject(error); </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    const onFulfilledNow = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value;</span><br><span class="line">    const onRejectedNow = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125;;</span><br><span class="line">    const promise2 = new FullPromisePerfect((resolve, reject) =&gt; &#123;</span><br><span class="line">      const handleResolve = value =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          const x = onFulfilledNow(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      const handleReject = reason =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          const x = onRejectedNow(reason);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (this.state === FULFILLED) &#123;</span><br><span class="line">        setTimeout(() =&gt; handleResolve(this.value), 0);</span><br><span class="line">      &#125; else if (this.state === REJECTED) &#123;</span><br><span class="line">        setTimeout(() =&gt; handleReject(this.reason), 0);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.onFulfilledCallback.push(value =&gt; setTimeout(() =&gt; handleResolve(value), 0));</span><br><span class="line">        this.onRejectedCallback.push(reason =&gt; setTimeout(() =&gt; handleReject(reason), 0));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise2;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = FullPromisePerfect;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>想要测试写的代码，可以使用npm i promises-aplus-tests -D</p><p>随后编写测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yarn add promises-aplus-tests -D</span><br><span class="line">在 package.json 中添加脚本</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;test&quot;: &quot;promises-aplus-tests 填写测试文件地址&quot;  // 如 ./src/testFullPromise.js</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">首先在 FullPromise.js 中导出 FullPromise</span><br><span class="line"></span><br><span class="line">module.exports = FullPromise;</span><br><span class="line">然后编写测试文件</span><br><span class="line"></span><br><span class="line">const FullPromise = require(&#x27;../FullPromise&#x27;);// 导入 FullPromise</span><br><span class="line">// 参照 promises-tests 仓库提供的方法</span><br><span class="line">FullPromise.defer = FullPromise.deferred = function()&#123;</span><br><span class="line">  let dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = new FullPromise((resolve, reject)=&gt;&#123;</span><br><span class="line">      dfd.resolve = resolve;</span><br><span class="line">      dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  return dfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports =  FullPromise;  // 最后导出即可</span><br><span class="line">运行命令即可开始测试</span><br><span class="line"></span><br><span class="line">yarn test</span><br></pre></td></tr></table></figure><p>ending</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;手写一个简单的promise&quot;&gt;&lt;a href=&quot;#手写一个简单的promise&quot; class=&quot;headerlink&quot; title=&quot;手写一个简单的promise&quot;&gt;&lt;/a&gt;手写一个简单的promise&lt;/h2&gt;&lt;h3 id=&quot;promise是什么？&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="promise" scheme="https://222cabbage.github.io/categories/promise/"/>
    
    
    <category term="promise" scheme="https://222cabbage.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法再see</title>
    <link href="https://222cabbage.github.io/2022/09/01/algorithm2/"/>
    <id>https://222cabbage.github.io/2022/09/01/algorithm2/</id>
    <published>2022-09-01T06:19:48.000Z</published>
    <updated>2022-10-12T15:54:47.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="之前草草过了一遍数据结构，这次再来复习一下"><a href="#之前草草过了一遍数据结构，这次再来复习一下" class="headerlink" title="之前草草过了一遍数据结构，这次再来复习一下"></a>之前草草过了一遍数据结构，这次再来复习一下</h2><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>执行当前算法所花费的时间</p><p>大O表示法</p><p>O(1) O(n) O(n2) O(llogn) ……</p><p>O(1)，花费时间不受某个变量变化影响，除了循环递归意外，基本都是O1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line"></span><br><span class="line">const b = 2</span><br><span class="line"></span><br><span class="line">function fn(num)&#123;</span><br><span class="line"></span><br><span class="line">return num</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(6)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>O(n) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n平方)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">    for()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(logN)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">const n = 6</span><br><span class="line">while(i &lt; n)&#123;</span><br><span class="line">    i = i * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><p>执行当前算法需要多少内存空间</p><p>大O表示法</p><p>O(1) O(n) O(n2) 。。。。。。</p><p>O(1) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br></pre></td></tr></table></figure><p>O(n) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">for(let i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n2平方)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">for(let i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">    for(let j = 0;j &lt; 100; j++)&#123;</span><br><span class="line">        arr[j].push(j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">后进先出</span><br><span class="line">向后面添加元素，从后向前删除元素</span><br><span class="line">上下电梯，最后一个进去，第一个出来</span><br><span class="line">入栈出栈，栈底栈顶</span><br></pre></td></tr></table></figure><h4 id="栈-leetcode有效括号"><a href="#栈-leetcode有效括号" class="headerlink" title="栈-leetcode有效括号"></a>栈-leetcode有效括号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function fn(s)&#123;</span><br><span class="line">let arr = []</span><br><span class="line">for(let i = 0; i &lt; s.length; i++)&#123;</span><br><span class="line">const start = s[i]</span><br><span class="line">if(s[i] === &#x27;(&#x27; || s[i] === &#x27;&#123;&#x27; || s[i] === &#x27;[&#x27;)&#123;</span><br><span class="line">arr.push(s[i])</span><br><span class="line">&#125;else&#123;</span><br><span class="line">            const end = arr[arr.length - 1]</span><br><span class="line">            if(start ==  &#x27;)&#x27; &amp;&amp; end == &#x27;(&#x27;</span><br><span class="line">               start ==  &#x27;]&#x27; &amp;&amp; end == &#x27;[&#x27;</span><br><span class="line">               start ==  &#x27;&#125;&#x27; &amp;&amp; end == &#x27;&#123;&#x27;</span><br><span class="line">            )&#123;</span><br><span class="line">                arr.pop()</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr.length == 0</span><br><span class="line">&#125;</span><br><span class="line">fn(str)</span><br></pre></td></tr></table></figure><h4 id="栈-leetcode删除字符串中所有相邻重复项"><a href="#栈-leetcode删除字符串中所有相邻重复项" class="headerlink" title="栈-leetcode删除字符串中所有相邻重复项"></a>栈-leetcode删除字符串中所有相邻重复项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">fn(str)</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>先进先出</p><h4 id="leetcode-933最近请求次数"><a href="#leetcode-933最近请求次数" class="headerlink" title="leetcode 933最近请求次数"></a>leetcode 933最近请求次数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class RecentCounter &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>js是一门单线程的浏览器脚本语言，因此诞生出了异步，同步任务会被推入堆或者执行栈，异步任务被推入异步任务队列，在执行栈中的任务完成后，会将异步队列中的任务依次推入执行栈执行，这就是事件循环</p><p>在异步任务中也分为宏任务和微任务，主线程查询任务队列，执行微任务，执行完微任务后，主线程查询任务队列，执行第一个宏任务，执行完毕后再查找所有微任务，再查找第一个宏任务</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>多个元素组成的链表，不是按照顺序存储，而是按照next指针联系在一起的</p><p>js的原型链和链表结构相同</p><p>数组和链表区别</p><p>1：数组有序存储，删除或添加某个元素，其他元素会重新计算</p><p>2：链表不是按照顺序存储，没有下标，删除和添加元素不会影响其他元素</p><p>3：查找时，数组根据下标，链表只能从头或者从后找起</p><p>链表分为单向链表，双向链表，环形链表，，，，，，</p><h4 id="instanceof原理"><a href="#instanceof原理" class="headerlink" title="instanceof原理"></a>instanceof原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">console.log(arr instanceof Array) //true</span><br><span class="line">console.log(arr instanceof Object) //true</span><br><span class="line"></span><br><span class="line"> const instanceof = (target,obj) =&gt; &#123;</span><br><span class="line">     let p = target</span><br><span class="line">     while(p)&#123;</span><br><span class="line">         if(p == obj.prototype)&#123;</span><br><span class="line">             return true</span><br><span class="line">         &#125;</span><br><span class="line">         p = p.__proto__</span><br><span class="line">     &#125;</span><br><span class="line">     return false</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> console.log(instanceof([1,2,3],Array))</span><br></pre></td></tr></table></figure><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><h4 id="leetcode-141环形链表"><a href="#leetcode-141环形链表" class="headerlink" title="leetcode-141环形链表"></a>leetcode-141环形链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function hasCycle = function(head)&#123;</span><br><span class="line">    let f = head</span><br><span class="line">    let s = head</span><br><span class="line">    while( f! = null &amp;&amp; f.next != null)&#123;</span><br><span class="line">        s = s.next</span><br><span class="line">        f = f.next.next</span><br><span class="line">        if( s = f ) return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-237删除链表中的节点"><a href="#leetcode-237删除链表中的节点" class="headerlink" title="leetcode-237删除链表中的节点"></a>leetcode-237删除链表中的节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无法访问head，只能访问要删除的node，要删除的node不是末尾节点</span><br><span class="line">function deleteEle(node)&#123;</span><br><span class="line">    node.val = node.next.val</span><br><span class="line">    node.next = node.next.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-83删除排序链表中的重复元素"><a href="#leetcode-83删除排序链表中的重复元素" class="headerlink" title="leetcode-83删除排序链表中的重复元素"></a>leetcode-83删除排序链表中的重复元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给一个head，升序序列，删除所有重塑元，使每个元素只出现一次</span><br><span class="line">function deleteEle(head)&#123;</span><br><span class="line">//我写的</span><br><span class="line">let p = head</span><br><span class="line">while( p.val = p.next.val )&#123;</span><br><span class="line">            p.next.val = p.next.next.val</span><br><span class="line">            p.next.next = p.next.next.next</span><br><span class="line">&#125;</span><br><span class="line">//视频写的</span><br><span class="line">if(!head)&#123;</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line">let cur = head</span><br><span class="line">while(cur.next)&#123;</span><br><span class="line">if(cur.val = cur.next.val)&#123;</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">&#125;else&#123;</span><br><span class="line">                cur = cur.next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-206反转链表"><a href="#leetcode-206反转链表" class="headerlink" title="leetcode-206反转链表"></a>leetcode-206反转链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function reserve(head)&#123;</span><br><span class="line">let prev = null</span><br><span class="line">let curr = head</span><br><span class="line">while(curr)&#123;</span><br><span class="line">                const next = curr.next</span><br><span class="line">                curr.next = prev</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = next</span><br><span class="line">&#125;</span><br><span class="line">return prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典和哈希表"><a href="#字典和哈希表" class="headerlink" title="字典和哈希表"></a>字典和哈希表</h3><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>键值对的存储，类似js对象，js对象的键在某些情况会转换成对象类型，字典类型键不会转换类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line">map.set(&#x27;key&#x27;,123)</span><br><span class="line">map.get(&#x27;key&#x27;)</span><br><span class="line">map.has(&#x27;key&#x27;)</span><br><span class="line">map.delete(&#x27;key&#x27;)</span><br><span class="line">map.clear()</span><br><span class="line">console.log(map.size) //length</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>和字典相比，省去了按照插入顺序排列的查找</p><p>又称为散列表</p><p>基于数组，可以通过下标hash值访问元素</p><p>js没有哈希表，哈希表是字典的一种实现</p><p>字典是根据添加顺序排列的，哈希表不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">实现哈希表</span><br><span class="line">class Hash &#123;</span><br><span class="line">    constructor&#123;</span><br><span class="line">        this.table = []</span><br><span class="line">    &#125;</span><br><span class="line">    hashCode(key)&#123;</span><br><span class="line">    let hash = 0 </span><br><span class="line">        for(let i = 0; i &lt; key.length; i++)&#123;</span><br><span class="line">            hash += key.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line">        return hash</span><br><span class="line">    &#125;</span><br><span class="line">    put(key,value)&#123;</span><br><span class="line">        let hashKey = this.hashCode(key)</span><br><span class="line">        this.table[hashKey] = value</span><br><span class="line">    &#125;</span><br><span class="line">    get(key)&#123;</span><br><span class="line">    let hashKey = this.hashCode(key)</span><br><span class="line">        return this.table[hashKey]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hash = new Hash()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="leetcode哈希表1两数之和"><a href="#leetcode哈希表1两数之和" class="headerlink" title="leetcode哈希表1两数之和"></a>leetcode哈希表1两数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，给定一个目标值，求数组中和为目标值的两个整数，返回下标</span><br><span class="line">function computed(nums, target)&#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">                num = target - nums[i]</span><br><span class="line">                if(map.has(num))&#123;</span><br><span class="line">                    return [map.get(num),i]</span><br><span class="line">                &#125;</span><br><span class="line">                map.set(nums[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode哈希表存在重复元素"><a href="#leetcode哈希表存在重复元素" class="headerlink" title="leetcode哈希表存在重复元素"></a>leetcode哈希表存在重复元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，判断是否存在重复元素</span><br><span class="line">如果一个值在该数组中至少出现两次，函数返回true，如果数组中每个元素都不相同，返回false</span><br><span class="line">function same(nums)&#123;</span><br><span class="line">let map = new Map()</span><br><span class="line">    for(let i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(map.has(nums[i]))&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode哈希表349两个数组交集"><a href="#leetcode哈希表349两个数组交集" class="headerlink" title="leetcode哈希表349两个数组交集"></a>leetcode哈希表349两个数组交集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组，编写函数计算交集</span><br><span class="line">function com(nums1,nums2)&#123;</span><br><span class="line">   let set = new Set(nums)</span><br><span class="line">   return [...new Set(nums1)].filter(val =&gt; set.has(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断一个字符串中出现最多的字符并统计次数"><a href="#判断一个字符串中出现最多的字符并统计次数" class="headerlink" title="判断一个字符串中出现最多的字符并统计次数"></a>判断一个字符串中出现最多的字符并统计次数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function num(str)&#123;</span><br><span class="line">let maxNum = 0</span><br><span class="line">let maxStr = &#x27;&#x27;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for(let item of str)&#123;</span><br><span class="line">        map.set(item, (map.get(item) || 0) + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    for(let [key,value] of map)&#123;</span><br><span class="line">        if(value &gt; maxNum)&#123;</span><br><span class="line">            maxNum = value</span><br><span class="line">            maxStr = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [maxStr,maxNum]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode哈希表1207独一无二的出现次数"><a href="#leetcode哈希表1207独一无二的出现次数" class="headerlink" title="leetcode哈希表1207独一无二的出现次数"></a>leetcode哈希表1207独一无二的出现次数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给予一个都是整数项的数组，统计每个项出现的次数，如果每个数出现的次数都是独一无二的，返回true，否则返回false</span><br><span class="line">function U(arr)&#123;</span><br><span class="line">    const map = new Map()</span><br><span class="line">    for(let item of arr)&#123;</span><br><span class="line">            if(map.has(item))&#123;</span><br><span class="line">                map.set(item,map.get(item) + 1)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.set(item,1)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const set = new Set()</span><br><span class="line">    for(let [key,value] of map)&#123;</span><br><span class="line">            set.add(value)</span><br><span class="line">    &#125;</span><br><span class="line">    return set.size == map.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-03无重复字符的最长子串"><a href="#leetcode-03无重复字符的最长子串" class="headerlink" title="leetcode 03无重复字符的最长子串"></a>leetcode 03无重复字符的最长子串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串s，找出其中不含重复字符的最长子串的长度</span><br><span class="line">如果是aassdd</span><br><span class="line">去重后卫asd，最长子串为3</span><br><span class="line">function Max(s)&#123;</span><br><span class="line">自己想的两种方式，但是不知道为什么无法通过测试用例，我自己在浏览器调试的时候是可以的</span><br><span class="line">// 后续搞明白了，没注意看题目，是最长子串，不是最长序列，题目我也没整明白，整成了去重后的长度，放这里记录一下错误</span><br><span class="line">1</span><br><span class="line">// let map = new Map()</span><br><span class="line">    // let arr = s.split(&#x27;&#x27;)</span><br><span class="line">    // for(let i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    // if(map.has(arr[i]))&#123;</span><br><span class="line">    // continue</span><br><span class="line">    // &#125;else&#123;</span><br><span class="line">    // map.set(arr[i],(map.get(arr[i]) || 0) + 1)</span><br><span class="line">    // &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return map.size</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">    // let set = new Set()</span><br><span class="line">    // for(let i = 0; i &lt; s.length; i++)&#123;</span><br><span class="line">    // set.add(s[i])</span><br><span class="line">    // &#125;</span><br><span class="line">    // return set.size</span><br><span class="line">    </span><br><span class="line">    涉及到了滑动窗口的概念</span><br><span class="line">    let map = new Map()</span><br><span class="line">    let l = 0</span><br><span class="line">    let num = 0</span><br><span class="line">    for(let i = 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        if(map.has(s[i]) &amp;&amp; map.get(s[i]) &gt;= l)&#123;</span><br><span class="line">            l = map.get(s[i]) + 1</span><br><span class="line">        &#125;</span><br><span class="line">        num = Math.max(num,i - l + 1)</span><br><span class="line">        map.set(s[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">    return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>分层数据关系</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>从根节点出发，尽可能深的搜索树的节点，往一个节点深处遍历，遍历完后再遍历下一个节点一直遍历</p><p>技巧</p><p>1：访问根节点</p><p>2：对根节点children挨个进行深度优先遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const tree = &#123;</span><br><span class="line">    val:&#x27;a&#x27;,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        val:&#x27;b&#x27;,</span><br><span class="line">        children:[&#123;</span><br><span class="line">            val:&#x27;d&#x27;,</span><br><span class="line">            children:[&#123;</span><br><span class="line">                val:&#x27;e&#x27;,</span><br><span class="line">                children:[]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        val:&#x27;c&#x27;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fn = (root) =&gt; &#123;</span><br><span class="line">    //if(root.children)&#123;</span><br><span class="line">    console.log(root.val)</span><br><span class="line">        root.children.forEach(fn)</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn(tree)</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>优先查找离根节点最近的节点，再查找最近的节点的子节点</p><p>技巧：</p><p>1：新建一个队列，吧根节点入队列</p><p>2：吧队头出队</p><p>3：吧对头的children挨个入队</p><p>4：重复2,3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn = (root) =&gt; &#123;</span><br><span class="line">    const arr = [root]</span><br><span class="line">    while(arr.length &gt; 0)&#123;</span><br><span class="line">        const obj = arr.shift()</span><br><span class="line">        console.log(obj.val)</span><br><span class="line">        obj.forEach(item =&gt; &#123;</span><br><span class="line">            arr.push(item)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h4><h4 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h4><p>dom结构</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>子节点只会有两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const tree = &#123;</span><br><span class="line">    val:&#x27;a&#x27;,</span><br><span class="line">    left:[&#123;</span><br><span class="line">        val:&#x27;b&#x27;,</span><br><span class="line">        left:[],</span><br><span class="line">        right:[]</span><br><span class="line">    &#125;],</span><br><span class="line">    right:[&#123;</span><br><span class="line">        val:&#x27;c&#x27;,</span><br><span class="line">        left:[&#123;</span><br><span class="line">            val:&#x27;d&#x27;;</span><br><span class="line">            left:[],</span><br><span class="line">           right:[]</span><br><span class="line">        &#125;],</span><br><span class="line">        right:[]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetocde144二叉树前序遍历前序遍历-x2F-先序遍历"><a href="#leetocde144二叉树前序遍历前序遍历-x2F-先序遍历" class="headerlink" title="leetocde144二叉树前序遍历前序遍历&#x2F;先序遍历"></a>leetocde144二叉树前序遍历前序遍历&#x2F;先序遍历</h4><p>根，左，右</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function tree(root)&#123;</span><br><span class="line">1:递归版</span><br><span class="line">    let arr = []</span><br><span class="line">    let fn = (node) =&gt; &#123;</span><br><span class="line">        if(node)&#123;</span><br><span class="line">        //先根节点</span><br><span class="line">            arr.push(node.value)</span><br><span class="line">            //遍历左子树</span><br><span class="line">            fn(node.left)</span><br><span class="line">            //遍历右子树</span><br><span class="line">            fn(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(root)</span><br><span class="line">    return arr //[1,2,3,4,5]</span><br><span class="line">    </span><br><span class="line">    //2:通过栈的形式，非递归版</span><br><span class="line">    if(!root)return []</span><br><span class="line">    let arr = []</span><br><span class="line">    let stack = [root]</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">let o = stack.pop()</span><br><span class="line">arr.push(o.val)</span><br><span class="line">p.right &amp;&amp; stack.push(o.right)</span><br><span class="line">p.left &amp;&amp; stack.push(o.left)</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode94二叉树中序遍历"><a href="#leetcode94二叉树中序遍历" class="headerlink" title="leetcode94二叉树中序遍历"></a>leetcode94二叉树中序遍历</h4><p>左，根，右</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function fnn(root)&#123;</span><br><span class="line">    1：递归版</span><br><span class="line">    const arr = []</span><br><span class="line">    const fn = ( root ) =&gt; &#123;</span><br><span class="line">        if(!root)return</span><br><span class="line">        fn(root.left);</span><br><span class="line">        arr.push(root.val)</span><br><span class="line">        fn(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    fn(root)</span><br><span class="line">    return arr</span><br><span class="line">    </span><br><span class="line">    2：非递归版</span><br><span class="line">    const arr = []</span><br><span class="line">    const stack = []</span><br><span class="line">    let o = root</span><br><span class="line">    while(stack.length || o)&#123;</span><br><span class="line">        while(o)&#123;</span><br><span class="line">            stack.push(o)</span><br><span class="line">            o = o.left</span><br><span class="line">        &#125;</span><br><span class="line">        const n  = stack.pop()</span><br><span class="line">        arr.push(n.value)</span><br><span class="line">        o = n.right</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode145二叉树后序遍历"><a href="#leetcode145二叉树后序遍历" class="headerlink" title="leetcode145二叉树后序遍历"></a>leetcode145二叉树后序遍历</h4><p>左右根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function tree(root)&#123;</span><br><span class="line">    1：递归版</span><br><span class="line">    const arr = []</span><br><span class="line">    const fn = (node) =&gt; &#123;</span><br><span class="line">        if(node)&#123;</span><br><span class="line">           fn(node.left)</span><br><span class="line">           fn(node.right)</span><br><span class="line">           arr.push(node.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(root)</span><br><span class="line">    return arr</span><br><span class="line">    </span><br><span class="line">    2：</span><br><span class="line">    if(!root)return []</span><br><span class="line">    const arr = []</span><br><span class="line">    const stack = [root]</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        const o = stack.pop()</span><br><span class="line">        arr.unshift(o.value)</span><br><span class="line">        o.left &amp;&amp; stack.push(o.left)</span><br><span class="line">        o.right &amp;&amp; stack.push(o.right)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode111二叉树最小深度"><a href="#leetcode111二叉树最小深度" class="headerlink" title="leetcode111二叉树最小深度"></a>leetcode111二叉树最小深度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function tree(root)&#123;</span><br><span class="line">    if(!root)return 0</span><br><span class="line">    const stack = [ [root,1] ]</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        const [o,n] = stack.shift()</span><br><span class="line">        if(!o.left || !o.right)&#123;</span><br><span class="line">            return n </span><br><span class="line">        &#125;</span><br><span class="line">        if(o.left)stack.push([o.left,n+1])</span><br><span class="line">        if(o.right)stack.push([o.right,n+1])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode104二叉树最大深度"><a href="#leetcode104二叉树最大深度" class="headerlink" title="leetcode104二叉树最大深度"></a>leetcode104二叉树最大深度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function tree(root)&#123;</span><br><span class="line">    if(!root)return 0</span><br><span class="line">    const stack = [root]</span><br><span class="line">    let num = 0</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">    let len = stack.length</span><br><span class="line">        num++</span><br><span class="line">        while(len--)&#123;</span><br><span class="line">            const o = stack.shift()</span><br><span class="line">            o.left &amp;&amp; stack.push(o.left)</span><br><span class="line">            o.right &amp;&amp; stack.push(o.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode104翻转二叉树"><a href="#leetcode104翻转二叉树" class="headerlink" title="leetcode104翻转二叉树"></a>leetcode104翻转二叉树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tree(root)&#123;</span><br><span class="line">    if(root == null)return null</span><br><span class="line">    let tem = root.left</span><br><span class="line">    root.left = rot.right</span><br><span class="line">    root.right = tem</span><br><span class="line">    tree(root.left)</span><br><span class="line">    tree(root.right)</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode100相同的树"><a href="#leetcode100相同的树" class="headerlink" title="leetcode100相同的树"></a>leetcode100相同的树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断两个树结构相同，值相同</span><br><span class="line">function tree(p,q)&#123;</span><br><span class="line">    if(p == null &amp;&amp; q == null)return true</span><br><span class="line">    if(p == null || q == null)return false</span><br><span class="line">    if(p.val != q.val)return false</span><br><span class="line">    return tree(p.left,q.left) &amp;&amp; tree(p.right,q.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>loading……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;之前草草过了一遍数据结构，这次再来复习一下&quot;&gt;&lt;a href=&quot;#之前草草过了一遍数据结构，这次再来复习一下&quot; class=&quot;headerlink&quot; title=&quot;之前草草过了一遍数据结构，这次再来复习一下&quot;&gt;&lt;/a&gt;之前草草过了一遍数据结构，这次再来复习一下&lt;/</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://222cabbage.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法1" scheme="https://222cabbage.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951/"/>
    
  </entry>
  
  <entry>
    <title>React18走起</title>
    <link href="https://222cabbage.github.io/2022/08/31/react18/"/>
    <id>https://222cabbage.github.io/2022/08/31/react18/</id>
    <published>2022-08-31T03:21:47.000Z</published>
    <updated>2022-08-31T04:40:10.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React走起，不要怪我卷，你们逼我的"><a href="#React走起，不要怪我卷，你们逼我的" class="headerlink" title="React走起，不要怪我卷，你们逼我的"></a>React走起，不要怪我卷，你们逼我的</h2><p>vue框架的使用基本差不多了，后续再钻研源码，看到别人各种夸奖react，我也想去学一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;React走起，不要怪我卷，你们逼我的&quot;&gt;&lt;a href=&quot;#React走起，不要怪我卷，你们逼我的&quot; class=&quot;headerlink&quot; title=&quot;React走起，不要怪我卷，你们逼我的&quot;&gt;&lt;/a&gt;React走起，不要怪我卷，你们逼我的&lt;/h2&gt;&lt;p&gt;vu</summary>
      
    
    
    
    <category term="React" scheme="https://222cabbage.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://222cabbage.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>vue3新特性，node多版本管理工具nvm和nrm的使用</title>
    <link href="https://222cabbage.github.io/2022/08/25/vue31/"/>
    <id>https://222cabbage.github.io/2022/08/25/vue31/</id>
    <published>2022-08-25T05:11:53.000Z</published>
    <updated>2022-08-29T11:47:33.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><p>从前实习做的项目和自己做的项目基本上都是vue2版本</p><p>到目前，vue3版本已经很成熟了，很多公司也都开始使用上了vue3，那么我也去学习一下吧</p><h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><p>vue3的双向绑定是基于proxy实现，与vue2的defineProperty不同</p><p>1：祛除了麻烦的for in 循环遍历监听</p><p>2：可以监听复杂对象变化</p><p>3：代码简化:</p><p>4：可以监听删除的属性和数组长度索引</p><p>vue3对VDOM进行了更新，对文本节点等内容进行标记，更新只对比想同类型节点，不同于vue2全局diff</p><p>vue3支持多根节点</p><p>同时支持render JSX写法</p><p>支持多v-model</p><p>支持tree-shaking</p><p>componsition-api也就是vue3-hook</p><h4 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest //注：npm 和 yarn的用法不同 //之前看过一些vite，命令都不一样</span><br><span class="line">npm i</span><br><span class="line">vite是通过script type=&quot;module&quot;的方式进行构建</span><br><span class="line">因此比传统的webpack启动服务更快</span><br><span class="line">修改一小块内容，只是对那一部分内容进行刷新，而不是全部刷新</span><br><span class="line">基于rollup</span><br></pre></td></tr></table></figure><h4 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h4><p>对node进行版本管理的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">建议先弄个梯子，不然github都进不去</span><br><span class="line">下载.exe文件安装</span><br><span class="line">安装目录名不要有中文字符</span><br><span class="line">nvm list //查看当前nvm使用的node版本集</span><br><span class="line">nvm list available //查看所有node版本</span><br><span class="line">nvm install 版本号//安装对应node版本 需要修改nvm安装目录下的setting文件，将包源切换为淘宝，不然除非科学上网，否则很难成功下载node</span><br><span class="line">nvm use 版本号//使用某个版本的node，记得命令行使用管理员权限打开</span><br><span class="line">nvm uninstall 版本号//卸载某个版本的node</span><br></pre></td></tr></table></figure><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>切换源的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm ls //展示源列表</span><br><span class="line">nrm use 源 //使用某源</span><br><span class="line">nrm test npm/taobeo/......  //测试速度</span><br></pre></td></tr></table></figure><h4 id="vetur和volar"><a href="#vetur和volar" class="headerlink" title="vetur和volar"></a>vetur和volar</h4><p>vetur是vue2时辅助开发的插件，但是vue3不适用，语法不同，如果使用vue2，则需要禁用volar，反之亦然</p><h4 id="模板语法和指令"><a href="#模板语法和指令" class="headerlink" title="模板语法和指令"></a>模板语法和指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">模板语法</span><br><span class="line">const mes:syring = &#x27;my name&#x27;</span><br><span class="line">&#123;&#123; name &#125;&#125;</span><br><span class="line">花括号中可以写三元表达式，运算等等</span><br><span class="line"></span><br><span class="line">指令</span><br><span class="line">v-text</span><br><span class="line">v-html</span><br><span class="line">v-if</span><br><span class="line">v-else-if</span><br><span class="line">v-else</span><br><span class="line">v-show</span><br><span class="line">v-on/@</span><br><span class="line">v-model</span><br><span class="line">v-bind/:</span><br><span class="line">v-for</span><br></pre></td></tr></table></figure><h4 id="虚拟dom和diff算法"><a href="#虚拟dom和diff算法" class="headerlink" title="虚拟dom和diff算法"></a>虚拟dom和diff算法</h4><p>虚拟dom：通过js来生成一个AST节点树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算了算了，懂懂概念还行，写就算了</span><br></pre></td></tr></table></figure><h4 id="ref全家桶"><a href="#ref全家桶" class="headerlink" title="ref全家桶"></a>ref全家桶</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref,Ref &#125; from &#x27;vue&#x27;</span><br><span class="line">const mes:Ref&lt;string&gt; = ref(&#x27;&#x27;)</span><br><span class="line">mes经过ref包装后，成为了响应式的对象，需要通过mes.value取值</span><br><span class="line"></span><br><span class="line">isRef // 判断是否是ref对象</span><br><span class="line">console.log(isRef(mes))</span><br><span class="line"></span><br><span class="line">shallowRef //创建一个跟踪自身.value变化的ref，单内部属性不会变成ref</span><br><span class="line">const mes = shallowRef(&#123;name:&#x27;hao&#x27;&#125;)</span><br><span class="line">const btnClivk = () =&gt; &#123;</span><br><span class="line">mes.value.name = &#x27;123&#x27; //无效</span><br><span class="line">mes.value = &#123;name:&#x27;123&#x27;&#125; //有效，内部属性不是响应式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">triggerRef //强制更新</span><br><span class="line">const mes = shallowRef(&#123;name:&#x27;hao&#x27;&#125;)</span><br><span class="line">const btnClivk = () =&gt; &#123;</span><br><span class="line">mes.value.name = &#x27;123&#x27; //无效</span><br><span class="line">triggger(mes) //有效，强制更新</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customRef //自定义ref</span><br><span class="line">function myRef&lt;T&gt;(value:T)&#123;</span><br><span class="line">return customRef((trank,trigger)=&gt;&#123;</span><br><span class="line">//trank为依赖 </span><br><span class="line">        return &#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                trank()</span><br><span class="line">                return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newValue:T)&#123;</span><br><span class="line">                value = newValue</span><br><span class="line">                trigger()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let mes = myRef&lt;string&gt;(&#x27;123&#x27;)</span><br></pre></td></tr></table></figure><h4 id="shallowRef造成视图更新的问题……"><a href="#shallowRef造成视图更新的问题……" class="headerlink" title="shallowRef造成视图更新的问题……"></a>shallowRef造成视图更新的问题……</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reactive全家桶"><a href="#reactive全家桶" class="headerlink" title="reactive全家桶"></a>reactive全家桶</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line">let mes = reactive([]/&#123;&#125;) //只接收复杂类型对象，如果插入简单数据类型，会提示错误，源码做了类型限制</span><br><span class="line">T extends object，只能是对象，又利用了isObject判断</span><br><span class="line"></span><br><span class="line">ref适用于基本类型</span><br><span class="line">reactive适用于复杂类型</span><br><span class="line">修改ref数据需要xxx.value = &#x27;&#x27;</span><br><span class="line">reactive则不需要 xxx.name = &#x27;123&#x27;</span><br><span class="line">//注，ref底层转换响应式使用了reactive</span><br><span class="line"></span><br><span class="line">reactive数据不能直接赋值，会破坏响应式</span><br><span class="line">解决方式：可以使用ref定义，或者定义一个reactive对象，内部属性是响应式</span><br><span class="line"></span><br><span class="line">readonly</span><br><span class="line">let mes = ref(&#x27;mes&#x27;)</span><br><span class="line">let copy = readonly(mes)</span><br><span class="line">copy.value = &#x27;123&#x27; //不允许，只读</span><br><span class="line"></span><br><span class="line">shallowReactive</span><br><span class="line">只能动浅层的数据，如果是深层的数据只会改变值，不会改变视图</span><br><span class="line">let mes = shallowReactive(&#123;</span><br><span class="line">    test:&#x27;123&#x27;,</span><br><span class="line">    people:&#123;</span><br><span class="line">        friends:&#123;</span><br><span class="line">            name:&#x27;&#x27;,</span><br><span class="line">            age:&#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/26/v26jxS.png"></p><p><img src="https://s1.ax1x.com/2022/08/26/v2cFP0.png"></p><h4 id="toRef，toRefs，toRaw"><a href="#toRef，toRefs，toRaw" class="headerlink" title="toRef，toRefs，toRaw"></a>toRef，toRefs，toRaw</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">toRef</span><br><span class="line">如果原始数据没有经过reactive包裹，那么通过toRef转换的数据内部值修改，视图不更新</span><br><span class="line">const obj = &#123;name:&#x27;hao&#x27;&#125;</span><br><span class="line">const state = toRef(onj,&#x27;name&#x27;)</span><br><span class="line">state.value = &#x27;ge&#x27;</span><br><span class="line"></span><br><span class="line">toRefs</span><br><span class="line">let obj = reactive(&#123;</span><br><span class="line">    name:&#x27;hao&#x27;,</span><br><span class="line">    age:21</span><br><span class="line">&#125;)</span><br><span class="line">let &#123;name,age&#125; = toRefs(obj) //通过toRefs结构出来的数据变成响应式，否则失去响应式</span><br><span class="line"></span><br><span class="line">toRaw //转换非响应式对象</span><br><span class="line">let obj = reactive(&#123;</span><br><span class="line">    name:&#x27;hao&#x27;,</span><br><span class="line">    age:21</span><br><span class="line">&#125;)</span><br><span class="line">let copy = toRaw(obj)</span><br></pre></td></tr></table></figure><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const age = computed(()=&gt;&#123;</span><br><span class="line">    return 21</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const age = computed(&#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        return 123</span><br><span class="line">    &#125;,</span><br><span class="line">    set()&#123;</span><br><span class="line">        123</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">具有缓存</span><br></pre></td></tr></table></figure><h4 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器"></a>watch侦听器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let mes = ref&lt;string&gt;(&#x27;hao&#x27;)</span><br><span class="line">watch(mes,(oldValue,newValue)=&gt;&#123;</span><br><span class="line">console.log(&#x27;旧值&#x27;,oldValue)</span><br><span class="line">console.log(&#x27;新值&#x27;,newValue)</span><br><span class="line">&#125;)</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">mes.value = &#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">支监听多个</span><br><span class="line">let mes = ref&lt;string&gt;(&#x27;hao&#x27;)</span><br><span class="line">let mes2 = ref&lt;string&gt;(&#x27;hao2&#x27;)</span><br><span class="line">watch([mes,mes2],(oldValue,newValue)=&gt;&#123;</span><br><span class="line">console.log(&#x27;旧值&#x27;,oldValue) //打印出来同为数组</span><br><span class="line">console.log(&#x27;新值&#x27;,newValue) //打印出来同为数组</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">深度监听</span><br><span class="line">let mes = ref(&#123;</span><br><span class="line">    nav:&#123;</span><br><span class="line">        name:&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">watch(mes,(oldValue,newValue)=&gt;&#123;</span><br><span class="line">console.log(&#x27;旧值&#x27;,oldValue) //打印出来同为数组</span><br><span class="line">console.log(&#x27;新值&#x27;,newValue) //打印出来同为数组</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    deep:true, //深层次监听，如果用ref定义复杂类型则需要使用这个，如果使用reactive则不需要</span><br><span class="line">    immediate:true //页面最开始加载调用一次</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">只监听某个数据</span><br><span class="line">let mes = reactive(&#123;</span><br><span class="line">   name:&#x27;123&#x27;,</span><br><span class="line">   name2:&#x27;232&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">只监听单一项</span><br><span class="line">watch(()=&gt;mes.name,(old,value)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">高级侦听器，非惰性，进入页面自动调用，全部监听</span><br><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">    console.log(mes.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">监听之前需要做什么</span><br><span class="line">watchEffect((oninvalidate)=&gt;&#123;</span><br><span class="line">oninvalidate(()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;先执行该回调，处理一些事情&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">    console.log(mes.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">停止监听</span><br><span class="line">const stopWatch = watchEffect((oninvalidate)=&gt;&#123;</span><br><span class="line">oninvalidate(()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;先执行该回调，处理一些事情&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">    console.log(mes.name)</span><br><span class="line">&#125;)</span><br><span class="line">@click = () =&gt; stopWatch() //停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">额外配置选项</span><br><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">//如果在此处访问dom，非惰性的原因会返回null</span><br><span class="line">    console.log(mes.name)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    flush:&quot;post&quot;, //dom加载完后再读取dom</span><br><span class="line">    onTrigger(e)&#123; //调试</span><br><span class="line">        debugger</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件和生命周期"><a href="#组件和生命周期" class="headerlink" title="组件和生命周期"></a>组件和生命周期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &#x27;..&#x27;</span><br><span class="line">&lt;Hello/&gt; 3.2 引入无须在components里注册就能使用</span><br><span class="line"></span><br><span class="line">生命周期</span><br><span class="line">setup，onBeforeMount，onMounted，onBeforeUpdate，onUpdated，onBeforeUnmount，onUnmounted</span><br></pre></td></tr></table></figure><h4 id="less，scoped"><a href="#less，scoped" class="headerlink" title="less，scoped"></a>less，scoped</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader -D</span><br><span class="line">scoped //单页面应用保证同类样式不冲突</span><br><span class="line">使用了data-v-xxx，样式修改为属性选择器</span><br></pre></td></tr></table></figure><h4 id="父子组件传参"><a href="#父子组件传参" class="headerlink" title="父子组件传参"></a>父子组件传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">defineProps</span><br><span class="line">写法1</span><br><span class="line">:title=&quot;&quot;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">写法2</span><br><span class="line">type Props = &#123;title:string&#125; </span><br><span class="line">defineProps&lt;Props&gt;()</span><br><span class="line"></span><br><span class="line">defineEmits</span><br><span class="line">子组件</span><br><span class="line">const emit = defineEmits([&#x27;emitMes&#x27;...//可以配置多个事件])</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">emit(&#x27;emitMes&#x27;,params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line">@emitMes=&quot;emitmes&quot;</span><br><span class="line">const emitmes = (value) =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineExpose</span><br><span class="line">子组件</span><br><span class="line">const mes = ref(&#x27;hao&#x27;)</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">    mes</span><br><span class="line">&#125;)</span><br><span class="line">父组件能通过在子组件标签上添加ref的方式获取子组件暴露出来的变量</span><br><span class="line"></span><br><span class="line">如果希望props有默认值</span><br><span class="line">type Props = &#123;title:string&#125; </span><br><span class="line">defineProps&lt;Props&gt;()</span><br><span class="line">withDefaults(defineProps&lt;Props&gt;(),&#123;</span><br><span class="line">    title:&#x27;我是默认值&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="全局组件，局部组件，递归组件"><a href="#全局组件，局部组件，递归组件" class="headerlink" title="全局组件，局部组件，递归组件"></a>全局组件，局部组件，递归组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">全局</span><br><span class="line">import XXX from &#x27;&#x27;</span><br><span class="line">app.component(&#x27;名字&#x27;,XXX) //main.js / main.ts 不能跟随在mount后面进行链式调用</span><br><span class="line"></span><br><span class="line">局部</span><br><span class="line">。。。。。。</span><br><span class="line"></span><br><span class="line">递归</span><br><span class="line">方法1：</span><br><span class="line">我引入我自己 //虽然成功但是会有提示警告</span><br><span class="line">放发2：</span><br><span class="line">再添加一个script，export default &#123;name:&#x27;&#x27;&#125;</span><br><span class="line">利用这个name作为组件名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import A from &#x27;./&#x27;</span><br><span class="line">import B from &#x27;./&#x27;</span><br><span class="line">&lt;component :is=&quot;A&quot;&gt;</span><br><span class="line">v3的is只能传组件不能传字符串，v2可以传字符串</span><br><span class="line">markRaw，为对象添加_v_skip,true时跳过</span><br><span class="line">const coms = [&#123;</span><br><span class="line">    name:&quot;A&quot;,</span><br><span class="line">    comName:markRaw(A) //组件是无需代理的，需要用markRaw包裹</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="插槽全家桶"><a href="#插槽全家桶" class="headerlink" title="插槽全家桶"></a>插槽全家桶</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">匿名插槽</span><br><span class="line">子组件</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;子组件名&gt;</span><br><span class="line">&lt;template v-slot&gt;</span><br><span class="line">我是插入的内容</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/子组件名&gt;</span><br><span class="line"></span><br><span class="line">具名插槽</span><br><span class="line">子组件</span><br><span class="line">&lt;slot name=&quot;A&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;B&quot;&gt;&lt;/slot&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;子组件名&gt;</span><br><span class="line">&lt;template v-slot:A&gt;</span><br><span class="line">我是插入A的内容</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:B&gt;</span><br><span class="line">我是插入B的内容</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//也可简写#===v-slot</span><br><span class="line">&lt;template #B&gt;</span><br><span class="line">我是插入B的内容</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/子组件名&gt;</span><br><span class="line"></span><br><span class="line">作用域插槽</span><br><span class="line">&lt;slot name=&quot;A&quot; :title=&quot;mes&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;子组件名&gt;</span><br><span class="line">&lt;template v-slot:A=&quot;&#123;title&#125;&quot;&gt;</span><br><span class="line">我是插入A的内容&#123;&#123; title &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/子组件名&gt;</span><br><span class="line"></span><br><span class="line">动态插槽</span><br><span class="line">&lt;slot name=&quot;A&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;B&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;子组件名&gt;</span><br><span class="line">&lt;template #[name]&gt;</span><br><span class="line">我是插入的内容</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/子组件名&gt;</span><br><span class="line"></span><br><span class="line">const name = ref(&#x27;A&#x27;) //插入A</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    name.value = &#x27;B&#x27; //点击后插入B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步组件，代码分包，suspense性能优化"><a href="#异步组件，代码分包，suspense性能优化" class="headerlink" title="异步组件，代码分包，suspense性能优化"></a>异步组件，代码分包，suspense性能优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">异步组件</span><br><span class="line">defineAsyncComponent</span><br><span class="line">demo：如果A组件是根据异步返回的数据v-for生成，那么视图不会更新，需要使用defineAsyncComponent</span><br><span class="line">const A = defineAsyncComponent(()=&gt;import(&#x27;./A.vue&#x27;))</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">插槽1：</span><br><span class="line">&lt;template #default&gt;</span><br><span class="line">&lt;A/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">插槽2：在异步加载组件之前可以做点什么</span><br><span class="line">&lt;template #fallback&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">Loading</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line"></span><br><span class="line">代码分包</span><br><span class="line">通过异步组件使代码build后拆分文件，被单独打包</span><br><span class="line">suspense</span><br></pre></td></tr></table></figure><h4 id="teleport传送组件"><a href="#teleport传送组件" class="headerlink" title="teleport传送组件"></a>teleport传送组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将模板渲染至指定DOM节点，不受父级style，v-show影响。但是data，prop数据依旧共用的技术</span><br><span class="line">类似于react的Portal</span><br><span class="line">&lt;teleport to=&quot;body/.class/#id&quot;&gt;  //to=?? 指定传送位置</span><br><span class="line">&lt;div&gt;我是需要传送的内容&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure><h4 id="keep-alive缓存组件，源码解析"><a href="#keep-alive缓存组件，源码解析" class="headerlink" title="keep-alive缓存组件，源码解析"></a>keep-alive缓存组件，源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">不希望组件重复渲染，节省性能</span><br><span class="line">include //缓存什么组件，如果无效可能是需要导出组件name</span><br><span class="line">exclude //不缓存什么组件</span><br><span class="line">max //最大缓存多少个组件，优先不缓存使用频率低的组件，而不是根据顺序</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;A&#x27;]&quot;&gt; //只缓存A组件</span><br><span class="line">&lt;keep-alive :exclude=&quot;[&#x27;A&#x27;]&quot;&gt; /不缓存A组件</span><br><span class="line">&lt;A/&gt;</span><br><span class="line">&lt;B/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">新增生命周期v3，v2是actived和deactived</span><br><span class="line">onActived //keep-alive初始化</span><br><span class="line">onDeactived //keep-alive组件切换卸载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keep-alive内部只能有一个根节点</span><br><span class="line">源码中对插槽做了判断</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/26/vRiy5Q.png"> </p><p>缓存机制，map结构，判断key</p><p><img src="https://s1.ax1x.com/2022/08/26/vRifK0.png"></p><p>组件也不是真正卸载</p><p><img src="https://s1.ax1x.com/2022/08/26/vRiHPJ.png"></p><h4 id="transition动画组件"><a href="#transition动画组件" class="headerlink" title="transition动画组件"></a>transition动画组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;animatename&quot;&gt;</span><br><span class="line">&lt;A/ v-if=&quot;flag&quot;&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">flag.value = !flag.value //隐藏与显示切换太过生硬</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">style中 //vue提供的类名</span><br><span class="line">.animatename-enter-from&#123;</span><br><span class="line">    width:0px;</span><br><span class="line">    height:0px</span><br><span class="line">&#125;</span><br><span class="line">.animatename-enter-active&#123;</span><br><span class="line">transition:all 1.5s ease</span><br><span class="line">&#125;</span><br><span class="line">.animatename-enter-to &#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:200px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.animatename-leave-from&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px</span><br><span class="line">&#125;</span><br><span class="line">.animatename-leave-active&#123;</span><br><span class="line">transition:all 1.5s ease</span><br><span class="line">&#125;</span><br><span class="line">.animatename-leave-to &#123;</span><br><span class="line">width:0px;</span><br><span class="line">height:0px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transition组件结合animate-css"><a href="#transition组件结合animate-css" class="headerlink" title="transition组件结合animate.css"></a>transition组件结合animate.css</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自定义class</span><br><span class="line">enter-from-class=&quot;&quot; enter-avtive-class=&quot;&quot; enter-to-class=&quot;&quot;</span><br><span class="line">leave-from-class=&quot;&quot; leave-active-class=&quot;&quot; leave-to-class=&quot;&quot;</span><br><span class="line">duration配置其他属性 动画持续时长</span><br><span class="line">duration=&quot;500&quot; //动画持续时长 500毫秒</span><br><span class="line">duration=&#123;enter:&quot;500&quot;,leave:&quot;500&quot;&#125; </span><br><span class="line"></span><br><span class="line">结合animate.css</span><br><span class="line">npm install animate.css</span><br><span class="line">import &#x27;animate.css&#x27;</span><br><span class="line">animate.css官网赋值类名为transition标签添加</span><br></pre></td></tr></table></figure><h4 id="transition生命周期和GSAP"><a href="#transition生命周期和GSAP" class="headerlink" title="transition生命周期和GSAP"></a>transition生命周期和GSAP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@before-enter=&quot;enterFrom&quot; //对应enter-from</span><br><span class="line">@enter= //enter-active</span><br><span class="line">@after-enter= //enter-to</span><br><span class="line">@enter-cancelled= //显示过渡打断</span><br><span class="line">@before-leave= //leave-from</span><br><span class="line">@leave= //enter-active</span><br><span class="line">@after= //leave-to</span><br><span class="line">@leave-cancelled= //离开过渡打断</span><br><span class="line"></span><br><span class="line">const enterFrom = (el:Element) =&gt; &#123;</span><br><span class="line">进入之前</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">npm install gsap -D //动画库</span><br><span class="line">import gsap from &#x27;gsap&#x27;</span><br><span class="line">const enterFrom = (el:Element) =&gt; &#123;</span><br><span class="line">gsap.set(el,&#123;</span><br><span class="line">        width:0,</span><br><span class="line">        height:0</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const enterActive = (el:Element,done:gasp.CallBack) =&gt; &#123;</span><br><span class="line">gsap.to(el,&#123;</span><br><span class="line">        width:200,</span><br><span class="line">        height:200,</span><br><span class="line">        onComplete:done</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const leave = (el:Element,done:gasp.CallBack) =&gt; &#123;</span><br><span class="line">gsap.to(el,&#123;</span><br><span class="line">        width:0,</span><br><span class="line">        height:0,</span><br><span class="line">        onComplete:done</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="transition的Appear属性"><a href="#transition的Appear属性" class="headerlink" title="transition的Appear属性"></a>transition的Appear属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition </span><br><span class="line">appear</span><br><span class="line">appear-from-class=&quot;&quot;</span><br><span class="line">appear-active-class=&quot;&quot;</span><br><span class="line">appear-to-class=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><h4 id="transitionGroup"><a href="#transitionGroup" class="headerlink" title="transitionGroup"></a>transitionGroup</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const list = reactive([1,2,3,4])</span><br><span class="line">&lt;transition-group //添加动画属性和transtion相同&gt;列表动画</span><br><span class="line">&lt;div v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;</span><br><span class="line">&#123;&#123; item &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line"></span><br><span class="line">const add = () =&gt; &#123;</span><br><span class="line">list.push(&#x27;x&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const delete = () =&gt; &#123;</span><br><span class="line">list.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平滑过渡动画"><a href="#平滑过渡动画" class="headerlink" title="平滑过渡动画"></a>平滑过渡动画</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flip动画库</span><br><span class="line">lodash制作随机数</span><br><span class="line">let list = [数字们]</span><br><span class="line">nom install lodash -D</span><br><span class="line">npm install @types/lodash -D</span><br><span class="line">import _ from &#x27;lodash&#x27;</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">list.value = _.shuffle(list.value) //变换数字排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="依赖注入provide，inject"><a href="#依赖注入provide，inject" class="headerlink" title="依赖注入provide，inject"></a>依赖注入provide，inject</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;provide,inject&#125; from &#x27;vue&#x27;</span><br><span class="line">provide(&#x27;mes&#x27;,mes) //发送</span><br><span class="line">const mes = inject(&#x27;mes&#x27;) //接收</span><br></pre></td></tr></table></figure><h4 id="兄弟组件传参"><a href="#兄弟组件传参" class="headerlink" title="兄弟组件传参"></a>兄弟组件传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">利用父组件传参，每次都要在父组件处理，麻烦</span><br><span class="line">A</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">emit(&#x27;change&#x27;,true)</span><br><span class="line">&#125;</span><br><span class="line">B</span><br><span class="line">defineProps(&#123;</span><br><span class="line">    flag,</span><br><span class="line">&#125;)</span><br><span class="line">父组件</span><br><span class="line">&lt;A @change=&quot;change&quot;/&gt;</span><br><span class="line">const flag = ref(false)</span><br><span class="line">const change = (value) =&gt; &#123;</span><br><span class="line">    flag.value = value</span><br><span class="line">&#125;</span><br><span class="line">&lt;B :flag=&quot;flag&quot;/&gt;</span><br><span class="line"></span><br><span class="line">eventBus</span><br><span class="line">封装的bus.ts</span><br><span class="line">type BusClass &#123;</span><br><span class="line">    emit:(name:string)=&gt;void</span><br><span class="line">    on:(name:string,callback:Function)=&gt;void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PramsKey = string | number | symbol</span><br><span class="line"></span><br><span class="line">type List = &#123;</span><br><span class="line">    [key:PramsKey]:Array&lt;Function&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bus implements BusClass &#123;</span><br><span class="line">    list:List</span><br><span class="line">    constructor()&#123;</span><br><span class="line">this.list = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">emit(name:string,...args:Array&lt;any&gt;)&#123;</span><br><span class="line">        let eventName:Array&lt;Function&gt; = this.list[name]</span><br><span class="line">        eventName.forEach(fn =&gt; &#123;</span><br><span class="line">fn.apply(this,args)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">on(name:string,callback:Function)&#123;</span><br><span class="line">        let fn:Array&lt;Function&gt; = this.list[name] || []</span><br><span class="line">        fn.push(callback)</span><br><span class="line">        this.list[name] = fn</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new Bus()</span><br><span class="line"></span><br><span class="line">import bus from &#x27;//&#x27;</span><br><span class="line">bus.emit(&#x27;xx&#x27;,123)</span><br><span class="line">bus.on(&#x27;xx&#x27;,(value)=&gt;&#123;</span><br><span class="line">    console.log(value) //123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Mitt"><a href="#Mitt" class="headerlink" title="Mitt"></a>Mitt</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Mitt是封装的eventBus库</span><br><span class="line">npm install mitt -S</span><br><span class="line"></span><br><span class="line">局部注册 //不带ts</span><br><span class="line">import mitt from &quot;mitt&quot;;</span><br><span class="line">const emitter = mitt();</span><br><span class="line">export default emitter</span><br><span class="line"></span><br><span class="line">全局注册 main.ts </span><br><span class="line">import mitt from &#x27;mitt&#x27;</span><br><span class="line">consyt Mitt = mitt()</span><br><span class="line">需要使用ts</span><br><span class="line">declare module &#x27;vue&#x27; &#123;</span><br><span class="line">    export interface ComponentCustomProperties &#123;</span><br><span class="line">        $Bus:typeof Mitt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.config.globalProperties.$Bus = Mitt</span><br><span class="line"></span><br><span class="line">页面中使用</span><br><span class="line">全局注册时</span><br><span class="line">import  &#123; getCurrentInstance &#125; from &#x27;vue&#x27;</span><br><span class="line">const instance = getCurrentInstance()</span><br><span class="line">instance?.proxy?.$Bus.emit(&#x27;xx&#x27;,123) //其他页面使用也这样</span><br><span class="line"></span><br><span class="line">局部注册</span><br><span class="line">import bus from &#x27;....&#x27;</span><br><span class="line">bus.$emit()</span><br><span class="line">bus.$on()</span><br><span class="line"></span><br><span class="line">监听多个事件</span><br><span class="line">bus.$emit(&#x27;A&#x27;)</span><br><span class="line">bus.$emit(&#x27;B&#x27;)</span><br><span class="line"></span><br><span class="line">bus.$on(&#x27;*&#x27;,(type,str)=&gt;&#123;</span><br><span class="line">    console.log(type,str) //打印出事件名和参数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">取消指定事件</span><br><span class="line">bus.$off(&#x27;xx&#x27;)</span><br><span class="line">取消所有指定事件</span><br><span class="line">bus.all.clear()</span><br></pre></td></tr></table></figure><h4 id="TSX"><a href="#TSX" class="headerlink" title="TSX"></a>TSX</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">之前使用的是template模板格式</span><br><span class="line">npm install @vitejs/plugin-vue-jsx</span><br><span class="line">配置太多，手敲太麻烦了，就附带一张长图展示vue使用tsx的配置和注意事项，跟着一步一步来就可以</span><br><span class="line">图片最下方有该博主的账号名</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/27/vR6tF1.png"></p><h4 id="ref等api自动引入插件"><a href="#ref等api自动引入插件" class="headerlink" title="ref等api自动引入插件"></a>ref等api自动引入插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install unplugin-auto-import -D</span><br><span class="line">配置百度查看，嘻嘻嘻</span><br></pre></td></tr></table></figure><h4 id="v-model深入"><a href="#v-model深入" class="headerlink" title="v-model深入"></a>v-model深入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">v-model是一个语法糖，是结合了props和emit而成</span><br><span class="line">默认值的改变：</span><br><span class="line">prop: value =&gt; modelValue</span><br><span class="line">demo:控制dialog组件显示与隐藏</span><br><span class="line">const flag = ref(true)</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    flag = !flag</span><br><span class="line">&#125;</span><br><span class="line">&lt;Dialog v-model=&quot;flag&quot;/&gt;</span><br><span class="line">组件内</span><br><span class="line">defineProps(&#123;</span><br><span class="line">modelValue,    </span><br><span class="line">&#125;)</span><br><span class="line">v-if=&quot;modelValue&quot;</span><br><span class="line"></span><br><span class="line">事件：input =&gt; update:modelValue</span><br><span class="line">const emit = defineEmits([&#x27;update:modelValue&#x27;])</span><br><span class="line">emit(&#x27;update:modelValue&#x27;,123)</span><br><span class="line"></span><br><span class="line">v-bind的.sync 修饰符和组件的model选项已经移除</span><br><span class="line"></span><br><span class="line">新增支持多个v-model</span><br><span class="line">v-model:title=&quot;123&quot;</span><br><span class="line"></span><br><span class="line">新增支持自定义修饰符</span><br><span class="line">v-model:hao=&quot;&quot;</span><br><span class="line">v-model:title.aass=&quot;title&quot;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">    [绑定属性名]Modifiers?:&#123;</span><br><span class="line">        hao:string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    if(props. [绑定属性名]Modifiers?.hao)&#123;</span><br><span class="line">do some thing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">div v-dir=&quot;123&quot;</span><br><span class="line">const vDir = &#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">    console.log(&#x27;created&#x27;)    </span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted(...args:Array&lt;any&gt;)&#123;</span><br><span class="line">            //可以获取一系列信息，节点，值，修饰符等</span><br><span class="line">            console.log(args)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    updated()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUnmount()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    unmounted()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">简写</span><br><span class="line">const vDir = (el,binding) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小demo，拖拽命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-move class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;</span><br><span class="line">      头</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">      内容</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref ,reactive,Directive,DirectiveBinding&#125; from &#x27;vue&#x27;;</span><br><span class="line">const vMove:Directive&lt;any,void&gt; = (el:HTMLElement,bingding:DirectiveBinding) =&gt; &#123;</span><br><span class="line">  let moveElement:HTMLDivElement = el.firstElementChild as HTMLDivElement</span><br><span class="line">  const mousedown = (e:MouseEvent) =&gt; &#123;</span><br><span class="line">    let X = e.clientX - el.offsetLeft</span><br><span class="line">    let Y = e.clientY - el.offsetTop</span><br><span class="line">    const move = (e:MouseEvent) =&gt; &#123;</span><br><span class="line">      el.style.left = e.clientX - X + &#x27;px&#x27;</span><br><span class="line">      el.style.top = e.clientY -Y + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">     document.addEventListener(&#x27;mousemove&#x27;,move)</span><br><span class="line">     document.addEventListener(&#x27;mouseup&#x27;,()=&gt;&#123;</span><br><span class="line">      document.removeEventListener(&#x27;mousemove&#x27;,move)</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  moveElement.addEventListener(&#x27;mousedown&#x27;,mousedown)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  height: 500px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  position: relative;</span><br><span class="line">  left:200px;</span><br><span class="line">  top: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 60px;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 400px;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与v2mixin很像，mixin含有的问题，生命周期调用的比组件快</span><br><span class="line">开源库vueUse，hook库</span><br><span class="line">import &#123; useAttrs &#125; from &#x27;vue&#x27; //是一个收集props的hook</span><br><span class="line">let attrs = useAttrs()</span><br><span class="line">console.log(attrs)</span><br><span class="line"></span><br><span class="line">export default function () &#123;</span><br><span class="line">    return 123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import useXX from &#x27;..&#x27;</span><br><span class="line">const xx = useXX()</span><br></pre></td></tr></table></figure><h4 id="全局函数和变量"><a href="#全局函数和变量" class="headerlink" title="全局函数和变量"></a>全局函数和变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vue3不能在原型上挂载，要修改方式</span><br><span class="line">定义时 //vue3移除了fillter，定义一个$filters过滤器,带ts</span><br><span class="line">app.config,globalProperties.$filters = （）=&gt; &#123;</span><br><span class="line">    format&lt;T&gt;(str:T):string&#123;</span><br><span class="line">        return `过滤器$&#123;str&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">app.config,globalProperties.$env = &#x27;1232&#x27;</span><br><span class="line">type Filter = &#123;</span><br><span class="line">    format:&lt;T&gt;(str:T)=&gt;string</span><br><span class="line">&#125;</span><br><span class="line">declare module &#x27;@vue/runtime-core&#x27; &#123;</span><br><span class="line">    export interface ComponentCustomProperties &#123;</span><br><span class="line">        $filters:Filter,</span><br><span class="line">        $env:string</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">使用时</span><br><span class="line">&#123;&#123; $filters.format(&#x27;123&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义vue插件"><a href="#自定义vue插件" class="headerlink" title="自定义vue插件"></a>自定义vue插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">插件是自包含的代码，通常是向Vue添加全局功能，如果是一个对象需要install方法Vue会帮助自动注入install方法，如果是function就可以直接当install使用</span><br><span class="line">在createApp之后通过use()添加插件</span><br><span class="line"></span><br><span class="line">index.ts</span><br><span class="line">import &#123; App , createVNode,render&#125; from &#x27;vue&#x27;</span><br><span class="line">import Loading from &#x27;...&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">install(app:App)&#123;</span><br><span class="line">const vnode:VNode = createVNode(Loading)</span><br><span class="line">         render(vnode,document.body)</span><br><span class="line">         app.config.globalPropertiees.$loading = &#123;</span><br><span class="line">             show:vnode.component?.exposed?.show,</span><br><span class="line">             hide:vnode.component?.exposed?.hide,</span><br><span class="line">         &#125; 。//需要先defineExpoed暴露出</span><br><span class="line">         </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.ts</span><br><span class="line">import Loading from &#x27;loading.ts&#x27;</span><br><span class="line">app.use(Loading) //如果使用ts需要声明</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">import &#123; getCurrentInstance,ComponentInternalInstance &#125; from &#x27;vue&#x27;</span><br><span class="line">const &#123; appContext &#125; = getCurrentInstance() as ComponentInternalInstance</span><br><span class="line">// 听说 const &#123; proxy &#125; = getCurrentInstance()可以直接获取到全局方法</span><br><span class="line">appContext.config.globalProperties.$loading.show()</span><br><span class="line">appContext.config.globalProperties.$loading.hide()</span><br></pre></td></tr></table></figure><h4 id="elementUI"><a href="#elementUI" class="headerlink" title="elementUI"></a>elementUI</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体看官网</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="样式穿透-deep"><a href="#样式穿透-deep" class="headerlink" title="样式穿透:deep()"></a>样式穿透:deep()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue3</span><br><span class="line">style中</span><br><span class="line">:deep(eleUI的样式类名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="css完整新特性"><a href="#css完整新特性" class="headerlink" title="css完整新特性"></a>css完整新特性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">除开:deep</span><br><span class="line">插槽选择器和全局选择器</span><br><span class="line">插槽选择器</span><br><span class="line">:slotted(插槽内节点类名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">全局选择器</span><br><span class="line">原本直接在app.vue中修改样式就是全局样式，但是vue3提供了一个优雅的写法</span><br><span class="line">:global(div)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">动态css和cssmodule</span><br><span class="line">动态css</span><br><span class="line">const color = ref(&#x27;red&#x27;)</span><br><span class="line">div&#123;</span><br><span class="line">color:v-bind(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果是对象</span><br><span class="line">const color = ref(&#123;</span><br><span class="line">    colorStyle:&#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">div&#123;</span><br><span class="line">color:v-bind(color.colorStyle) //不能直接.需要修改成color:v-bind(&#x27;color.colorStyle&#x27;)字符串形式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cssmodule</span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.div &#123;</span><br><span class="line">        color:red</span><br><span class="line">&#125;</span><br><span class="line">.di &#123;</span><br><span class="line">        border:1px solid red</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">使用时</span><br><span class="line">&lt;div :class=&quot;[$style.div,$style.di]&quot;/&gt;</span><br><span class="line"></span><br><span class="line">也可</span><br><span class="line">import  &#123; useCssModule &#125; from &#x27;vue&#x27;</span><br><span class="line">const css = useCssModule(&#x27;style&#x27;)</span><br><span class="line">console.log(css)</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;style&quot;&gt;</span><br><span class="line">.div &#123;</span><br><span class="line">        color:red</span><br><span class="line">&#125;</span><br><span class="line">.di &#123;</span><br><span class="line">        border:1px solid red</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">//改写法比较适用于tsx，jsx写法</span><br></pre></td></tr></table></figure><h4 id="vue3集成TailWindCss"><a href="#vue3集成TailWindCss" class="headerlink" title="vue3集成TailWindCss"></a>vue3集成TailWindCss</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TailWindCss是一个js编写的css框架，基于postCss解析</span><br><span class="line">postCss是一个js编写的使用js工具和插件转换CSS代码的工具</span><br><span class="line">下方截取了其他博主的博客教程，一步步配置即可</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/27/vRjPqH.png"></p><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">事件循环机制</span><br><span class="line">js是单线程的，如果是多线程的话，同一时间会操作多个dom，增加或者删除，单线程意味着所有的任务都要排队，如果前面的任务耗时长，那么后续任务就会卡住，影响用户体验，因此出现了异步的概念//HTML5已经支持多线程webWorker，但是不能操作dom</span><br><span class="line"></span><br><span class="line">同步任务</span><br><span class="line">代码从上到下执行</span><br><span class="line"></span><br><span class="line">异步任务</span><br><span class="line">Promise是同步的</span><br><span class="line"></span><br><span class="line">宏任务</span><br><span class="line">script,定时器，ajax，UI交互</span><br><span class="line"></span><br><span class="line">微任务</span><br><span class="line">promise.then,catch,finally,process.nextTick</span><br><span class="line"></span><br><span class="line">运行机制</span><br><span class="line">所有同步任务都是在主线程形成执行栈，主线程之外还有个任务队列，异步任务执行队列会先执行宏任务，然后清空宏任务中的微任务，再进行下一个tick形成循环</span><br><span class="line">nextTick就是创建一个异步任务，会等待同步任务执行完以后再执行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="nextTick，源码解析"><a href="#nextTick，源码解析" class="headerlink" title="nextTick，源码解析"></a>nextTick，源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">更新dom内容后，访问还是之前的值</span><br><span class="line">import &#123; nextTick &#125; from &#x27;vue&#x27;</span><br><span class="line">const mes = ref(&#x27;1&#x27;)</span><br><span class="line">const div = ref(null)</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    mes.value = &#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">await nextTick()</span><br><span class="line">console.log(div.value.innerText) //正常情况打印应该是123，这里是1，因此需要nextTick</span><br><span class="line"></span><br><span class="line">源码</span><br><span class="line">迷惑后续看吧</span><br></pre></td></tr></table></figure><h4 id="vue开发移动，打包APP暂时跳过"><a href="#vue开发移动，打包APP暂时跳过" class="headerlink" title="vue开发移动，打包APP暂时跳过"></a>vue开发移动，打包APP暂时跳过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时跳过......</span><br></pre></td></tr></table></figure><h4 id="unoCss原子化"><a href="#unoCss原子化" class="headerlink" title="unoCss原子化"></a>unoCss原子化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">什么是css原子化</span><br><span class="line">减少css体积，提高css复用</span><br><span class="line">减少起名复杂度</span><br><span class="line">缺点：增加了记忆成本，势必要记住一些api</span><br><span class="line">集合了tailwindcss和其他css框架</span><br><span class="line"></span><br><span class="line">接入unocss //适用于vite，webpack是阉割版</span><br><span class="line">npm i unocss -D  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/28/vW8fTe.png"></p><h4 id="函数式编程和h函数"><a href="#函数式编程和h函数" class="headerlink" title="函数式编程和h函数"></a>函数式编程和h函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">h函数底层，createVNode</span><br><span class="line">h函数接收三个参数</span><br><span class="line">type：元素类型</span><br><span class="line">propsOrChildren：数据对象，表示props，attrs，dom props，class和style</span><br><span class="line">chilren：子节点</span><br><span class="line"></span><br><span class="line">h(&#x27;div&#x27;)</span><br><span class="line">h(&#x27;div&#x27;,&#123; id:&#x27;foo&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">h(&#x27;div&#x27;,&#123;class:&#x27;foo&#x27;,innerHTML:&#x27;foo&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">const div = h(...) //创建，但是并未渲染到页面</span><br><span class="line">render(div,document.body) //渲染插入body</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">    text:string</span><br><span class="line">&#125;</span><br><span class="line">const btn =  (props:Props,ctx:any) =&gt; &#123;</span><br><span class="line">    return h(&#x27;div&#x27;,&#123;</span><br><span class="line">        class:[&#x27;&#x27;],</span><br><span class="line">        onClick:()=&gt;&#123;</span><br><span class="line">ctx.emit(&#x27;on-click&#x27;,&#x27;123&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue3开发Electron桌面程序"><a href="#vue3开发Electron桌面程序" class="headerlink" title="vue3开发Electron桌面程序"></a>vue3开发Electron桌面程序</h4><p><img src="https://s1.ax1x.com/2022/08/28/vWGju6.png"></p><h4 id="响应性语法糖"><a href="#响应性语法糖" class="headerlink" title="响应性语法糖"></a>响应性语法糖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都是实验性产物，想使用需要自己开启</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/28/vWJpUe.png"></p><h4 id="配置用户代码片段"><a href="#配置用户代码片段" class="headerlink" title="配置用户代码片段"></a>配置用户代码片段</h4><p>有个小妙招，可以自定义快捷代码片段<br>输入v3可以快速生成vue3代码片段模板<br>vscode点击左下角配置代码片段，搜索vue3，如果没有就新建一个，百度一下模板很多</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">天天去别人博客扒图的我 //555</span><br><span class="line">vite的话需要打印import.meta.env.得到环境变量相关信息</span><br><span class="line">之前是打印的process,env...</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/28/vWNyq0.png"></p><h4 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">替代vuex</span><br><span class="line">完整ts支持</span><br><span class="line">轻量，压缩体积只有1kb左右</span><br><span class="line">去除mutation</span><br><span class="line">actions支持同步和异步</span><br><span class="line">npm install pinia -D --save</span><br><span class="line"></span><br><span class="line">main.ts</span><br><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27; //2和3版本不一样</span><br><span class="line">const store = createStore()</span><br><span class="line">app.use(store)</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">新建store文件夹</span><br><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line">export const Test = defineStore(&#x27;id&#x27;,&#123;</span><br><span class="line">    state:()=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            current:1,</span><br><span class="line">            name:&#x27;hao&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 类似computed,具有缓存</span><br><span class="line">    getters:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    // 类似methods,同步异步都可以做</span><br><span class="line">    actions:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入页面使用</span><br><span class="line">import &#123; Test &#125; from &#x27;...&#x27;</span><br><span class="line">const test = Test()</span><br><span class="line">&lt;div&gt;&#123;&#123; test.name &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改state方式</span><br><span class="line">1：可以在页面直接</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    text.name = &#x27;xu&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2：通过pinia</span><br><span class="line">@click = ()=&gt; &#123;</span><br><span class="line">    Test.$patch(&#123;</span><br><span class="line">        current:2,</span><br><span class="line">        name:&#x27;xu&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3：依旧是patch</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    Test.$patch((state)=&gt;&#123;</span><br><span class="line">        state.current = 3</span><br><span class="line">        state.name = &#x27;xu&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4：弊端，直接覆盖，必须修改整个对象</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    Test.$state = &#123;</span><br><span class="line">        current:4,</span><br><span class="line">        name:&#x27;ye&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5：action</span><br><span class="line">actions:&#123;</span><br><span class="line">    setCurrent(params)&#123;</span><br><span class="line">        this.current = 999 || params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    Test.setCurrent(//也可以传参123)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解构store</span><br><span class="line">const  &#123; current,name &#125; = Test</span><br><span class="line">和reactive是一样的，解构失去响应式</span><br><span class="line"></span><br><span class="line">解决方式</span><br><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line">const  &#123; current,name &#125; = storeToRefs(Test)</span><br><span class="line"></span><br><span class="line">源码是先将数据转换成toRaw</span><br><span class="line">再判断赋予响应</span><br><span class="line"></span><br><span class="line">getters和actions</span><br><span class="line">actions支持同步和异步，可以相互调用</span><br><span class="line"></span><br><span class="line">getters：&#123;</span><br><span class="line">    newName():string&#123;</span><br><span class="line">return `$-$&#123;this.name&#125;`</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他api</span><br><span class="line">Test.$reset()</span><br><span class="line">订阅state改变Test.$subscribe((args,state)=&gt;&#123;console.log(args,state)&#125;,&#123;detached:true,deep:true,flush:&quot;post&quot;&#125;)</span><br><span class="line">订阅action的调用Test.$onAction((args)=&gt;&#123;console.log(args)&#125;,true)</span><br><span class="line">见下方图</span><br><span class="line"></span><br><span class="line">持久化插件</span><br><span class="line">vuex和pinia刷新都会丢失数据</span><br><span class="line">const store = createStore()</span><br><span class="line">const setStorage = (key:string,value:any) =&gt; &#123;</span><br><span class="line">    localStorage.setItem(key,JSON.stringify(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getStorage = (key:string) =&gt; &#123;</span><br><span class="line">    localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key) as string) : &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typr Option = &#123;</span><br><span class="line">    key?:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const defaultPiniaKey:string = &#x27;hao&#x27;</span><br><span class="line"></span><br><span class="line">const piniaPlugin = (options:Option) =&gt; &#123;</span><br><span class="line">   return  (context:PiniaPluginContext) =&gt; &#123;</span><br><span class="line">    const &#123; store &#125; = context</span><br><span class="line">    const data = getStorage(`$&#123;options?.key ?? defaultPiniaKey&#125;-$&#123;store.$id&#125;`)</span><br><span class="line">    store.$subscribe((args,state)=&gt;&#123;</span><br><span class="line">        setStorage(`$&#123;options?.key ?? defaultPiniaKey&#125;-$&#123;store.$id&#125;`,toRaw(store.$state))</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">        ...data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.use(piniaPlugin(&#123;</span><br><span class="line">    key:&#x27;pinia&#x27;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/28/vWgrhn.png"></p><h4 id="穿插的可视化项目"><a href="#穿插的可视化项目" class="headerlink" title="穿插的可视化项目"></a>穿插的可视化项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="摸鱼神器JSON2TS插件"><a href="#摸鱼神器JSON2TS插件" class="headerlink" title="摸鱼神器JSON2TS插件"></a>摸鱼神器JSON2TS插件</h4><p>自动生成ts</p><p>新建一个json文件</p><p>将返回的数据粘贴里面</p><p>滑动至json文件底部 ctrl +alt + v</p><h4 id="Router路由"><a href="#Router路由" class="headerlink" title="Router路由"></a>Router路由</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">npm init vue#latest</span><br><span class="line">npm init vite@latest //该方式创建时没有router选项</span><br><span class="line">npm install vue-router -s</span><br><span class="line"></span><br><span class="line">router/index.ts</span><br><span class="line">import &#123; createRouter,createWebhistory ,RouteRecordRaw&#125; from &#x27;vue-router&#x27;</span><br><span class="line">const routes:Array&lt;RouteRecordRaw&gt; = [&#123;</span><br><span class="line">    path:&#x27;/login&#x27;,</span><br><span class="line">    component:Login | () =&gt; import(&#x27;./Login.vue&#x27;)</span><br><span class="line">&#125;]</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history:createWebhistory(),</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line">main.ts</span><br><span class="line">import router from &#x27;..&#x27;</span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">app.vue</span><br><span class="line">router-view</span><br><span class="line">router-link to=&quot;/login&quot;</span><br><span class="line"></span><br><span class="line">路由模式的变化</span><br><span class="line">vue2 mode =&gt; vue3 mode</span><br><span class="line">hash =&gt; createHashHistory</span><br><span class="line">history =&gt; createWebHistory</span><br><span class="line">abstract =&gt; createMemoryHistory</span><br><span class="line"></span><br><span class="line">hash模式实现原理是location.hash</span><br><span class="line">location.hash = &#x27;/login&#x27;</span><br><span class="line">监听左右箭头前进和回退</span><br><span class="line">window.addEventListener(&#x27;hashchange&#x27;,(e)=&gt;&#123;console.log(e)&#125;)//监听前进和回退</span><br><span class="line"></span><br><span class="line">history模式不带#，是基于h5的history实现的</span><br><span class="line">监听左右箭头</span><br><span class="line">window.addEventListener(&#x27;popstate&#x27;,(e)=&gt;&#123;console.log(e)&#125;)</span><br><span class="line"></span><br><span class="line">跳转方式</span><br><span class="line">history.pushState(&#123;&#125;,&#x27;&#x27;,&#x27;/login&#x27;)</span><br><span class="line"></span><br><span class="line">编程式导航</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;&#x27;,</span><br><span class="line">    name:&#x27;Login&#x27;,</span><br><span class="line">    component:&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">router-link to=&quot;path&quot;</span><br><span class="line">router-link :to=&quot;&#123;name:&#x27;Login&#x27;&#125;&quot;</span><br><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line">const router = useRouter()</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    router.push(&#x27;/login&#x27;)</span><br><span class="line">    router.push(&#123;</span><br><span class="line">        path:&#x27;/login&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">    router.push(&#123;</span><br><span class="line">        name:&#x27;Login&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不保存历史记录</span><br><span class="line">router-link replace :to=&quot;&#123;name:&#x27;Login&#x27;&#125;&quot; //添加replace以后不保存历史记录</span><br><span class="line">@click = () =&gt; &#123;</span><br><span class="line">    router.replace(&#x27;/login&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">前进和后退</span><br><span class="line">router.go(1) //前进</span><br><span class="line">router.back(1) //后退</span><br><span class="line"></span><br><span class="line">路由传参</span><br><span class="line">新的和json2TS差不多的插件=》 json to ts</span><br><span class="line">ctrl + shift + alt + s</span><br><span class="line"></span><br><span class="line">@click = (obj) =&gt; &#123;</span><br><span class="line">    router.push(&#x27;/login&#x27;)</span><br><span class="line">    router.push(&#123;</span><br><span class="line">        path:&#x27;/login&#x27;,</span><br><span class="line">        query:obj //query只能接收对象</span><br><span class="line">    &#125;)</span><br><span class="line">    router.push(&#123;</span><br><span class="line">        name:&#x27;Login&#x27;,</span><br><span class="line">        params:&#123;&#125; //地址栏不会显示传参信息，params参数存在内存中，因此刷新页面参数会丢失</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在跳转的页面获取传值</span><br><span class="line">import &#123; useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class="line">const route = useRoute()</span><br><span class="line">route.params</span><br><span class="line">route.query</span><br><span class="line"></span><br><span class="line">动态路由传参</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/login/:id&#x27;,</span><br><span class="line">    name:&#x27;Login&#x27;,</span><br><span class="line">    component:&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">router.push(&#123;</span><br><span class="line">        name:&#x27;Login&#x27;,</span><br><span class="line">        params:&#123;</span><br><span class="line">            id:item.id //和路径后动态的参数名要相同</span><br><span class="line">        &#125; //地址栏不会显示传参信息，params参数存在内存中，因此刷新页面参数会丢失</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> 嵌套路由</span><br><span class="line"> &#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    name:&#x27;Home&#x27;,</span><br><span class="line">    component:Home,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        path:&#x27;/login&#x27;,  //最后的跳转路径 /home/login</span><br><span class="line">        name:&#x27;Login&#x27;,</span><br><span class="line">        component:Login,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">命名视图</span><br><span class="line">命名视图可以在同一级/同一个组件中展示更多的路由视图，而不是嵌套展示，命名视图可以让一个组件中具有多个路由渲染出口。对于一些固定布局的组件非常有用，类似具名插槽，视图默认名称也是default</span><br><span class="line">一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    name:&#x27;Home&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        default:()=&gt;import(Home),</span><br><span class="line">        header:()=&gt;import(Header),</span><br><span class="line">        content:()=&gt;import(Content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用时</span><br><span class="line">router-view </span><br><span class="line">router-view name=&quot;header&quot;</span><br><span class="line">router-view name=&quot;content&quot;</span><br><span class="line"></span><br><span class="line">路由重定向，路由别名</span><br><span class="line">重定向方式1：字符串形式</span><br><span class="line"> &#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    name:&#x27;Home&#x27;,</span><br><span class="line">    component:Home,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        path:&#x27;/login&#x27;,  //最后的跳转路径 /home/login</span><br><span class="line">        name:&#x27;Login&#x27;,</span><br><span class="line">        component:Login,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    path:&#x27;/&#x27;,</span><br><span class="line">    redirect:&quot;/home&quot;, //重定向</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重定向方式2：对象形式</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/&#x27;,</span><br><span class="line">    redirect:&#123;</span><br><span class="line">        path:&#x27;/home&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重定向方式2：回调函数形式</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/&#x27;,</span><br><span class="line">    redirect: (to) =&gt; &#123;</span><br><span class="line">        return &#x27;/home&#x27;</span><br><span class="line">        return &#123;</span><br><span class="line">            path:&#x27;/home&#x27;,</span><br><span class="line">            params:&#123;</span><br><span class="line">                name:&#x27;hao&#x27; //传参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">路由别名alias</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    component:Home,</span><br><span class="line">    alias:[&#x27;/red&#x27;,&#x27;/green&#x27;,&#x27;/blue&#x27;] // 无论访问哪个路由，都是/home</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">导航守卫</span><br><span class="line">全局前置守卫</span><br><span class="line">router.beforeEach((to,next,from)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">后置守卫</span><br><span class="line">router.afterEach((to,next,from)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">导航进度条，设置动画</span><br><span class="line">window.requestAnimationFrame()</span><br><span class="line">window.cancelAnimationFrame()</span><br><span class="line"></span><br><span class="line">路由元信息</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    component:Home,</span><br><span class="line">    meta:&#123;</span><br><span class="line">        title:&#x27;首页&#x27;, //页面标题</span><br><span class="line">        nedd:true //是否需要权限</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用</span><br><span class="line">守卫中</span><br><span class="line">console.log(to) //to中包含meta</span><br><span class="line"></span><br><span class="line">路由过渡动效/copy的小满大佬文章</span><br><span class="line">想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 v-slot API：</span><br><span class="line">    &lt;router-view #default=&quot;&#123;route,Component&#125;&quot;&gt;</span><br><span class="line">        &lt;transition  :enter-active-class=&quot;`animate__animated $&#123;route.meta.transition&#125;`&quot;&gt;</span><br><span class="line">            &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;</span><br><span class="line">        &lt;/transition&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息和动态的 name 结合在一起，放在&lt;transition&gt; 上： </span><br><span class="line"></span><br><span class="line">declare module &#x27;vue-router&#x27;&#123;</span><br><span class="line">     interface RouteMeta &#123;</span><br><span class="line">        title:string,</span><br><span class="line">        transition:string,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(import.meta.env.BASE_URL),</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;@/views/Login.vue&#x27;),</span><br><span class="line">      meta:&#123;</span><br><span class="line">         title:&quot;登录页面&quot;,</span><br><span class="line">         transition:&quot;animate__fadeInUp&quot;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/index&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;@/views/Index.vue&#x27;),</span><br><span class="line">      meta:&#123;</span><br><span class="line">         title:&quot;首页！！！&quot;,</span><br><span class="line">         transition:&quot;animate__bounceIn&quot;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">滚动行为</span><br><span class="line">使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。vue-router 可以自定义路由切换时页面如何滚动。</span><br><span class="line"></span><br><span class="line">当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法</span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  scrollBehavior: (to, from, savePosition) =&gt; &#123;</span><br><span class="line">  记录上个页面滚动至的位置，返回依旧处于那个位置</span><br><span class="line">  if(savePosition)&#123;</span><br><span class="line">        return savePosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            top:0</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  或者</span><br><span class="line">    console.log(to, &#x27;==============&gt;&#x27;, savePosition);</span><br><span class="line">    return new Promise((r) =&gt; &#123; //支持异步</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        r(&#123;</span><br><span class="line">          top: 10000</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</span><br><span class="line"></span><br><span class="line">scrollBehavior 返回滚动位置的对象信息，长这样：</span><br><span class="line"></span><br><span class="line">&#123; left: number, top: number &#125;</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  scrollBehavior: (to, from, savePosition) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">       top:200</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态路由</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/29/vfd5jJ.png"></p><p>暂时到这里了，后面复习一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3&quot;&gt;&lt;a href=&quot;#vue3&quot; class=&quot;headerlink&quot; title=&quot;vue3&quot;&gt;&lt;/a&gt;vue3&lt;/h2&gt;&lt;p&gt;从前实习做的项目和自己做的项目基本上都是vue2版本&lt;/p&gt;
&lt;p&gt;到目前，vue3版本已经很成熟了，很多公司也都开始使用上</summary>
      
    
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://222cabbage.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>webgl入一下门</title>
    <link href="https://222cabbage.github.io/2022/08/25/webgl1/"/>
    <id>https://222cabbage.github.io/2022/08/25/webgl1/</id>
    <published>2022-08-25T04:12:33.000Z</published>
    <updated>2022-08-25T05:16:53.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webGL入门"><a href="#webGL入门" class="headerlink" title="webGL入门"></a>webGL入门</h2><p>webGL是openGL的子集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const canvas = document.querySelector(&#x27;canvas&#x27;)</span><br><span class="line">const gl = canvas.getContext(&#x27;webgl&#x27;)</span><br></pre></td></tr></table></figure><p>老的浏览器</p><p><img src="https://s1.ax1x.com/2022/08/25/vgI1hj.png"></p><p>。。。先暂停一下，涉及到知识盲区了，得先去恶补一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webGL入门&quot;&gt;&lt;a href=&quot;#webGL入门&quot; class=&quot;headerlink&quot; title=&quot;webGL入门&quot;&gt;&lt;/a&gt;webGL入门&lt;/h2&gt;&lt;p&gt;webGL是openGL的子集&lt;/p&gt;
&lt;figure class=&quot;highlight plain</summary>
      
    
    
    
    <category term="webGL" scheme="https://222cabbage.github.io/categories/webGL/"/>
    
    
    <category term="webGL" scheme="https://222cabbage.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>vite入门</title>
    <link href="https://222cabbage.github.io/2022/08/24/vite1/"/>
    <id>https://222cabbage.github.io/2022/08/24/vite1/</id>
    <published>2022-08-24T13:22:57.000Z</published>
    <updated>2022-08-25T04:11:27.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vite入门"><a href="#Vite入门" class="headerlink" title="Vite入门"></a>Vite入门</h2><p>为什么需要工程化？</p><p>太多的资源文件，高级语法，优化代码体积，提升代码效率，热更新</p><p>提供模块加载方案，兼容不同模块规范</p><p>高级语法转译，如sass，ts。资源加载，图片，字体，worker</p><p>产物压缩，无用代码剔除，对不支持高级语法的浏览器等平台进行语法降级</p><p>热更新</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>No-bundle开发服务，源文件无需打包</p><p>生产环境基于Rollup的Bundler</p><p>高性能，dev启动速度和热更新速度非常快</p><p>相比于webpack配置简单易用，开发体验好</p><h4 id="传统构建工具缺点："><a href="#传统构建工具缺点：" class="headerlink" title="传统构建工具缺点："></a>传统构建工具缺点：</h4><p>编译慢，热更新慢</p><p>瓶颈；bundle带来的性能开销，js语言本身的性能瓶颈</p><h4 id="vite："><a href="#vite：" class="headerlink" title="vite："></a>vite：</h4><p>基于原生js的ESM，浏览器无需打包源代码，祛除了bundle的性能开销，天然的按需加载，可以利用文件级的浏览器缓存</p><p>深度使用esbuild</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i pnpm -g</span><br><span class="line">pnpm create vite // 根据项目进行条件选择</span><br><span class="line">pnpm i // 下载依赖</span><br><span class="line">pnpm run dev</span><br><span class="line">pnpm i  sass -D</span><br><span class="line">其他配置</span><br><span class="line">tree shaking在vite中默认开启</span><br></pre></td></tr></table></figure><h4 id="为什么要进行预打包？"><a href="#为什么要进行预打包？" class="headerlink" title="为什么要进行预打包？"></a>为什么要进行预打包？</h4><p>避免node_modules过多文件请求</p><p>将commonjs转换为ESM格式</p><h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>服务启动前检查项目依赖</p><p>用esbuild对依赖代码进行预打包</p><p>改写import语句，指定依赖为预构建产物路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">改写前</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">改写后</span><br><span class="line">import React from &#x27;./node_modules/.vite/react.js&#x27;</span><br><span class="line">关键技术：单文件编译使用esbuild完成</span><br><span class="line">局限性：不支持类型检查，不支持语法降级到es5，最低es6，因此在生产环境需要调用tsc</span><br><span class="line">关键技术：代码压缩</span><br><span class="line">关键技术：插件机制</span><br><span class="line">开发阶段 =&gt; 模拟rollup插件机制</span><br><span class="line">生产阶段 =&gt; 直接使用rollup</span><br><span class="line">注：不是所有rollup插件都能兼容vite</span><br></pre></td></tr></table></figure><h4 id="vite后续学习路线："><a href="#vite后续学习路线：" class="headerlink" title="vite后续学习路线："></a>vite后续学习路线：</h4><p>esbuild，rollup：可以去看官方文档，编写的很好</p><p>先尝试基础的配置</p><p>再进阶插件开发</p><h4 id="为什么需要插件机制"><a href="#为什么需要插件机制" class="headerlink" title="为什么需要插件机制"></a>为什么需要插件机制</h4><h4 id="vite钩子："><a href="#vite钩子：" class="headerlink" title="vite钩子："></a>vite钩子：</h4><p><img src="https://s1.ax1x.com/2022/08/25/vg46i9.png"></p><h4 id="插件的配置和使用demo"><a href="#插件的配置和使用demo" class="headerlink" title="插件的配置和使用demo"></a>插件的配置和使用demo</h4><p><img src="https://s1.ax1x.com/2022/08/25/vg4qzt.png"></p><h4 id="代码拆包"><a href="#代码拆包" class="headerlink" title="代码拆包"></a>代码拆包</h4><p>……</p><h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><p>js语法标准繁多，浏览器支持程度不同，将高级语法降级</p><p>原理：将代码转换为高级语法抽象语法树，再转换为低级语法抽象树，再通过babel的generator转换为代码</p><p><img src="https://s1.ax1x.com/2022/08/25/vg5MWR.png"></p><h4 id="语法安全降级解决方案："><a href="#语法安全降级解决方案：" class="headerlink" title="语法安全降级解决方案："></a>语法安全降级解决方案：</h4><p>vite上层解决方案：@vitejs&#x2F;plugin-legacy</p><p>底层原理：借助babel进行语法降级，提前注入Polyfill实现，如core-js，regeneraator-runtime</p><h4 id="服务端渲染SSR"><a href="#服务端渲染SSR" class="headerlink" title="服务端渲染SSR"></a>服务端渲染SSR</h4><p><img src="https://s1.ax1x.com/2022/08/25/vg5UFH.png"></p><p>未完待续……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vite入门&quot;&gt;&lt;a href=&quot;#Vite入门&quot; class=&quot;headerlink&quot; title=&quot;Vite入门&quot;&gt;&lt;/a&gt;Vite入门&lt;/h2&gt;&lt;p&gt;为什么需要工程化？&lt;/p&gt;
&lt;p&gt;太多的资源文件，高级语法，优化代码体积，提升代码效率，热更新&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="vite" scheme="https://222cabbage.github.io/categories/vite/"/>
    
    
    <category term="vite" scheme="https://222cabbage.github.io/tags/vite/"/>
    
  </entry>
  
  <entry>
    <title>接触一下ts</title>
    <link href="https://222cabbage.github.io/2022/07/10/tsstudy1/"/>
    <id>https://222cabbage.github.io/2022/07/10/tsstudy1/</id>
    <published>2022-07-10T03:11:20.000Z</published>
    <updated>2022-10-07T05:40:49.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习TS"><a href="#学习TS" class="headerlink" title="学习TS"></a>学习TS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先全或者在对应文件夹下npm install typeescript -g  / -D</span><br><span class="line">tsc init 生成ts配置文件</span><br><span class="line">outDir输出目录</span><br><span class="line">rootDir代码根目录</span><br><span class="line">tsc 打包</span><br><span class="line"></span><br><span class="line">安装ts-node可以直接运行ts代码，无序将ts编译成js、</span><br><span class="line">npm install ts-node -D</span><br><span class="line">安装nodemon可以自动检测目录中文件改动后自动重新启动</span><br><span class="line">npm install nodemon -D</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/07/10/js8xzV.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;</span><br><span class="line">&#125;,</span><br><span class="line">监听src文件夹下后缀名为ts的文件变化，一有变化就重新执行index.ts文件</span><br><span class="line"></span><br><span class="line">parcle打包运行</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon --watch src/ -e ts --exec ts-node ./src/index.ts&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;parcel ./index.html&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类是拥有相同属性和方法的集合，有静态特征和动态特征</span><br><span class="line">静态特征：属性，姓名属性</span><br><span class="line">动态特征：方法，吃饭走路</span><br><span class="line"></span><br><span class="line">创建类的过程</span><br><span class="line">1：在堆中开辟一块空间</span><br><span class="line">2：调用对应构造函数 new XXX() 匹配构造器constructor</span><br><span class="line">3：把对象赋值给对象变量/吧实例赋值给实例对象/改变this指向</span><br></pre></td></tr></table></figure><p>类的源码，底层，原生es5</p><p>转换为es5函数</p><h5 id="引用属性"><a href="#引用属性" class="headerlink" title="引用属性"></a>引用属性</h5><p>数组，函数，类，对象，对象数组，集合类set，map，自定义，集合类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">constructor中的参数本身需要通过this.xx = xx为属性赋值，括号纵只是参数</span><br><span class="line">但是如果添加了public等修饰符，就不用再赋值，会隐式操作挂载为属性</span><br><span class="line">constructor(name,age)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">添加public等修饰符后</span><br><span class="line">constructor(public name,public age)&#123;</span><br><span class="line">    不需要再赋值，隐式挂载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">不使用重载</span><br><span class="line">function(value: number | Message):Message | Array&lt;Message&gt; | undefined &#123;</span><br><span class="line">    if(typeof value === &#x27;number&#x27;)&#123;</span><br><span class="line">        return messages.find(item =&gt; item.id === value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return messages.filter(item =&gt; item.type === value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">联合类型中，方法属性会受到限制，会提取公用属性和方法，交集</span><br><span class="line">TS无法根据参数来推倒最终返回的类型中的数据类型</span><br><span class="line">只可以根据方法定义的类型来展现</span><br><span class="line"></span><br><span class="line">使用重载</span><br><span class="line">函数重载规则</span><br><span class="line">函数签名 = 函数名 + 函数参数 + 函数参数类型 + 返回值类型，不包括函数体</span><br><span class="line">函数重载定义</span><br><span class="line">由一个实现签名或者多个实现签名组成</span><br><span class="line">外部调用时，只能调用重载签名，不能调用实现签名</span><br><span class="line">调用重载函数时，会根据传递的参数来判断你调用的是哪一个函数</span><br><span class="line">只有一个函数体，只有实现签名配备了函数体</span><br><span class="line">function getMessage(id:number):number</span><br><span class="line">function getmessage(message:Message):Array&lt;Message&gt;</span><br><span class="line">function getMessage(value:any):number | Array&lt;Message&gt; | undefined &#123;</span><br><span class="line">    if(typeof value === &#x27;number&#x27;)&#123;</span><br><span class="line">        return messages.find(item =&gt; item.id === value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return messages.filter(item =&gt; item.type === value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有利于功能扩展</span><br><span class="line">任何类型都是unknown的子类型</span><br><span class="line">何时用any，何时用unknown</span><br><span class="line">unknown只能作为父类，不能作为子类</span><br><span class="line">let x:unknown = 3</span><br><span class="line">let z:number = x</span><br></pre></td></tr></table></figure><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">规则与函数重载相同，有细小区别</span><br><span class="line">方法是特定情境下的函数，由对象变量/实例变量直接调用的函数都是方法</span><br><span class="line">let p = new P()</span><br><span class="line">p.sendMessage()//方法</span><br><span class="line">方法签名 = 方法名称 + 方法参数 + 方法参数类型 + 方法返回值类型</span><br></pre></td></tr></table></figure><p>在new时，会隐式的将this返回给左边的对象变量。this和等号左边变量都指向当前正创建的对象</p><h5 id="重载应用，求图形面积"><a href="#重载应用，求图形面积" class="headerlink" title="重载应用，求图形面积"></a>重载应用，求图形面积</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type type_s = &#123;</span><br><span class="line">    width:number,</span><br><span class="line">    height:number,</span><br><span class="line">    radious?:number</span><br><span class="line">&#125;</span><br><span class="line"> class Square &#123;</span><br><span class="line">     public width:number</span><br><span class="line">     public height:number</span><br><span class="line">     constructor(width:number,height:number) // 重载签名</span><br><span class="line">     constructor(type:type_s) // 重载签名</span><br><span class="line">     constructor(value:any,height?:number)&#123;</span><br><span class="line">        this.width = value</span><br><span class="line">        this.height = height</span><br><span class="line">        if(typeof value === &#x27;object&#x27;)&#123;</span><br><span class="line">            let &#123; width,height &#125; = value</span><br><span class="line">            this.width = width</span><br><span class="line">            this.height = height</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.width = value</span><br><span class="line">            this.height = height</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public getArea()&#123;</span><br><span class="line">         return this.width * this.height</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let s = new Square(30,40)</span><br><span class="line"> let s2 = new Square(&#123;width:20,height:30&#125;)</span><br></pre></td></tr></table></figure><h5 id="单件设计模式"><a href="#单件设计模式" class="headerlink" title="单件设计模式"></a>单件设计模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">单件设计模式概述</span><br><span class="line">一个类对外有且仅有一个实例</span><br><span class="line">如果一个类对外只提供一个对象类，并且在该类的内部提供了一个外部可以访问该对象的属性和方法</span><br><span class="line">通过静态方法访问</span><br><span class="line">public static getXXX()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">静态方法和对象无关，外部变量无法访问静态方法和属性，可以通过类名调用</span><br><span class="line">静态方法和原型方法/对象方法是不同的，互相都不能访问</span><br><span class="line">一个静态方法改变了某个静态属性，其他静态方法或者外部任何地方访问这个属性都会改变</span><br><span class="line">除了栈，堆之外，还有静态内存区</span><br><span class="line">静态成员保存在内存的静态区，静态成员的内存分配要早于对象空间的分配，也就是对象创建之前，Ts就已经为静态成员分配好了空间，一个静态方法分配一个空间，只要服务器电脑不重启，静态方法就一直保存在内存空间，无论调用多少次，访问的都是同一片空间</span><br><span class="line">export default class MyLocal&#123;</span><br><span class="line">// 饿汉式 直接先创建</span><br><span class="line">    static localStorage:MyLocal = new MyLocal（）</span><br><span class="line">    private constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 给外部提供访问内部对象的方法</span><br><span class="line">    public static getConstructor()&#123;</span><br><span class="line">    // 懒汉式 调用方法才创建</span><br><span class="line">        if(!this.localStorage)&#123;</span><br><span class="line">            this.localStorage = new MyLocal()</span><br><span class="line">        &#125;</span><br><span class="line">        return this.localStorage</span><br><span class="line">    &#125;</span><br><span class="line">    public static setItem(key:string,value:any)&#123;</span><br><span class="line">        localStorage.setItem(key,JSON.stringify(value))</span><br><span class="line">    &#125;</span><br><span class="line">    public getItem(key:string)&#123;</span><br><span class="line">        let value = localStorage.getItem(key)</span><br><span class="line">        return value != null ? JSON.parse(value) : null</span><br><span class="line">    &#125;</span><br><span class="line">    public removeItem(key:string)&#123;</span><br><span class="line">        localStorage.removeItem(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123; MyLocal &#125; from &#x27;./MyLoacl.js&#x27;</span><br><span class="line">MyLocal.getConstructor()</span><br><span class="line"></span><br><span class="line">什么情况适合采用单件模式。较多复用的内容，后续多使用，方法类，对象属性并不多，创建实例意义不大</span><br></pre></td></tr></table></figure><h5 id="继承Loading学习到5-5先跳过"><a href="#继承Loading学习到5-5先跳过" class="headerlink" title="继承Loading学习到5-5先跳过"></a>继承Loading学习到5-5先跳过</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 类型断言，类型转换</span><br><span class="line">// a数据类型 as b数据类型 </span><br><span class="line">// a和b必须要有交叠 </span><br><span class="line">// 判断交叠的条件</span><br><span class="line"></span><br><span class="line">// 场景1 a和b都是类并且是父子继承关系 通常是将父类类型转换为子类类型</span><br><span class="line">// class Father &#123;</span><br><span class="line">//     public name:string</span><br><span class="line">// &#125;</span><br><span class="line">// class Son extends Father&#123;</span><br><span class="line">//     study()&#123;</span><br><span class="line"></span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// let fat = new Father()</span><br><span class="line">// let res = fat as Son 将father类型转换为son类型</span><br><span class="line">// 什么是类型转换</span><br><span class="line">// let res = &lt;Son&gt;fat</span><br><span class="line">// res.</span><br><span class="line">// let son = new Son()</span><br><span class="line">// let res2 = son as Father</span><br><span class="line">// res2.</span><br><span class="line">// new 的底层发生了什么</span><br><span class="line"></span><br><span class="line">// 场景2 ab都是类 但是没有继承关系 转换后的类型必须包含转换前的类型的所有属性 转换之前的属性是转换之后的子集</span><br><span class="line">// class A &#123;</span><br><span class="line">//     public name:string</span><br><span class="line">// &#125;</span><br><span class="line">// class B &#123;</span><br><span class="line">//     public name:string</span><br><span class="line">//     public age:number</span><br><span class="line">// &#125;</span><br><span class="line">// let a = new A()</span><br><span class="line">// let res = a as B</span><br><span class="line">// let b = new B()</span><br><span class="line"></span><br><span class="line">// 场景3 A是类，b是接口，A类实现了B接口 implements</span><br><span class="line">// interface B &#123;</span><br><span class="line">//     username:string,</span><br><span class="line">//     age:number</span><br><span class="line">// &#125;</span><br><span class="line">// class A implements B &#123;</span><br><span class="line">//     public username: string</span><br><span class="line">//     public age: number</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 场景4 A是类 B是接口 A类没有实现B接口</span><br><span class="line"></span><br><span class="line">// 场景5 A是类 B是type定义的类型</span><br><span class="line">// type B  = &#123;</span><br><span class="line">//     username:string,</span><br><span class="line">//     age:number</span><br><span class="line">// &#125;</span><br><span class="line">// class A implements B &#123;</span><br><span class="line">//     public username: string</span><br><span class="line">//     public age: number</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 场景6 A是类 B是type定义的类型 A没有实现B定义的数据类型</span><br><span class="line">// type B  = &#123;</span><br><span class="line">//     username:string,</span><br><span class="line">//     age:number</span><br><span class="line">// &#125;</span><br><span class="line">// class A  &#123;</span><br><span class="line">//     public username: string</span><br><span class="line">//     public age: number</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 场景7 A是一个函数上参数的联合类型变量</span><br><span class="line">// function SS(name:string | number)&#123;</span><br><span class="line">//     let num = name as number + 3</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 场景8 多个类组成的联合类型如何断言</span><br><span class="line">// let a:A | B | C</span><br><span class="line">// a as A</span><br><span class="line">// a as B</span><br><span class="line">// a as C</span><br><span class="line"></span><br><span class="line">// 场景9 转换为any或者unknown类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">类型守卫需要了解一下new 的过程</span><br><span class="line">class Person &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">&#125;</span><br><span class="line">let per = new Person()</span><br><span class="line"></span><br><span class="line">1：创建一个obj对象</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">2：使创建对象的__proto__指向构造函数/类的prototype</span><br><span class="line">obj.__proto = Person.prototype</span><br><span class="line">3：借用构造函数/类的apply为obj对象添加name与age属性</span><br><span class="line">Person.apply(obj,[&quot;1232&quot;,123])</span><br><span class="line"></span><br><span class="line">类型守卫</span><br><span class="line">在词句的块级作用域内，if语句内或者条目运算符表达式以内，缩小变量类型的一种类型推断的行为</span><br><span class="line">类型守卫产生时机 获得更精准的变量类型，减少不必要的类型断言</span><br><span class="line">类型判断 typeof</span><br><span class="line">属性或方法判断 in 判断属性或者方法是不是在该对象中 &quot;name&quot; in obj     &quot;getname&quot; in obj</span><br><span class="line">实例判断 instanceof</span><br><span class="line">字面量相等判断 == === != !==</span><br><span class="line"></span><br><span class="line">typeof 局限性</span><br><span class="line">检测范围 string | number | bigint | boolean | symbol | undefined | object | function</span><br><span class="line">检测变量并不完全准确</span><br><span class="line">typeof null 结果为object</span><br><span class="line">typeof [] 结果为object</span><br><span class="line"></span><br><span class="line">typeof替代方案</span><br><span class="line">Object.prototype.toString.call(检测对象)</span><br><span class="line">仍然无法解决自定义函数类，使用instanceof</span><br><span class="line"></span><br><span class="line">instanceof</span><br><span class="line">a instanceof b 可用于原型链继承关系 子类 instanceof 父类 左边是否是右边的实例对象 会一直在左边的实例对象的__proto__一直查找到Object的prototype空间</span><br><span class="line"></span><br><span class="line">instanceof应用场景</span><br><span class="line">class car &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Bus &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">car 和 Bus类中各自包含一个求总价的方法</span><br><span class="line">class GetTotal &#123;</span><br><span class="line">    returnTotal(cartype:car | Bus)&#123;</span><br><span class="line">        if(cartype instanceof car)&#123;</span><br><span class="line">            return car.total()</span><br><span class="line">        &#125; else if(cartype instanceof Bus)&#123;</span><br><span class="line">            return Bus.total()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">根据不同车类型返回价格</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="自定义守卫"><a href="#自定义守卫" class="headerlink" title="自定义守卫"></a>自定义守卫</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">自定义守卫</span><br><span class="line">格式</span><br><span class="line">function 函数名 （形参：参数类型/大多为any）：形参 is A类型 = boolean + 类型守卫能力&#123;</span><br><span class="line">    return true / false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isString(str:any):str is string&#123;</span><br><span class="line">    return typeof str === &#x27;string&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isFunc(str:any):str is Function&#123;</span><br><span class="line">    return typeof str === &#x27;function&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">抽象类</span><br><span class="line">一个在任何位置都不能实例化的类就是一个抽象类，实例化无意义的类</span><br><span class="line">包含0个或多个带有方法体的方法和不带有方法体的抽象方法</span><br><span class="line">父类的抽象方法会在子类强制实现</span><br><span class="line">abstract class A &#123;</span><br><span class="line">    public name:string</span><br><span class="line">    public eat()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   public abstract run():void</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public run(): void &#123;</span><br><span class="line">        console.log(&#x27;1232&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a =  new A() // 抽象类无法实例化</span><br><span class="line"></span><br><span class="line">抽象类扩大，适配器</span><br><span class="line">后端称为适配器adapter</span><br><span class="line">export &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">多态</span><br><span class="line">定义：</span><br><span class="line">父类的对象变量可以接收任何一个子类的对象</span><br><span class="line">从而用这个父类的对象变量来调用子类中重写的方法而输出不同的结果</span><br><span class="line"></span><br><span class="line">产生条件：</span><br><span class="line">1：必须存在继承关系</span><br><span class="line">2：必须有方法重写</span><br><span class="line"></span><br><span class="line">利于项目拓展</span><br><span class="line"></span><br><span class="line">无法调用子类独有方法，必须结合instanceif类型守卫解决</span><br><span class="line">属性不必完全重叠，在继承的情况下</span><br><span class="line">class Father &#123;</span><br><span class="line">    name:string</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&#x27;父亲吃饭&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A extends Father&#123;</span><br><span class="line">    age:number</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&#x27;A&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends Father &#123;</span><br><span class="line">    address:string</span><br><span class="line">    eat(): void &#123;</span><br><span class="line">        console.log(&#x27;B&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fat:Father = new B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改写汽车返回价格</span><br><span class="line">class Fat &#123;</span><br><span class="line">    total()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class car extends Fat &#123;</span><br><span class="line">    total()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bus extends Fat &#123;</span><br><span class="line">    total()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    aaa()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">car 和 Bus类中各自包含一个求总价的方法</span><br><span class="line">class GetTotal &#123;</span><br><span class="line">    returnTotal(cartype: Fat)&#123;</span><br><span class="line">            return cartype.total() // 只能调用total方法 无法调用B类中独有的的aaa方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let gettotal = new GetTotal()</span><br><span class="line">let car = new car()</span><br><span class="line">let bus = new Bus()</span><br><span class="line">gettotal(car)</span><br><span class="line">gettotal(bus)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="新特性可变元祖"><a href="#新特性可变元祖" class="headerlink" title="新特性可变元祖"></a>新特性可变元祖</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr:[number,string,string,string] = [123,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br><span class="line">let arr2:[number,string,...any[]] = [123,&#x27;2&#x27;,123,&#x27;456&#x27;] </span><br><span class="line">let [username,age,...rest]:[username_:string,age_:number,...rest:any[]] = [&quot;123&quot;,123,&#x27;456&#x27;]</span><br><span class="line">let [username,age,...rest,desc]:[username_:string,age_:number,...rest:any[],desc_:string] = [&quot;123&quot;,123,&#x27;456&#x27;,&#x27;123&#x27;]</span><br></pre></td></tr></table></figure><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt;&#123;</span><br><span class="line">public List:Array&lt;T&gt;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.List = []</span><br><span class="line">    &#125;</span><br><span class="line">    add(element:T)&#123;</span><br><span class="line">        this.List.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let person = new Person&lt;string&gt;()</span><br><span class="line"></span><br><span class="line">泛型的参数可以使A-Z的任一大写字母，也可以是语义化的单词</span><br><span class="line"></span><br><span class="line">Object是所有类型的父类型，object只是对象类型</span><br></pre></td></tr></table></figure><h5 id="Object-object-unknown和any的区别"><a href="#Object-object-unknown和any的区别" class="headerlink" title="Object object unknown和any的区别"></a>Object object unknown和any的区别</h5><p>…….</p><h5 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">T extends object</span><br><span class="line">表示具体化的类型只能是object类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof obj能获得该对象的类型</span><br><span class="line">let obj = &#123;name:&#x27;&#x27;,age:2&#125;</span><br><span class="line">console.log(typeof obj) //&#123;name:string,age:number&#125;</span><br><span class="line"></span><br><span class="line">keyof K</span><br><span class="line">keyof表示获取一个类或者一个对象类型，或者一个接口类型的所有属性名组成的联合类型</span><br><span class="line">console.log(keyof 类型/也可以是类) //name | age 甚至可以获取到类上的方法名</span><br><span class="line">keyof typeof obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T extends keyof K</span><br><span class="line">T是K联合类型中的某一个或者全部联合类型</span><br><span class="line"></span><br><span class="line">let obj = &#123;name:&#x27;&#x27;,age:2&#125;</span><br><span class="line">type one = typeof obj //&#123;name:string,age:number&#125;</span><br><span class="line">type two = keyof one  // //name | age </span><br><span class="line">type objKeyType =  one[two] / type objKeyType =  one[&#x27;name&#x27;] //string || number 得到值的类型</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface List&lt;T&gt;&#123;</span><br><span class="line">    add(ele:T):void;</span><br><span class="line">    get(index:number):T;</span><br><span class="line">    size():number;</span><br><span class="line">    remove(value:T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&lt;T&gt; implements List &lt;T&gt;&#123;</span><br><span class="line">    public add()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let per = new Person&lt;&gt;()</span><br><span class="line"></span><br><span class="line">如果类型是any，会很麻烦，无法判断返回值原型对象所携带的方法，无法智提示</span><br><span class="line">一个父类数组对象变量里面的每一个元素都可以是任何一个该父类的子类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn&lt;T&gt;(arr:Array&lt;T&gt;):Array&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">泛型函数可以在调用返回后得到返回值的具体类型数据，从而可以有自动方法和属性的提示和错误编译提示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="泛型函数重载"><a href="#泛型函数重载" class="headerlink" title="泛型函数重载"></a>泛型函数重载</h5><p>分工明确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(data:string):string</span><br><span class="line">function fn&lt;T&gt;(data:T):T[]</span><br><span class="line">function fn(data:any):any&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型工厂函数"><a href="#泛型工厂函数" class="headerlink" title="泛型工厂函数"></a>泛型工厂函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">工厂函数类型定义</span><br><span class="line">代表所有类【等价JS的构造函数】的函数类型</span><br><span class="line">泛型工厂函数定义：一个可以创建任意类对象的通用函数</span><br><span class="line">使用场景：</span><br><span class="line">不方便或者没有办法直接new类名()格式来创建对象，在一些测试欧哲调试代码中简化代码使用</span><br><span class="line"></span><br><span class="line">通用函数类型</span><br><span class="line">type fn = （...args：any）=&gt; any</span><br><span class="line"></span><br><span class="line">interface fn &#123;</span><br><span class="line">    (..args:any):any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fnn:fn = () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let t = new Test() //在ts中不能直接new一个函数创建实例</span><br><span class="line"></span><br><span class="line">type fn = new (...args) =&gt; Student学生类</span><br><span class="line">type fn = new (...args) =&gt; Teacher老师类</span><br><span class="line"></span><br><span class="line">更加具备通用性</span><br><span class="line">type fn = new (...args) =&gt; any</span><br><span class="line"></span><br><span class="line">工厂函数</span><br><span class="line"></span><br><span class="line">泛型工厂函数</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">将多个类型合并【多个类型属性和方法的并集】成的类型就是交叉类型</span><br><span class="line"></span><br><span class="line">type1 = </span><br><span class="line">type2 = </span><br><span class="line">type3 = </span><br><span class="line">let obj:type1 &amp; type2 &amp; type3 = </span><br><span class="line">交叉类型可以获取两个类型的任意变量和方法，联合类型只能获取共有属性和方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">infer表示在extends条件语句中以占位符出现的用来修饰数据类型的关键字，被修饰的数据类型等到使用时才能被推断出来</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ts高级类型"><a href="#ts高级类型" class="headerlink" title="ts高级类型"></a>ts高级类型</h5><p>extract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>exclude</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>record</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>pick</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>partial</p><p>required</p><p>readonly</p><p>omit</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习TS&quot;&gt;&lt;a href=&quot;#学习TS&quot; class=&quot;headerlink&quot; title=&quot;学习TS&quot;&gt;&lt;/a&gt;学习TS&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="typescript" scheme="https://222cabbage.github.io/categories/typescript/"/>
    
    
    <category term="ts" scheme="https://222cabbage.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>vue2源码</title>
    <link href="https://222cabbage.github.io/2022/07/02/vue2code1/"/>
    <id>https://222cabbage.github.io/2022/07/02/vue2code1/</id>
    <published>2022-07-01T17:37:06.000Z</published>
    <updated>2022-07-17T17:47:01.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue2源码学习"><a href="#Vue2源码学习" class="headerlink" title="Vue2源码学习"></a>Vue2源码学习</h2><p>感觉工作了几个月了，也该看一看源码了，然后就捣鼓出了个盗版vue.js</p><p>实现的功能有模板渲染，生命周期，数据劫持，双向绑定，添加点击事件等很基础的功能，下面是源码</p><p>每天看掘金上的源码理论讲解，什么compile和watcher之类的看麻了，实现一下之后就有很大的感悟</p><p>首先在Vue的类中将$el和$data挂载在实例对象上，方便后续的操作</p><p>模板的编译思想就是，设置正则匹配，获取根节点后，再去获取根节点的子节点，循环去匹配文本节点，利用字符串的replace方法结合正则表达式，匹配到设置了模板字符串的文本节点和键，再利用键从data中获取相应值去替换文本节点</p><p>生命周期简单些，就是传递几个函数，判断类型，如果是函数就执行，顺序不能随便放，执行顺序是固定的，后期需要通过bind改变this指向</p><p>这是html内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">copyvye.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123; str &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; b &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;modelStr&quot;&gt;</span><br><span class="line">        &lt;button @click=&quot;changeStr&quot;&gt;change str&lt;/button&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123; modelStr &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./copyVue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                str:&#x27;hao hello&#x27;,</span><br><span class="line">                b:&#x27;好嗨欧&#x27;,</span><br><span class="line">                modelStr:&#x27;v-model关联字符&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                changeStr()&#123;</span><br><span class="line">                    this.str = &#x27;我终于更新了&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            beforeCreate() &#123;</span><br><span class="line">                console.log(&#x27;beforeCreate&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            created() &#123;</span><br><span class="line">                console.log(&#x27;created&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            beforeMount() &#123;</span><br><span class="line">                console.log(&#x27;beforeMount&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            mounted() &#123;</span><br><span class="line">                console.log(&#x27;mounted&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这是copyVue.js内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">copyVue.js</span><br><span class="line">class Vue &#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        if(typeof options.beforeCreate === &#x27;function&#x27;)&#123;</span><br><span class="line">            options.beforeCreate.bind(this)()</span><br><span class="line">        &#125;</span><br><span class="line">        this.$options = options</span><br><span class="line">        this.$data = options.data</span><br><span class="line">        this.$watchEvent = &#123;&#125;</span><br><span class="line">        this.proxyData()</span><br><span class="line">        this.observe()</span><br><span class="line">        if(typeof options.created === &#x27;function&#x27;)&#123;</span><br><span class="line">            options.created.bind(this)()</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof options.beforeMount === &#x27;function&#x27;)&#123;</span><br><span class="line">            options.beforeMount.bind(this)()</span><br><span class="line">        &#125;</span><br><span class="line">        this.$el = document.querySelector(options.el)</span><br><span class="line">        if(typeof options.mounted === &#x27;function&#x27;)&#123;</span><br><span class="line">            options.mounted.bind(this)()</span><br><span class="line">        &#125;</span><br><span class="line">        this.compile(this.$el)</span><br><span class="line">    &#125;</span><br><span class="line">    // 劫持数据 此时并未更新视图</span><br><span class="line">    proxyData()&#123;</span><br><span class="line">        for(let key in this.$data)&#123;</span><br><span class="line">            Object.defineProperty(this,key,&#123;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return this.$data[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                set(val)&#123;</span><br><span class="line">                    this.$data[key] = val</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 数据被修改但是视图并未更新</span><br><span class="line">    observe()&#123;</span><br><span class="line">        for(let key in this.$data)&#123;</span><br><span class="line">            let value = this.$data[key]</span><br><span class="line">            let that = this</span><br><span class="line">            Object.defineProperty(this.$data,key,&#123;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return value</span><br><span class="line">                &#125;,</span><br><span class="line">                set(val)&#123;</span><br><span class="line">                    value = val</span><br><span class="line">                    if(that.$watchEvent[key])&#123;</span><br><span class="line">                        that.$watchEvent[key].forEach(item =&gt; &#123;</span><br><span class="line">                            item.update()</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compile(node)&#123;</span><br><span class="line">        let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g;</span><br><span class="line">        node.childNodes.forEach(item =&gt; &#123;</span><br><span class="line">            // 首先需要判断节点类型</span><br><span class="line">            if(item.nodeType === 1)&#123;</span><br><span class="line">                if(item.hasAttribute(&#x27;@click&#x27;))&#123;</span><br><span class="line">                    let vmKey = item.getAttribute(&#x27;@click&#x27;).trim()</span><br><span class="line">                    item.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123;</span><br><span class="line">                        this.eventFn = this.$options.methods[vmKey].bind(this)</span><br><span class="line">                        this.eventFn(event)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                if(item.hasAttribute(&#x27;v-model&#x27;))&#123;</span><br><span class="line">                    let vmKey = item.getAttribute(&#x27;v-model&#x27;).trim()</span><br><span class="line">                    if(this.hasOwnProperty(vmKey))&#123;</span><br><span class="line">                        item.value = this[vmKey]</span><br><span class="line">                    &#125;</span><br><span class="line">                    item.addEventListener(&#x27;input&#x27;,(event)=&gt;&#123;</span><br><span class="line">                        this[vmKey] = item.value</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                if(item.childNodes.length &gt; 0)&#123;</span><br><span class="line">                   this.compile(item) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(item.nodeType === 3)&#123;</span><br><span class="line">                // 使用另外一个变量保存文本节点的内容</span><br><span class="line">                let nodeContent = item.textContent</span><br><span class="line">                item.textContent = nodeContent.replace(reg,(match,vmKey)=&gt;&#123;</span><br><span class="line">                    vmKey = vmKey.trim()</span><br><span class="line">                    if(this.hasOwnProperty(vmKey))&#123;</span><br><span class="line">                        let watcher = new Watch(this,vmKey,item,&#x27;textContent&#x27;)</span><br><span class="line">                        if(this.$watchEvent[vmKey])&#123;</span><br><span class="line">                            this.$watchEvent[vmKey].push(watcher)</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            this.$watchEvent[vmKey] = []</span><br><span class="line">                            this.$watchEvent[vmKey].push(watcher)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return this.$data[vmKey]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Watch &#123;</span><br><span class="line">    constructor(vm,key,node,attr)&#123;</span><br><span class="line">        this.vm = vm</span><br><span class="line">        this.key = key</span><br><span class="line">        this.node = node</span><br><span class="line">        this.attr = attr</span><br><span class="line">    &#125;</span><br><span class="line">    update()&#123;</span><br><span class="line">        this.node[this.attr] = this.vm[this.key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loading……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue2源码学习&quot;&gt;&lt;a href=&quot;#Vue2源码学习&quot; class=&quot;headerlink&quot; title=&quot;Vue2源码学习&quot;&gt;&lt;/a&gt;Vue2源码学习&lt;/h2&gt;&lt;p&gt;感觉工作了几个月了，也该看一看源码了，然后就捣鼓出了个盗版vue.js&lt;/p&gt;
&lt;p&gt;实现的</summary>
      
    
    
    
    <category term="vue框架源码" scheme="https://222cabbage.github.io/categories/vue%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Vue2源码" scheme="https://222cabbage.github.io/tags/Vue2%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
